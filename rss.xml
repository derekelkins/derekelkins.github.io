<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Hedonistic Learning</title>
        <link>https://derekelkins.github.io</link>
        <description><![CDATA[Mostly math, physics, and CS]]></description>
        <atom:link href="https://derekelkins.github.io/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Thu, 01 Mar 2018 04:35:14 UT</lastBuildDate>
        <item>
    <title>The Pedagogy of Logic: A Rant</title>
    <link>https://derekelkins.github.io/posts/the-pedagogy-of-logic-a-rant.html</link>
    <description><![CDATA[<h3 id="introduction">Introduction</h3>
<p>Over the years I’ve seen a lot of confusion about formal logic online. Usually this is from students (but I’ve also seen it with experienced mathematicians) on platforms like the Math or CS StackExchange. Now there is clearly some selection bias where the people asking the questions are the people who are confused, but while the questions <em>about</em> the confusions are common, the confusions are often evident even in questions about other aspects, the confusions are <em>in the (upvoted!) answers</em>, and when you look at the study material they are using it is often completely unsurprising that they are confused. Again, these confusions are also not limited to just “students”, though I’ll use that word in a broad sense below. Finally, on at least one of the points below, the confusion seems to be entirely on the instructors’ side.</p>
<p>To give an indication of the problem, here is my strong impression of what would happen if I gave a student who had just passed a full year introduction to formal logic the following exercise: “Give me a formal proof of #(neg P =&gt; neg Q) =&gt; (Q =&gt; P)#”. I suspect most would draw up a truth table. When I responded, “that’s not a formal proof,” they would be confused. If you are confused by that response, then this is definitely for you. I’m sure they would completely agree with me that if I asked for the inverse matrix of some matrix #M#, showing that the determinant of #M# is non-zero does not constitute an answer to that question. The parallelism of these scenarios would likely be lost on them though. While I think courses that focus on a syntactic approach to logic will produce students that are much more likely to give an appropriate answer to my exercise, that doesn’t mean they lack the confusions, just that this exercise isn’t a good discriminator for them. For example, if they don’t see the parallelism of the two scenarios I described, or worse, have no idea what truth tables have to do with anything, then they have some gap.</p>
<p>As a disclaimer, I am not an educator nor even an academic in any professional capacity.</p>
<p>As a summary, the points I will touch on are:</p>
<ul>
<li><a href="#syntax-versus-semantics">Not <em>continually</em> emphasizing the distinction between syntax and semantics</a>.</li>
<li><a href="#unnecessary-philosophizing">Unnecessary philosophizing</a>.</li>
<li><a href="#the-complete-absence-of-non-classical-logics">The complete absence of non-classical logics</a>.</li>
<li><a href="#silly-linguistics">Silly linguistics exercises</a>.</li>
<li><a href="#the-complete-conflation-of-negation-introduction-with-double-negation-elimination">The complete conflation of negation introduction with double negation elimination</a>.</li>
<li><a href="#smaller-issues">Some smaller issues that are not so bad and some missed opportunities</a>.</li>
</ul>
<p>If anyone reading this is aware of <em>introductory</em> textbooks or other resources (ideally freely available, but I’ll take a reasonably priced textbook too) that avoid most or all of the major issues I list and otherwise do a good job, I would be very interested. My own education on these topics has been piecemeal and eclectic and also strongly dependent on my background in programming. This leaves me with no reasonable recommendations. Please leave a comment or email me, if you have such a recommendation.</p>
<!--more-->
<h3 id="syntax-versus-semantics">Syntax versus Semantics</h3>
<p>The distinction between syntax and semantics is fundamental in logic. Many, many students, on the other hand, seem completely unaware of the distinction. The most blatant form of this is that for many students it seems quite clear that “proving a formula true” <em>means</em> plugging in truth values and seeing that the result is always “true”. Often they (seemingly) think a truth table <em>is</em> a formal proof. They find it almost impossible to state what the difference between provable and “true” is. The impression I get from some is that they think plugging truth values into formulas <em>is</em> what logic is about.</p>
<p>If the students get to classical predicate logic, most of these misunderstandings will be challenged, but students with this misunderstanding will struggle unnecessarily, and you can see this on sites like <a href="https://math.stackexchange.com">math.stackexchange.com</a> where questioners <a href="https://math.stackexchange.com/q/2646421/305738">present attempts to prove statements of predicate logic by reducing them to propositional statements</a>. It’s not clear to me what typically happens to students with such misunderstandings as they gain proficiency with classical predicate logic. Certainly some clear up their misunderstanding, but since it’s clear that some still have a slippery grasp of the distinction between syntax and semantics, some misunderstanding remains for them. My guess would be that many just view classical propositional logic and classical predicate logic as more different than they are with unrelated approaches to proof. Any instructors reading this can probably describe much stranger rationalizations that students have come up with, and perhaps give some indications of what faulty rationalizations are common.</p>
<p>Speaking of instructors, the pedagogical problem I see here is not that the textbook authors and instructors don’t understand these distinctions, or even that they don’t <em>present</em> these distinctions, but that they don’t continually <em>emphasize</em> these distinctions. Maybe they do in the classroom, but going by the lecture notes or books, the notation and terminology that many use make it <em>very</em> easy to conflate syntax and semantics. For understandable reasons, proofs of the soundness and completeness theorems that are necessary to justify this conflation are pushed off until much later.</p>
<p>I googled <code>lecture notes &quot;classical propositional logic&quot;</code> and looked at the <a href="http://www.philosophy.ed.ac.uk/undergraduate/documents/Propositional_Logic_2008_09.pdf">first hit I got</a>. It clearly has a section on semantics and multiple sections on a (syntactic) deductive system “helpfully” named “semantic tableaux”. It bases all concepts on truth tables introduced in section 4. Later concepts are justified by corresponding to the truth table semantics. Here is how it describes the semantics for negation:</p>
<blockquote>
<p>A negation #neg A# is <strong>true</strong> (in any situation) if and only if #A# is <strong>not true</strong> (in that situation).</p>
</blockquote>
<p>This is followed by the sentence: “For the moment, we shall suppress the qualifier ‘in any situation’[…]”, and we get the rules for the other connectives starting with the one for conjunction:</p>
<blockquote>
<p>A conjunction #A ^^ B# is <strong>true</strong> if and only if #A# is true and #B# is true.</p>
</blockquote>
<p>It later explicates the “in any situation” by talking about truth-value assignments and giving “rules” like:</p>
<blockquote>
<p>#A ^^ B# is true in an assignment iff #A# and #B# are true in that assignment.</p>
</blockquote>
<p>Between these two renditions of the rule for conjunction, the notes tell us what a “truth-value” is and seemingly what “is true” means with the following text:</p>
<blockquote>
<p>In classical propositional logic, formulas may have only <strong>one</strong> of two possible “<strong>truth values</strong>”. Each formula must be <strong>either true</strong> or <strong>false</strong>; and no formula may be both true and false. These values are written <strong>T</strong> and <strong>F</strong>. (Some authors use #1# and #0# instead. Nothing hinges on this.)</p>
</blockquote>
<p>The description so far makes it sound like logical formula are “expressions” which “compute” to <strong>true</strong> or <strong>false</strong>, which will also be written <strong>T</strong> or <strong>F</strong>, like arithmetical expressions. This is made worse in section 11 where the connectives are identified with truth-functions (which is only mentioned in this early section). It would be better to have a notation to distinguish a formula from its truth value e.g. #v(A)# or, the notation I like, |[\! [A]\!]|. (As I’ll discuss in the next section, it would also be better to avoid using philosophically loaded terms like “true” and “false”. #1# and #0# are better choices, but if you <em>really</em> wanted to drive the point home, you could use arbitrary things like “dog” and “cat”. As the authors state, “nothing hinges on this”.) Rewording the above produces a result that I believe is much harder to misunderstand.</p>
<blockquote>
<p>#v(A ^^ B)=1# if and only if #v(A)=1# and #v(B)=1#.</p>
</blockquote>
<p>This is likely to be perceived as less “intuitive” to students, but I strongly suspect the seeming cognitive ease was masking actually grappling with what is being said in the earlier versions of the statement. If we actually want to introduce truth functions, I would highly recommend using different notation for them, for example:</p>
<blockquote>
<p><code class="asciimath">#v(A ^^ B)=sf &quot;and&quot;(v(A),v(B))#.</code></p>
</blockquote>
<p>Of course, we can interpret “#A# is true” as defining a unary predicate on formulas, “_ is true”, but I seriously doubt this is where most students’ minds jump to when being introduced to formal logic, and this view is undermined by the notion of “truth values”. Again, I’m not saying the authors are saying things that are <em>wrong</em>, I’m saying that they make it very easy to misunderstand what is going on.</p>
<p>Following this, most of the remainder of the notes discusses the method of semantic tableaux. It mentions soundness and completeness but also states: “In this introductory course, we do not expect you to study the proof of these two results[.]”) At times it suggests that the tableaux method can stand on its own: “However, we can show that it is inconsistent <strong>without using a truth table</strong>, by a form of <strong>deductive reasoning</strong>. That is, by following computer-programmable <strong>inference rules</strong>.” But the method is largely presented as summarizing semantic arguments: “This rule just summarizes the information in the truth table that…” In my ideal world, this more deductive approach would be clearly presented as an <em>alternative</em> approach to thinking about logic with the inference rules not explained in terms of semantic notions but related to them after the fact.</p>
<p>My point isn’t to pick on these notes which seem reasonable enough overall. They have some of the other issues I’ll cover but also include some of the things I’d like to see in such texts.</p>
<h3 id="unnecessary-philosophizing">Unnecessary Philosophizing</h3>
<p>As mentioned in the previous section, words like “true” and “false” have a huge philosophical weight attached to them. It is quite easy to define any particular logic either syntactically or semantically without even suggesting the identification of anything with the philosophical notion of “truth”. My point isn’t that philosophy should be banished from a mathematical logic course, though that <em>is</em> an option, but that we can <em>separate</em> the definition of a logical system with how it relates to the intuitive or philosophical notion of “truth”. This allows us to present logics as the mathematical constructions they are and not feel the need to justify why any given rules/semantics really are the “right” ones.</p>
<p>(As an aside, while I did read introductions to logic early on, the beginnings of my in-depth understanding of logic arose via programming language theory and type systems [and then category theory]. These areas often cover the same concepts and systems but with little to no philosophizing. Papers discuss classical and constructive logics with no philosophical commitment for or against the law of excluded middle being remotely implied.)</p>
<p>Of course, we do want to leverage our intuitive understanding of logic to motivate either the inference rules or the chosen semantics, but we can phrase the definitions as being <em>inspired by</em> the intuition rather than codifying it. Things like the <a href="https://math.stackexchange.com/q/232309/305738">common misgivings</a> students (and <a href="https://en.wikipedia.org/wiki/Material_conditional#Philosophical_problems_with_material_conditional">others</a>) have about material implication are a lot easier to deal with when logic isn’t presented as “The One True Formulation of Correct Reasoning”. Of course another way to undermine this impression would be to present a variety of logics including ones where material implication doesn’t hold. This is also confounded by unnecessary philosphizing. It makes it seem like non-classical logics are only of interest to crazy contrarians who reject “self-evident” “truths” like every statement is either “true” or “false”. While there definitely is a philosophical discussion that could be had here, there are plenty of <em>mathematical</em> reasons to be interested in non-classical logics regardless of your philosophical stance on truth. Non-classical logics can also shed a lot of light on what’s going on in classical logics.</p>
<p>This assumes non-classical logics are even mentioned at all.</p>
<h3 id="the-complete-absence-of-non-classical-logics">The Complete Absence of Non-Classical Logics</h3>
<p>I’m highly confident you can go through many introductory courses on logic and never have any inkling that there are logics other than classical logics. I suspect you can easily go through an entire math major and also be completely unaware of non-classical logics. For an introductory course on logic, I completely understand that time constraints can make it difficult to include any substantial discussion of non-classical logics. I somewhat less forgiving when it comes to textbooks.</p>
<p>What bothers me isn’t that non-classical logics aren’t given equal time - I wouldn’t expect them to be - it’s that classical logic is presented as a comprehensive picture of logic. This is likely, to some degree, unintentional, but it is easily fixable. First, at the beginning of the course, simply mention that the course will cover classical logics and there are other logics like constructive or paraconsistent logics that have different rules and different notions of semantics. Use less encompassing language. Instead of saying “logic”, say “a logic” or “the logic we’re studying”. Similarly, talk about “<em>a</em> semantics” rather than “<em>the</em> semantics”, and “<em>a</em> set of rules” rather than “<em>the</em> rules”. Consistently say “<em>classical</em> propositional/first-order/predicate logic” rather than just “propositional/first-order/predicate logic” or worse just “logic”. Note points where non-classical logics make different choices when the topics come up. For example, that truth tables are a semantics for classical propositional logic while non-classical logics will use a different notion of semantics. The law of excluded middle, indirect proof, and material implication are other areas where a passing mention of how different logics make different decisions about these topics could be made. The principle of explosion, related to the issues with material implication, is an interesting point where classical and constructive logics typically agree while paraconsistent logics differ. Heck, I suspect some people find my use of the plural, “logics”, jarring, as if there could be more than one logic. Fancy that!</p>
<p>The goal with this advice is just to indicate to students that there is a wider world of logic out there. I don’t expect students to be quizzed on this. Some of this advice is relevant even purely for classical logics. It’s not uncommon for people to ask questions on the Math StackExchange asking for a proof of some formula. When asked what rules they are using, they seem confused: “The rules of predicate logic(?!)” The idea that the presentation of (classical) predicate logic that they were given is only one of many possibilities seems never to have occurred to them. Similarly for semantics. So generally when a choice is made, it would seem of long-term pedagogical value to at least mention that a choice has been made and that other choices are possible.</p>
<h3 id="silly-linguistics">Silly Linguistics</h3>
<p>Nearly any week on the Math StackExchange you can <a href="https://math.stackexchange.com/q/2270547/305738">find</a> <a href="https://math.stackexchange.com/q/2536711/305738">someone</a> <a href="https://math.stackexchange.com/q/2589373/305738">asking</a> <a href="https://math.stackexchange.com/q/2549016/305738">about</a> an <a href="https://math.stackexchange.com/q/2658713/305738">exercise like the following</a>:</p>
<blockquote>
<p>Translate “Jan likes Sally but not Alice” to a logical formula.</p>
</blockquote>
<p>Exercises like these are just a complete and utter waste of time. The only people who <em>might</em> do something like this are linguists. Even then the “linguistics” presented in introductions to formal logic is (understandably) ridiculously naive, and an introductory course on formal logic is simply not the place for it anyway. What the vast majority of consumers of formal logic <em>do</em> need is to 1) be able to understand what <em>formal</em> expressions mean, and 2) be able to present <em>their own thoughts</em> formally. Even when formalizing another person’s informal proof, the process is one of understanding what the person was saying and then writing down your understanding in formal language. Instead what’s presented is rules-of-thumb like “‘but’ means ‘and’”.</p>
<p>I could understand having an in-class discussion where the instructor presents natural language statements and asks students interactively to provide various interpretations of the statements. The ambiguity in natural language should quickly become apparent and this motivates the introduction of unambiguous formal notation. What makes no sense to me is giving students sheets of natural language statements about everyday situations that they need to “formalize” and grading them on this. Even if this was valuable, which I don’t think it is, the opportunity cost of spending time on this rather than some other topic would make it negatively valued to me.</p>
<p>What is fine is telling students how to <em>read</em> formal notation in natural language as long as it’s clear that these readings are not definitions. I have <a href="https://math.stackexchange.com/q/2596766/305738">seen people</a> claim that e.g. #A =&gt; B# is <em>defined</em> as “if #A#, then #B#”, but this is likely a misunderstanding on their part and not what their instructors or books said. On the other hand, it doesn’t seem too rare for a textbook to present a logical connective and then explicate it in terms of natural language examples shortly before or after providing a more formal definition (via rules or semantics). I don’t find it completely surprising that some students confuse these examples as definitions especially when the actual definitions, at times, don’t look terribly different from schematic phrases of natural languages.</p>
<p>I think natural language examples, and especially everyday as opposed to mathematical examples, should largely be avoided, or at the very least should be used with care.</p>
<h3 id="the-complete-conflation-of-negation-introduction-with-double-negation-elimination">The Complete Conflation of Negation Introduction with Double Negation Elimination</h3>
<p>Negation introduction is the following rule: if by assuming #P# we can produce a contradiction, then we can conclude #neg P#. You could present this as an axiom: <code class="asciimath">#(P =&gt; _|_) =&gt; neg P#</code>.</p>
<p>Double negation elimination is the following rule: if by assuming #neg P# we can produce a contradiction, then we can conclude #P#. You could present this as an axiom: <code class="asciimath">#(neg P =&gt; _|_) =&gt; P#</code> or #neg neg P =&gt; P#.</p>
<p>It seems pretty evident that many experienced mathematicians, let alone instructors and students, don’t see any difference between these. “Proof by contradiction” or “reductio ad absurdum” are often use to ambiguously refer to either of the above rules. This has <a href="http://math.andrej.com/2010/03/29/proof-of-negation-and-proof-by-contradiction/">been discussed</a> a <a href="https://existentialtype.wordpress.com/2017/03/04/a-proof-by-contradiction-is-not-a-proof-that-derives-a-contradiction/">few</a> <a href="https://blog.plover.com/math/IL-contradiction.html">times</a>. When even the likes of Timothy Gowers <a href="https://gowers.wordpress.com/2010/03/28/when-is-proof-by-contradiction-necessary/#comment-6984">does this</a>, I think it is safe to say many others do as well. Or just look at the comments to <a href="http://math.andrej.com/2010/03/29/proof-of-negation-and-proof-by-contradiction/">Andrej’s article</a> which I <em>highly</em> recommend.</p>
<p>As discussed in the referenced articles, and evidenced in the comments, there seems to be two things going on here. First, it seems that many people believe that dropping double negations, i.e. treating #neg neg P# and #P# is just a thing that you can do. They incorrectly reason as follows: substitute #neg P# into <code class="asciimath">#(P =&gt; _|_) =&gt; neg P#</code> to derive <code class="asciimath">#(neg P =&gt; _|_) =&gt; neg neg P#</code> which is the same as <code class="asciimath">#(neg P =&gt; _|_) =&gt; P#</code>. Of course, double negation elimination, the thing they are trying to show follows from negation introduction, is what lets them do that last step in the first place! It’s clear that negation introduction only adds (introduces, if you will) negations and can’t eliminate them. The second is that any informal proof of the form “Suppose #P# … hence a contradiction” is called a “proof by contradiction”.</p>
<p>As alluded to in the articles, people develop and state false beliefs about constructive logics because they are unaware of this distinction. This is an excellent area where exploring non-classical logics can be hugely clarifying. The fact that negation introduction is not only derivable but often <em>axiomatic</em> in constructive logics, while adding double negation elimination to a constructive logic makes it classical, very clearly illustrates that there is a <em>huge</em> difference between these rules. But forget about constructive logics, what’s happening here is many mathematicians are <em>deeply confused</em> about the key thing that makes classical logics classical. Further, students are being <em>taught</em> this confusion. Clearly there is <em>some</em> pedagogical failure occurring here.</p>
<h3 id="smaller-issues">Smaller Issues</h3>
<p>Finally, here are some minor issues that either seem less common or less problematic as well as some potential missed opportunities.</p>
<p>The first is a failure of abstraction I’ve occasionally seen, and I think certain books encourage. I’ve seen students who talk about the “symbols” of their logic as “including …, <code>'('</code>, and <code>')'</code>”. While certainly how to parse strings into syntax trees is a core topic of formal <em>languages</em>, it’s not that important for formal logic. The issues with parsing formulas I see have to do with conventions on omitting parentheses, not an inability to match them. There can be some benefit to driving home that syntax is just inert symbols, but the concept of a syntax tree seems more important and the process of producing a syntax tree for a string of symbols rather secondary. Working at the level of strings adds a lot of complexity and offers little insight into the <em>logical</em> concepts.</p>
<p>As a missed opportunity, there’s a <em>lot</em> of algorithmic content in formal logic. This should come as no surprise as the mechanization of reasoning has been a long time dream of mathematics and was an explicit goal during the birth of formal logic. Unfortunately, if the instructors and/or students don’t have a programming background it can be hard to really leverage this. Still, my impression is that the only indication of the mechanizability of much of logic that students get is in the mechanical drudgery of doing certain exercises. Even when it’s not possible to actually implement some of the relevant ideas, they can still be mentioned. For example, it is often taken as a requirement of a proof system that the proofs can be mechanically verified. That is, we can write a program that takes a formal proof and tells you whether it is a valid proof or not. This should be at least mentioned. Even better, for more than just this reason, it can be experienced by using proof assistants like Coq or MetaMath or simpler things like <a href="http://logitext.mit.edu/main">Logitext</a>. There are other areas of mechanization. Clearly, we can mechanize the process of checking truth tables for classical propositional logic, though there are interesting efficiency aspects to mention here. The completeness theorem of classical propositional logic is also constructively provable producing an algorithm that will take a formula with a truth table showing its validity and will produce a formal proof of that formula. As a little more open-ended topic, much of proof <em>search</em> is mechanical. I’ve often seen students stumped by problems whose proofs can be found in a completely goal-directed manner without any guessing at all.</p>
<p>Another issue is the use of Hilbert-style presentations of logics. It does seem that many logic texts thankfully use natural deduction or some other humane proof system, but Hilbert-style presentations aren’t uncommon. The <em>benefit</em> of Hilbert-style presentations of logics is that they can simplify meta-logical reasoning. But many introductions to logic do little to no meta-logical reasoning. The downsides of Hilbert-style presentations is that they don’t match informal reasoning well, they don’t provide much insight into the logical connectives, and proofs in Hilbert-style proof systems are just painful where even simple results are puzzles. Via the lens of Curry-Howard, Hilbert-style proof systems correspond to combinatory algebras, and writing programs in combinator systems (such as <a href="http://www.madore.org/~david/programs/unlambda/">unlambda</a>) is similarly unpleasant. The fact that introducing logic using a Hilbert-style proof system is formally analogous to introducing programming using an esoteric programming language designed to be obfuscatory says something…</p>]]></description>
    <pubDate>Thu, 01 Mar 2018 04:35:14 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/the-pedagogy-of-logic-a-rant.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>
<item>
    <title>Djinn in your browser</title>
    <link>https://derekelkins.github.io/posts/djinn.html</link>
    <description><![CDATA[<p>I couldn’t find an online version of Djinn, so I ran it through GHCJS with some tweaks, added a basic interface and hosted it <a href="/djinn/">here</a>. It runs in your browser, so go crazy. If you want changes to the default settings or environment, feel free to suggest them. Right now everything is the default settings of the Djinn tool except that multiple results is enabled.</p>]]></description>
    <pubDate>Sun, 09 Apr 2017 12:35:18 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/djinn.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>
<item>
    <title>Category Theory, Syntactically</title>
    <link>https://derekelkins.github.io/posts/category-theory-syntactically.html</link>
    <description><![CDATA[<h4 id="or-how-model-theory-got-scooped-by-category-theory">(or: How Model Theory Got Scooped by Category Theory)</h4>
<h2 id="overview">Overview</h2>
<p>This will be a <em>very</em> non-traditional introduction to the ideas behind category theory. It will essentially be a slice through model theory (presented in a more programmer-friendly manner) with an unusual organization. Of course the end result will be <strong>***SPOILER ALERT***</strong> it was category theory all along. A secret decoder ring will be provided at the end. This approach is inspired by the notion of an internal logic/language and by Vaughn Pratt’s paper <a href="http://boole.stanford.edu/pub/yon.pdf">The Yoneda Lemma Without Category Theory</a>. <!-- \* --></p>
<p>I want to be very clear, though. This is not meant to be an analogy or an example or a guide for intuition. This <em>is</em> category theory. It is simply presented in a different manner.</p>
<p>Dan Doel pointed me at some draft lecture notes by Mike Shulman that seem very much in the spirit of this blog post (albeit aimed at an audience familiar with category theory): <a href="https://mikeshulman.github.io/catlog/catlog.pdf">Categorical Logic from a Categorical Point of View</a>. A theory in my sense corresponds to a category presentation (Definition 1.7.1) as defined by these lecture notes. Its oft-mentioned Appendix A will also look very familiar.</p>
<!--more-->
<h2 id="theories">Theories</h2>
<p>The first concept we’ll need is that of a theory. If you’ve ever implemented an interpreter for even the simplest language, then most of what follows modulo some terminological differences should be both familiar and very basic. If you are familiar with algebraic semantics, then that is exactly what is happening here only restricting to unary (but multi-sorted) algebraic theories.</p>
<p>For us, a <strong>theory</strong>, #ccT#, is a collection of <strong>sorts</strong>, a collection of (unary) <strong>function symbols</strong><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, and a collection of <strong>equations</strong>. Each function symbol has an input sort and an output sort which we’ll call the <strong>source</strong> and <strong>target</strong> of the function symbol. We’ll write #ttf : A -&gt; B# to say that #ttf# is a function symbol with source #A# and target #B#. We define <code class="asciimath">#&quot;src&quot;(ttf) -= A#</code> and <code class="asciimath">#&quot;tgt&quot;(ttf) -= B#</code>. Sorts and function symbols are just symbols. Something is a sort if it is in the collection of sorts. Nothing else is required. A function symbol is not a function, it’s just a, possibly structured, name. Later, we’ll map those names to functions, but the same name may be mapped to different functions. In programming terms, a theory defines an interface or signature. We’ll write <code class="asciimath">#bb &quot;sort&quot;(ccT)#</code> for the collection of sorts of #ccT# and <code class="asciimath">#bb &quot;fun&quot;(ccT)#</code> for the collection of function symbols.</p>
<p>A (raw) <strong>term</strong> in a theory is either a <strong>variable</strong> labelled by a sort, #bbx_A#, or it’s a function symbol applied to a term, <code class="asciimath">#tt &quot;f&quot;(t)#</code>, such that the sort of the term #t# matches the source of #ttf#. The sort or target of a term is the sort of the variable if it’s a variable or the target of the outermost function symbol. The source of a term is the sort of the innermost variable. In fact, all terms are just sequences of function symbol applications to a variable, so there will always be exactly one variable. All this is to say the expressions need to be “well-typed” in the obvious way. Given a theory with two function symbols #ttf : A -&gt; B# and #ttg : B -&gt; A#, <code class="asciimath">#bbx_A#</code>, <code class="asciimath">#bbx_B#</code> , <code class="asciimath">#tt &quot;f&quot;(bbx_A)#</code>, and <code class="asciimath">#tt &quot;f&quot;(tt &quot;g&quot;(tt &quot;f&quot;(bbx_A)))#</code> are all examples of terms. <code class="asciimath">#tt &quot;f&quot;(bbx_B)#</code> and <code class="asciimath">#tt &quot;f&quot;(tt &quot;f&quot;(bbx_A))#</code> are not terms because they are not “well-typed”, and #ttf# by itself is not a term simply because it doesn’t match the syntax. Using Haskell syntax, we can define a data type representing this syntax if we ignore the sorting:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Term</span> <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">Sort</span> <span class="fu">|</span> <span class="dt">Apply</span> <span class="dt">FunctionSymbol</span> <span class="dt">Term</span></code></pre></div>
<p>Using GADTs, we could capture the sorting constraints as well:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Term</span> (<span class="ot">s ::</span> <span class="dt">Sort</span>) (<span class="ot">t ::</span> <span class="dt">Sort</span>) <span class="kw">where</span>
    <span class="dt">Var</span><span class="ot"> ::</span> <span class="dt">Term</span> t t
    <span class="dt">Apply</span><span class="ot"> ::</span> <span class="dt">FunctionSymbol</span> x t <span class="ot">-&gt;</span> <span class="dt">Term</span> s x <span class="ot">-&gt;</span> <span class="dt">Term</span> s t</code></pre></div>
<p>An important operation on terms is <strong>substitution</strong>. Given a term #t_1# with source #A# and a term #t_2# with target #A# we define the substitution of #t_2# into #t_1#, written #t_1[bbx_A |-&gt; t_2]#, as:</p>
<blockquote>
<p>If #t_1 = bbx_A# then #bbx_A[bbx_A |-&gt; t_2] -= t_2#.</p>
<p>If <code class="asciimath">#t_1 = tt &quot;f&quot;(t)#</code> then <code class="asciimath">#tt &quot;f&quot;(t)[bbx_A |-&gt; t_2] -= tt &quot;f&quot;(t[bbx_A |-&gt; t_2])#</code>.</p>
</blockquote>
<p>Using the theory from before, we have:</p>
<blockquote>
<p><code class="asciimath">#tt &quot;f&quot;(bbx_A)[bbx_A |-&gt; tt &quot;g&quot;(bbx_B)] = tt &quot;f&quot;(tt &quot;g&quot;(bbx_B))#</code></p>
</blockquote>
<p>As a shorthand, for arbitrary terms #t_1# and #t_2#, #t_1(t_2)# will mean <code class="asciimath">#t_1[bbx_(&quot;src&quot;(t_1)) |-&gt; t_2]#</code>.</p>
<p>Finally, equations<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>. An <strong>equation</strong> is a pair of terms with equal source and target, for example, <code class="asciimath">#(: tt &quot;f&quot;(tt &quot;g&quot;(bbx_B)), bbx_B :)#</code>. The idea is that we want to identify these two terms. To do this we <a href="../posts/quotient-types-for-programmers.html">quotient</a> the set of terms by the congruence generated by these pairs, i.e. by the reflexive-, symmetric-, transitive-closure of the relation generated by the equations which further satisfies “if #s_1 ~~ t_1# and #s_2 ~~ t_2# then <code class="asciimath">#s_1(s_2) ~~ t_1(t_2)#</code>”. From now on, by “terms” I’ll mean this quotient with “raw terms” referring to the unquotiented version. This means that when we say “<code class="asciimath">#tt &quot;f&quot;(tt &quot;g&quot;(bbx_B)) = bbx_B#</code>”, we really mean the two terms are congruent with respect to the congruence generated by the equations. We’ll write #ccT(A, B)# for the collection of terms, in this sense, with source #A# and target #B#. To make things look a little bit more normal, I’ll write #s ~~ t# as a synonym for #(: s, t :)# when the intent is that the pair represents a given equation.</p>
<p>Expanding the theory from before, we get the <strong>theory of isomorphisms</strong>, <code class="asciimath">#ccT_{:~=:}#</code>, consisting of two sorts, #A# and #B#, two function symbols, #ttf# and #ttg#, and two equations <code class="asciimath">#tt &quot;f&quot;(tt &quot;g&quot;(bbx_B)) ~~ bbx_B#</code> and <code class="asciimath">#tt &quot;g&quot;(tt &quot;f&quot;(bbx_A)) ~~ bbx_A#</code>. The equations lead to equalities like <code class="asciimath">#tt &quot;f&quot;(tt &quot;g&quot;(tt &quot;f&quot;(bbx_A))) = tt &quot;f&quot;(bbx_A)#</code>. In fact, it doesn’t take much work to show that this theory only has four distinct terms: #bbx_A#, #bbx_B#, <code class="asciimath">#tt &quot;f&quot;(bbx_A)#</code>, and <code class="asciimath">#tt &quot;g&quot;(bbx_B)#</code>.</p>
<p>In traditional model theory or universal algebra we tend to focus on multi-ary operations, i.e. function symbols that can take multiple inputs. By restricting ourselves to only unary function symbols, we expose a duality. For every theory #ccT#, we have the <strong>opposite theory</strong>, #ccT^(op)# defined by using the same sorts and function symbols but swapping the source and target of the function symbols which also requires rewriting the terms in the equations. The rewriting on terms is the obvious thing, e.g. if #ttf : A -&gt; B#, #ttg : B -&gt; C#, and #tth : C -&gt; D#, then the term in #ccT#, <code class="asciimath">#tt &quot;h&quot;(tt &quot;g&quot;(tt &quot;f&quot;(bbx_A)))#</code> would become the term <code class="asciimath">#tt &quot;f&quot;(tt &quot;g&quot;(tt &quot;h&quot;(bbx_D)))#</code> in #ccT^(op)#. From this it should be clear that <code class="asciimath">#(ccT^(op))^(op) = ccT#</code>.</p>
<h2 id="product-theories">Product Theories</h2>
<p>Given two theories #ccT_1# and #ccT_2# we can form a new theory #ccT_1 xx ccT_2# called the <strong>product theory</strong> of #ccT_1# and #ccT_2#. The sorts of this theory are pairs of sorts from #ccT_1# and #ccT_2#. The collection of function symbols is the <em>disjoint union</em> <code class="asciimath">#bb &quot;fun&quot;(ccT_1) xx bb &quot;sort&quot;(ccT_2) + bb &quot;sort&quot;(ccT_1) xx bb &quot;fun&quot;(ccT_2)#</code>. A disjoint union is like Haskell’s <code>Either</code> type. Here we’ll write <code class="asciimath">#tt &quot;inl&quot;#</code> and <code class="asciimath">#tt &quot;inr&quot;#</code> for the left and right injections respectively. <code class="asciimath">#tt &quot;inl&quot;#</code> takes a function symbol from #ccT_1# and a sort from #ccT_2# and produces a function symbol of #ccT_1 xx ccT_2# and similarly for <code class="asciimath">#tt &quot;inr&quot;#</code>. If <code class="asciimath">#tt &quot;f&quot; : A -&gt; B#</code> in #ccT_1# and #C# is a sort of #ccT_2#, then <code class="asciimath">#tt &quot;inl&quot;(f, C) : (A, C) -&gt; (B, C)#</code> and similarly for <code class="asciimath">#tt &quot;inr&quot;#</code>.</p>
<p>The collection of equations for #ccT_1 xx ccT_2# consists of the following:</p>
<ul>
<li>for every equation, #l ~~ r# of #ccT_1# and every sort, #C#, of #ccT_2# we produce an equation #l’ ~~ r’# by replacing each function symbol #ttf# in #l# and #r# with <code class="asciimath">#tt &quot;inl&quot;(tt &quot;f&quot;, C)#</code></li>
<li>similarly for equations of #ccT_2#</li>
<li>for every pair of function symbols #ttf : A -&gt; B# from #ccT_1# and #ttg : C -&gt; D# from #ccT_2#, we produce the equation <code class="asciimath">#tt &quot;inl&quot;(tt &quot;f&quot;, D)(tt &quot;inr&quot;(A, tt &quot;g&quot;)(bbx_{:(A, C&quot;)&quot;:})) ~~ tt &quot;inr&quot;(B, tt &quot;g&quot;)(&quot;inl&quot;(tt &quot;f&quot;, C)(bbx_{:(A, C&quot;)&quot;:}))#</code></li>
</ul>
<p>The above is probably unreadable. If you work through it, you can show that every term of #ccT_1 xx ccT_2# is equivalent to a pair of terms #(t_1, t_2)# where #t_1# is a term in #ccT_1# and #t_2# is a term in #ccT_2#. Using this equivalence, the first bullet is seen to be saying that if #l = r# in #ccT_1# and #C# is a sort in #ccT_2# then #(l, bbx_C) = (r, bbx_C)# in #ccT_1 xx ccT_2#. The second is similar. The third then states</p>
<blockquote>
<p><code class="asciimath">#(t_1, bbx_C)((bbx_A, t_2)(bbx_{:&quot;(A, C)&quot;:})) = (t_1, t_2)(bbx_{:&quot;(A, C)&quot;:}) = (bbx_A, t_2)((t_1, bbx_C)(bbx_{:&quot;(A, C)&quot;:}))#</code>.</p>
</blockquote>
<p>To establish the equivalence between terms of #ccT_1 xx ccT_2# and pairs of terms from #ccT_1# and #ccT_2#, we use the third bullet to move all the <code class="asciimath">#tt &quot;inl&quot;#</code>s outward at which point we’ll have a sequence of #ccT_1# function symbols followed by a sequence of #ccT_2# function symbols each corresponding to term.</p>
<p>The above might seem a bit round about. An alternative approach would be to define the function symbols of #ccT_1 xx ccT_2# to be all pairs of all the <em>terms</em> from #ccT_1# and #ccT_2#. The problem with this approach is that it leads to an <em>explosion</em> in the number of function symbols and equations required. In particular, it easily produces an infinitude of function symbols and equations even when provided with theories that only have a finite number of sorts, function symbols, and equations.</p>
<p>As a concrete and useful example, consider the theory #ccT_bbbN# consisting of a single sort, #0#, a single function symbol, #tts#, and no equations. This theory has a term for each natural number, #n#, corresponding to #n# applications of #tts#. Now let’s articulate #ccT_bbbN xx ccT_bbbN#. It has one sort, #(0, 0)#, two function symbols, <code class="asciimath">#tt &quot;inl&quot;(tt &quot;s&quot;, 0)#</code> and <code class="asciimath">#tt &quot;inr&quot;(0, tt &quot;s&quot;)#</code>, and it has one equation, <code class="asciimath">#tt &quot;inl&quot;(tt &quot;s&quot;, 0)(tt &quot;inr&quot;(0, tt &quot;s&quot;)(bbx_{:(0, 0&quot;)&quot;:})) ~~ tt &quot;inr&quot;(0, tt &quot;s&quot;)(tt &quot;inl&quot;(tt &quot;s&quot;, 0)(bbx_{:(0, 0&quot;)&quot;:}))#</code>. Unsurprisingly, the terms of this theory correspond to pairs of natural numbers. If we had used the alternative definition, we’d have had an infinite number of function symbols and an infinite number of equations.</p>
<p>Nevertheless, for clarity I will typically write a term of a product theory as a pair of terms.</p>
<p>As a relatively easy exercise — easier than the above — you can formulate and define the disjoint sum of two theories #ccT_1 + ccT_2#. The idea is that every term of #ccT_1 + ccT_2# corresponds to either a term of #ccT_1# or a term of #ccT_2#. Don’t forget to define what happens to the equations.</p>
<p>Related to these, we have the theory #ccT_{:bb1:}#, which consists of one sort and no function symbols or equations, and #ccT_{:bb0:}# which consists of no sorts and thus no possibility for function symbols or equations. #ccT_{:bb1:}# has exactly one term while #ccT_{:bb0:}# has no terms.</p>
<h2 id="collages">Collages</h2>
<p>Sometimes we’d like to talk about function symbols whose source is in one theory and target is in another. As a simple example, that we’ll explore in more depth later, we may want function symbols whose sources are in a product theory. This would let us consider terms with multiple inputs.</p>
<p>The natural way to achieve this is to simply make a new theory that contains sorts from both theories plus the new function symbols. A <strong>collage</strong>, #ccK#, from a theory #ccT_1# to #ccT_2#, written #ccK : ccT_1 ↛ ccT_2#, is a theory whose collection of sorts is the disjoint union of the sorts of #ccT_1# and #ccT_2#. The function symbols of #ccK# consist for each function symbol #ttf : A -&gt; B# in #ccT_1#, a function symbol <code class="asciimath">#tt &quot;inl&quot;(ttf) : tt &quot;inl&quot;(A) -&gt; tt &quot;inl&quot;(B)#</code>, and similarly for function symbols from #ccT_2#. Equations from #ccT_1# and #ccT_2# are likewise taken and lifted appropriately, i.e. #ttf# is replaced with <code class="asciimath">#tt &quot;inl&quot;(ttf)#</code> or <code class="asciimath">#tt &quot;inr&quot;(ttf)#</code> as appropriate. Additional function symbols of the form <code class="asciimath">#k : tt &quot;inl&quot;(A) -&gt; tt &quot;inr&quot;(Z)#</code> where #A# is a sort of #ccT_1# and #Z# is a sort of #ccT_2#, and potentially additional equations involving these function symbols, may be given. (If no additional function symobls are given, then this is exactly the disjoint sum of #ccT_1# and #ccT_2#.) These additional function symbols and equations are what differentiate two collages that have the same source and target theories. Note, there are <em>no</em> function symbols <code class="asciimath">#tt &quot;inr&quot;(Z) -&gt; tt &quot;inl&quot;(A)#</code>, i.e. where #Z# is in #ccT_2# and #A# is in #ccT_1#. That is, there are no function symbols going the “other way”. To avoid clutter, I’ll typically assume that the sorts and function symbols of #ccT_1# and #ccT_2# are disjoint already, and dispense with the <code class="asciimath">#tt &quot;inl&quot;#</code>s and <code class="asciimath">#tt &quot;inr&quot;#</code>s.</p>
<p>Summarizing, we have <code class="asciimath">#ccK(tt &quot;inl&quot;(A), &quot;inl&quot;(B)) ~= ccT_1(A, B)#</code>, <code class="asciimath">#ccK(tt &quot;inr&quot;(Y), tt &quot;inr&quot;(Z)) ~= ccT_2(Y, Z)#</code>, and <code class="asciimath">#ccK(tt &quot;inr&quot;(Z), tt &quot;inl&quot;(A)) = O/#</code> for all #A#, #B#, #Y#, and #Z#. <code class="asciimath">#ccK(tt &quot;inl&quot;(A), tt &quot;inr&quot;(Z))#</code> for any #A# and #Z# is arbitrary generated. To distinguish them, I’ll call the function symbols that go from one theory to another <strong>bridges</strong>. More generally, an arbitrary term that has it’s source in one theory and target in another will be described as a <strong>bridging term</strong>.</p>
<p>Here’s a somewhat silly example. Consider #ccK_+ : ccT_bbbN xx ccT_bbbN ↛ ccT_bbbN# that has one bridge <code class="asciimath">#tt &quot;add&quot; : (0, 0) -&gt; 0#</code> with the equations <code class="asciimath">#tt &quot;add&quot;(tt &quot;inl&quot;(tts, 0)(bbx_(&quot;(&quot;0, 0&quot;)&quot;))) ~~ tts(tt &quot;add&quot;(bbx_(&quot;(&quot;0, 0&quot;)&quot;)))#</code> and <code class="asciimath">#tt &quot;add&quot;(tt &quot;inr&quot;(0, tts)(bbx_(&quot;(&quot;0, 0&quot;)&quot;))) ~~ tts(tt &quot;add&quot;(bbx_(&quot;(&quot;0, 0&quot;)&quot;)))#</code>.</p>
<p>More usefully, if a bit degenerately, every theory induces a collage in the following way. Given a theory #ccT#, we can build the collage #ccK_ccT : ccT ↛ ccT# where the bridges consist of the following. For each sort, #A#, of #ccT#, we have the following bridge: <code class="asciimath">#tt &quot;id&quot;_A : tt &quot;inl&quot;(A) -&gt; tt &quot;inr&quot;(A)#</code>. Then, for every function symbol, #ttf : A -&gt; B# in #ccT#, we have the following equation: <code class="asciimath">#tt &quot;inl&quot;(tt &quot;f&quot;)(tt &quot;id&quot;_A(bbx_(tt &quot;inl&quot;(A)))) ~~ tt &quot;id&quot;_B(tt &quot;inr&quot;(tt &quot;f&quot;)(bbx_(tt &quot;inl&quot;(A))))#</code>. We have <code class="asciimath">#ccK_ccT(tt &quot;inl&quot;(A), tt &quot;inr&quot;(B)) ~= ccT(A, B)#</code>.</p>
<p>You can think of a bridging term in a collage as a sequence of function symbols partitioned into two parts by a bridge. Naturally, we might consider partitioning into more than two parts by having more than one bridge. It’s easy to generalize the definition of collage to combine an arbitrary number of theories, but I’ll take a different, probably worse, route. Given collages #ccK_1 : ccT_1 ↛ ccT_2# and #ccK_2 : ccT_2 ↛ ccT_3#, we can make the collage #ccK_2 @ ccK_1 : ccT_1 ↛ ccT_3# by defining its bridges to be triples of a bridge of #ccK_1#, #k_1 : A_1 -&gt; A_2#, a term, #t : A_2 -&gt; B_2# of #ccT_2#, and a bridge of #ccK_2#, #k_2 : B_2 -&gt; B_3# which altogether will be a bridge of #ccK_2 @ ccK_1# going from #A_1 -&gt; B_3#. These triples essentially represent a term like <code class="asciimath">#k_2(t(k_1(bbx_(A_1))))#</code>. With this intuition we can formulate the equations. For each equation <code class="asciimath">#t'(k_1(t_1)) ~~ s'(k'_1(s_1))#</code> where #k_1# and <code class="asciimath">#k'_1#</code> are bridges of #ccK_1#, we have for every bridge #k_2# of #ccK_2# and term #t# of the appropriate sorts <code class="asciimath">#(k_2, t(t'(bbx)), k_1)(t_1) ~~ (k_2, t(s'(bbx)), k'_1)(s_1)#</code> and similarly for equations involving the bridges of #ccK_2#.</p>
<p>This composition is associative… almost. Furthermore, the collages generated by theories, #ccK_ccT#, behave like identities to this composition… almost. It turns out these statements are true, but only up to isomorphism of theories. That is, #(ccK_3 @ ccK_2) @ ccK_1 ~= ccK_3 @ (ccK_2 @ ccK_1)# but is not equal.</p>
<p>To talk about isomorphism of theories we need the notion of…</p>
<h2 id="interpretations">Interpretations</h2>
<p>An interpretation of a theory gives meaning to the syntax of a theory. There are two nearly identical notions of interpretation for us: interpretation (into sets) and interpretation into a theory. I’ll define them in parallel. An <strong>interpretation</strong> (<strong>into a theory</strong>), #ccI#, is a mapping, written #⟦-⟧^ccI# though the superscript will often be omitted, which maps sorts to sets (sorts) and function symbols to functions (terms). The mapping satisfies:</p>
<blockquote>
<p><code class="asciimath">#⟦&quot;src&quot;(f)⟧ = &quot;src&quot;(⟦f⟧)#</code> and <code class="asciimath">#⟦&quot;tgt&quot;(f)⟧ = &quot;tgt&quot;(⟦f⟧)#</code> where <code class="asciimath">#&quot;src&quot;#</code> and <code class="asciimath">#&quot;tgt&quot;#</code> on the right are the domain and codomain operations for an interpretation.</p>
</blockquote>
<p>We extend the mapping to a mapping on terms via:</p>
<blockquote>
<ul>
<li>#⟦bbx_A⟧ = x |-&gt; x#, i.e. the identity function, or, for interpretation into a theory, <code class="asciimath">#⟦bbx_A⟧ = bbx_{:⟦A⟧:}#</code></li>
<li><code class="asciimath">#⟦tt &quot;f&quot;(t)⟧ = ⟦tt &quot;f&quot;⟧ @ ⟦t⟧#</code> or, for interpretation into a theory, <code class="asciimath">#⟦tt &quot;f&quot;(t)⟧ = ⟦tt &quot;f&quot;⟧(⟦t⟧)#</code></li>
</ul>
</blockquote>
<p>and we require that for any equation of the theory, #l ~~ r#, #⟦l⟧ = ⟦r⟧#. (Technically, this is implicitly required for the extension of the mapping to terms to be well-defined, but it’s clearer to state it explicitly.) I’ll write <code class="asciimath">#ccI : ccT -&gt; bb &quot;Set&quot;#</code> when #ccI# is an interpretation of #ccT# into sets, and #ccI’ : ccT_1 -&gt; ccT_2# when #ccI’# is an interpretation of #ccT_1# into #ccT_2#.</p>
<p>An interpretation of the theory of isomorphisms produces a bijection between two specified sets. Spelling out a simple example where #bbbB# is the set of booleans:</p>
<blockquote>
<ul>
<li>#⟦A⟧ -= bbbB#</li>
<li>#⟦B⟧ -= bbbB#</li>
<li><code class="asciimath">#⟦tt &quot;f&quot;⟧ -= x |-&gt; not x#</code></li>
<li><code class="asciimath">#⟦tt &quot;g&quot;⟧ -= x |-&gt; not x#</code></li>
</ul>
</blockquote>
<p>plus the proof #not not x = x#.</p>
<p>As another simple example, we can interpret the theory of isomorphisms into itself slightly non-trivially.</p>
<blockquote>
<ul>
<li>#⟦A⟧ -= B#</li>
<li>#⟦B⟧ -= A#</li>
<li><code class="asciimath">#⟦tt &quot;f&quot;⟧ -= tt &quot;g&quot;(bbx_B)#</code></li>
<li><code class="asciimath">#⟦tt &quot;g&quot;⟧ -= tt &quot;f&quot;(bbx_A)#</code></li>
</ul>
</blockquote>
<p>As an (easy) exercise, you should define #pi_1 : ccT_1 xx ccT_2 -&gt; ccT_1# and similarly #pi_2#. If you defined #ccT_1 + ccT_2# before, you should define #iota_1 : ccT_1 -&gt; ccT_1 + ccT_2# and similarly for #iota_2#. As another easy exercise, show that an interpretation of <code class="asciimath">#ccT_{:~=:}#</code> is a bijection. In Haskell, an interpretation of #ccT_bbbN# would effectively be <code>foldNat</code>. Something very interesting happens when you consider what an interpretation of the collage generated by a theory, #ccK_ccT#, is. Spell it out. In a different vein, you can show that a collage #ccK : ccT_1 ↛ ccT_2# and an interpretation <code class="asciimath">#ccT_1^(op) xx ccT_2 -&gt; bb &quot;Set&quot;#</code> are essentially the same thing in the sense that each gives rise to the other.</p>
<p>Two theories are <strong>isomorphic</strong> if there exists interpretations <code class="asciimath">#ccI_1 : ccT_1 -&gt; ccT_2#</code> and <code class="asciimath">#ccI_2 : ccT_2 -&gt; ccT_1#</code> such that <code class="asciimath">#⟦⟦A⟧^(ccI_1)⟧^(ccI_2) = A#</code> and vice versa, and similarly for function symbols. In other words, each is interpretable in the other, and if you go from one interpretation and then back, you end up where you started. Yet another way to say this is that there is a one-to-one correspondence between sorts and terms of each theory, and this correspondence respects substitution.</p>
<p>As a crucially important example, the set of terms, #ccT(A, B)#, can be extended to an interpretation. In particular, for each sort #A#, <code class="asciimath">#ccT(A, -) : ccT -&gt; bb &quot;Set&quot;#</code>. It’s action on function symbols is the following:</p>
<blockquote>
<p><code class="asciimath">#⟦tt &quot;f&quot;⟧^(ccT(A, -)) -= t |-&gt; tt &quot;f&quot;(t)#</code></p>
</blockquote>
<p>We have, dually, <code class="asciimath">#ccT(-, A) : ccT^(op) -&gt; bb &quot;Set&quot;#</code> with the following action:</p>
<blockquote>
<p><code class="asciimath">#⟦tt &quot;f&quot;⟧^(ccT(-, A)) -= t |-&gt; t(tt &quot;f&quot;(bbx_B))#</code></p>
</blockquote>
<p>We can abstract from both parameters making <code class="asciimath">#ccT(-, =) : ccT^(op) xx ccT -&gt; bb &quot;Set&quot;#</code> which, by an early exercise, can be shown to correspond with the collage #ccK_ccT#.</p>
<p>Via an abuse of notation, I’ll identify #ccT^(op)(A, -)# with #ccT(-, A)#, though technically we only have an isomorphism between the interpretations, and to talk about isomorphisms between interpretations we need the notion of…</p>
<h2 id="homomorphisms">Homomorphisms</h2>
<p>The theories we’ve presented are (multi-sorted) universal algebra theories. Universal algebra allows us to specify a general notion of “homomorphism” that generalizes monoid homomorphism or group homomorphism or ring homomorphism or lattice homomorphism.</p>
<p>In universal algebra, the algebraic theory of groups consists of a single sort, a nullary operation, #1#, a binary operation, <code class="asciimath">#*#</code>, a unary operation, <code class="asciimath">#tt &quot;inv&quot;#</code>, and some equations which are unimportant for us. Operations correspond to our function symbols except that they’re are not restricted to being unary. A particular group is a particular interpretation of the algebraic theory of groups, i.e. it is a set and three functions into the set. A group homomorphism then is a function between those two groups, i.e. between the two interpretations, that preserves the operations. In a traditional presentation this would look like the following:</p>
<blockquote>
<p>Say #alpha : G -&gt; K# is a group homomorphism from the group #G# to the group #K# and #g, h in G# then:</p>
<ul>
<li>#alpha(1_G) = 1_K#</li>
<li><code class="asciimath">#alpha(g *_G h) = alpha(g) *_K alpha(h)#</code></li>
<li><code class="asciimath">#alpha(tt &quot;inv&quot;_G(g)) = tt &quot;inv&quot;_K(alpha(g))#</code></li>
</ul>
</blockquote>
<p>Using something more akin to our notation, it would look like:</p>
<blockquote>
<ul>
<li>#alpha(⟦1⟧^G) = ⟦1⟧^K#</li>
<li><code class="asciimath">#alpha(⟦*⟧^G(g,h)) = ⟦*⟧^K(alpha(g), alpha(h))#</code></li>
<li><code class="asciimath">#alpha(⟦tt &quot;inv&quot;⟧^G(g)) = ⟦tt &quot;inv&quot;⟧^K(alpha(g))#</code></li>
</ul>
</blockquote>
<p>The <code class="asciimath">#tt &quot;inv&quot;#</code> case is the most relevant for us as it is unary. However, for us, a function symbol #ttf# may have a different source and target and so we made need a different function on each side of the equation. E.g. for #ttf : A -&gt; B#, #alpha : ccI_1 -&gt; ccI_2#, and #a in ⟦A⟧^(ccI_1)# we’d have:</p>
<blockquote>
<p><code class="asciimath">#alpha_B(⟦tt &quot;f&quot;⟧^(ccI_1)(a)) = ⟦tt &quot;f&quot;⟧^(ccI_2)(alpha_A(a))#</code></p>
</blockquote>
<p>So a <strong>homomorphism</strong> <code class="asciimath">#alpha : ccI_1 -&gt; ccI_2 : ccT -&gt; bb &quot;Set&quot;#</code> is a <em>family</em> of functions, one for each sort of #ccT#, that satisfies the above equation for every function symbol of #ccT#. We call the individual functions making up #alpha# <strong>components</strong> of #alpha#, and we have <code class="asciimath">#alpha_A : ⟦A⟧^(ccI_1) -&gt; ⟦A⟧^(ccI_2)#</code>. The definition for an interpretation into a theory, #ccT_2#, is identical except the components of #alpha# are terms of #ccT_2# and #a# can be replaced with #bbx_(⟦A⟧^(ccI_1))#. Two interpretations are <strong>isomorphic</strong> if we have homomorphism #alpha : ccI_1 -&gt; ccI_2# such that each component is a bijection. This is the same as requiring a homomorphism #beta : ccI_2 -&gt; ccI_1# such that for each #A#, #alpha_A(beta_A(x)) = x# and #beta_A(alpha_A(x)) = x#. A similar statement can be made for interpretations into theories, just replace #x# with <code class="asciimath">#bbx_(⟦A⟧)#</code>.</p>
<p>Another way to look at homomorphisms is via collages. A homomorphism <code class="asciimath">#alpha : ccI_1 -&gt; ccI_2 : ccT -&gt; bb &quot;Set&quot;#</code> gives rise to an interpretation of the collage #ccK_ccT#. The interpretation <code class="asciimath">#ccI_alpha : ccK_ccT -&gt; bb &quot;Set&quot;#</code> is defined by:</p>
<blockquote>
<ul>
<li><code class="asciimath">#⟦tt &quot;inl&quot;(A)⟧^(ccI_alpha) -= ⟦A⟧^(ccI_1)#</code></li>
<li><code class="asciimath">#⟦tt &quot;inr&quot;(A)⟧^(ccI_alpha) -= ⟦A⟧^(ccI_2)#</code></li>
<li><code class="asciimath">#⟦tt &quot;inl&quot;(ttf)⟧^(ccI_alpha) -= ⟦ttf⟧^(ccI_1)#</code></li>
<li><code class="asciimath">#⟦tt &quot;inr&quot;(ttf)⟧^(ccI_alpha) -= ⟦ttf⟧^(ccI_2)#</code></li>
<li><code class="asciimath">#⟦tt &quot;id&quot;_A⟧^(ccI_alpha) -= alpha_A#</code></li>
</ul>
</blockquote>
<p>The homomorphism law guarantees that it satisfies the equation on <code class="asciimath">#tt &quot;id&quot;#</code>. Conversely, given an interpretation of #ccK_ccT#, we have the homomorphism, <code class="asciimath">#⟦tt &quot;id&quot;⟧ : ⟦tt &quot;inl&quot;(-)⟧ -&gt; ⟦tt &quot;inr&quot;(-)⟧ : ccT -&gt; bb &quot;Set&quot;#</code>. and the equation on <code class="asciimath">#tt &quot;id&quot;#</code> is exactly the homomorphism law.</p>
<h2 id="yoneda">Yoneda</h2>
<p>Consider a homomorphism #alpha : ccT(A, -) -&gt; ccI#. The #alpha# needs to satisfy for every sort #B# and #C#, every function symbol #ttf : C -&gt; D#, and every term #t : B -&gt; C#:</p>
<blockquote>
<p><code class="asciimath">#alpha_D(tt &quot;f&quot;(t)) = ⟦tt &quot;f&quot;⟧^ccI(alpha_C(t))#</code></p>
</blockquote>
<p>Looking at this equation, the possibility of viewing it as a recursive “definition” leaps out suggesting that the action of #alpha# is completely determined by it’s action on the variables. Something like this, for example:</p>
<blockquote>
<p><code class="asciimath">#alpha_D(tt &quot;f&quot;(tt &quot;g&quot;(tt &quot;h&quot;(bbx_A)))) = ⟦tt &quot;f&quot;⟧(alpha_C(tt &quot;g&quot;(tt &quot;h&quot;(bbx_A)))) = ⟦tt &quot;f&quot;⟧(⟦tt &quot;g&quot;⟧(alpha_B(tt &quot;h&quot;(bbx_A)))) = ⟦tt &quot;f&quot;⟧(⟦tt &quot;g&quot;⟧(⟦tt &quot;h&quot;⟧(alpha_A(bbx_A))))#</code></p>
</blockquote>
<p>We can easily establish that there’s a one-to-one correspondence between the set of homomorphisms #ccT(A, -) -&gt; ccI# and the elements of the set #⟦A⟧^ccI#. Given a homomorphism, #alpha#, we get an element of #⟦A⟧^ccI# via #alpha_A(bbx_A)#. Inversely, given an element #a in ⟦A⟧^ccI#, we can define a homomorphism <code class="asciimath">#a^**#</code> via:</p>
<blockquote>
<ul>
<li><code class="asciimath">#a_D^**(tt &quot;f&quot;(t)) -= ⟦tt &quot;f&quot;⟧^ccI(a_C^**(t))#</code></li>
<li><code class="asciimath">#a_A^**(bbx_A) -= a#</code></li>
</ul>
</blockquote>
<p>which clearly satisfies the condition on homomorphisms by definition. It’s easy to verify that <code class="asciimath">#(alpha_A(bbx_A))^** = alpha#</code> and immediately true that <code class="asciimath">#a^**(bbx_A) = a#</code> establishing the bijection.</p>
<p>We can state something stronger. Given any homomorphism #alpha : ccT(A, -) -&gt; ccI# and any function symbol #ttg : A -&gt; X#, we can make a new homomorphism #alpha * ttg : ccT(X, -) -&gt; ccI# via the following definition:</p>
<blockquote>
<p><code class="asciimath">#(alpha * ttg)(t) = alpha(t(tt &quot;g&quot;(bbx_A)))#</code></p>
</blockquote>
<p>Verifying that this is a homomorphism is straightforward:</p>
<blockquote>
<p><code class="asciimath">#(alpha * ttg)(tt &quot;f&quot;(t)) = alpha(tt &quot;f&quot;(t(tt &quot;g&quot;(bbx_A)))) = ⟦tt &quot;f&quot;⟧(alpha(t(tt &quot;g&quot;(bbx_A)))) = ⟦tt &quot;f&quot;⟧((alpha * ttg)(t))#</code></p>
</blockquote>
<p>and like any homomorphism of this form, as we’ve just established, it is completely determined by it’s action on variables, namely <code class="asciimath">#(alpha * ttg)_A(bbx_A) = alpha_X(tt &quot;g&quot;(bbx_A)) = ⟦tt &quot;g&quot;⟧(alpha_A(bbx_A))#</code>. In particular, if <code class="asciimath">#alpha = a^**#</code>, then we have <code class="asciimath">#a^** * ttg = (⟦tt &quot;g&quot;⟧(a))^**#</code>. Together these facts establish that we have an interpretation <code class="asciimath">#ccY : ccT -&gt; bb &quot;Set&quot;#</code> such that <code class="asciimath">#⟦A⟧^ccY -= (ccT(A, -) -&gt; ccI)#</code>, the <em>set</em> of homomorphisms, and <code class="asciimath">#⟦tt &quot;g&quot;⟧^ccY(alpha) -= alpha * tt &quot;g&quot;#</code>. The work we did before established that we have homomorphisms #(-)(bbx) : ccY -&gt; ccI# and <code class="asciimath">#(-)^** : ccI -&gt; ccY#</code> that are inverses. This is true for all theories and all interpretations as at no point did we use any particular facts about them. This statement is the (dual form of the) Yoneda lemma. To get the usual form simply replace #ccT# with #ccT^(op)#. A particularly important and useful case (so useful it’s usually used tacitly) occurs when we choose #ccI = ccT(B,-)#, we get #(ccT(A, -) -&gt; ccT(B, -)) ~= ccT(B, A)# or, choosing #ccT^(op)# everywhere, #(ccT(-, A) -&gt; ccT(-, B)) ~= ccT(A, B)# which states that a term from #A# to #B# is equivalent to a homomorphism from #ccT(-, A)# to #ccT(-, B)#.</p>
<p>There is another result, dual in a different way, called the co-Yoneda lemma. It turns out it is a corollary of the fact that for a collage #ccK : ccT_1 ↛ ccT_2#, <code class="asciimath">#ccK_(ccT_2) @ ccK ~= ccK#</code> and the dual is just the composition the other way. To get (closer to) the precise result, we need to be able to turn an interpretation into a collage. Given an interpretation, <code class="asciimath">#ccI : ccT -&gt; bb &quot;Set&quot;#</code>, we can define a collage #ccK_ccI : ccT_bb1 ↛ ccT# whose bridges from #1 -&gt; A# are the elements of #⟦A⟧^ccI#. Given this, the co-Yoneda lemma is the special case, #ccK_ccT @ ccK_ccI ~= ccK_ccI#.</p>
<p>Note, that the Yoneda and co-Yoneda lemmas only apply to interpretations into sets as #ccY# involves the <em>set</em> of homomorphisms.</p>
<h2 id="representability">Representability</h2>
<p>The Yoneda lemma suggests that the interpretations #ccT(A, -)# and #ccT(-, A)# are particularly important and this will be borne out as we continue.</p>
<p>We call an interpretation, <code class="asciimath">#ccI : ccT^(op) -&gt; bb &quot;Set&quot;#</code> <strong>representable</strong> if #ccI ~= ccT(-, X)# for some sort #X#. We then say that #X# <strong>represents</strong> #ccI#. What this states is that every term of sort #X# corresponds to an element in one of the sets that make up #ccI#, and these transform appropriately. There’s clearly a particularly important element, namely the image of #bbx_X# which corresponds to an element in #⟦X⟧^ccI#. This element is called the <strong>universal element</strong>. The dual concept is, for <code class="asciimath">#ccI : ccT -&gt; bb &quot;Set&quot;#</code>, #ccI# is <strong>co-representable</strong> if #ccI ~= ccT(X, -)#. We will also say #X# represents #ccI# in this case as it actually does when we view #ccI# as an interpretation of <code class="asciimath">#(ccT^(op))^(op)#</code>.</p>
<p>As a rather liberating exercise, you should establish the following result called <strong>parameterized representability</strong>. Assume we have theories #ccT_1# and #ccT_2#, and a family of sorts of #ccT_2#, #X#, and a family of interpretations of #ccT_2^(op)#, #ccI#, both indexed by sorts of #ccT_1#, such that for each <code class="asciimath">#A in bb &quot;sort&quot;(ccT_1)#</code>, #X_A# represents #ccI_A#, i.e. #ccI_A ~= ccT_2(-, X_A)#. Given all this, then there is a <em>unique</em> interpretation #ccX : ccT_1 -&gt; ccT_2# and <code class="asciimath">#ccI : ccT_1 xx ccT_2^(op) -&gt; bb &quot;Set&quot;#</code> where #⟦A⟧^(ccX) -= X_A# and <code class="asciimath">#&quot;⟦(&quot;A, B&quot;)⟧&quot;^ccI -= ⟦B⟧^(ccI_A)#</code> such that #ccI ~= ccT_2(=,⟦-⟧^ccX)#. To be a bit more clear, the right hand side means #(A, B) |-&gt; ccT_2(B, ⟦A⟧^ccX)#. Simply by choosing #ccT_1# to be a product of multiple theories, we can generalize this result to an arbitrary number of parameters. What makes this result liberating is that we just don’t need to worry about the parameters, they will automatically transform homomorphically. As a technical warning though, since two interpretations may have the same action on sorts but a different action on function symbols, if the family #X_A# was derived from an interpretation #ccJ#, i.e. #X_A -= ⟦A⟧^ccJ#, it may <em>not</em> be the case that #ccX = ccJ#.</p>
<p>Let’s look at some examples.</p>
<p>As a not-so-special case of representability, we can consider <code class="asciimath">#ccI -= ccK(tt &quot;inl&quot;(-), tt &quot;inr&quot;(Z))#</code> where #ccK : ccT_1 ↛ ccT_2#. Saying that #A# represents #ccI# in this case is saying that <em>bridging</em> terms of sort <code class="asciimath">#tt &quot;inr&quot;(Z)#</code>, i.e. sort #Z# in #ccT_2#, in #ccK#, correspond to terms of sort #A# in #ccT_1#. We’ll call the universal element of this representation the <strong>universal bridge</strong> (though technically it may be a bridging term, not a bridge). Let’s write #varepsilon# for this universal bridge. What representability states in this case is given <em>any</em> bridging term #k# of sort #Z#, there exists a unique term #|~ k ~|# of sort #A# such that #k = varepsilon(|~ k ~|)#. If we have an interpretation #ccX : ccT_2 -&gt; ccT_1# such that #⟦Z⟧^ccX# represents <code class="asciimath">#ccK(tt &quot;inl&quot;(-), tt &quot;inr&quot;(Z))#</code> for each sort #Z# of #ccT_2# we say we have a <strong>right representation</strong> of #ccK#. Note, that the universal bridges become a family <code class="asciimath">#varepsilon_Z : ⟦Z⟧^ccX -&gt; Z#</code>. Similarly, if <code class="asciimath">#ccK(tt &quot;inl&quot;(A), tt &quot;inr&quot;(-))#</code> is co-representable for each #A#, we say we have a <strong>left representation</strong> of #ccK#. The <strong>co-universal bridge</strong> is then a bridging term #eta_A : A -&gt; ⟦A⟧# such that for any bridging term #k# with source #A#, there exists a unique term <code class="asciimath">#|__ k __|#</code> in #ccT_2# such that <code class="asciimath">#k = |__ k __|(eta_A)#</code>. For reference, we’ll call these equations <strong>universal properties</strong> of the left/right representation. Parameterized representability implies that a left/right representation is essentially unique.</p>
<center>
<img src="/posts/raw/left-rep.svg" alt="" width="20%"></img> <img src="/posts/raw/right-rep.svg" alt="" width="20%"></img>
</center>
<p>Define #ccI_bb1# via #⟦A⟧^(ccI_bb1) -= bb1# where #bb1# is some one element set. #⟦ttf⟧^(ccI_bb1)# is the identity function for all function symbols #ttf#. We’ll say a theory #ccT# <strong>has a unit sort</strong> or <strong>has a terminal sort</strong> if there is a sort that we’ll also call #bb1# that represents #ccI_bb1#. Spelling out what that means, we first note that there is nothing notable about the universal element as it’s the only element. However, writing the homomorphism #! : ccI_bb1 -&gt; ccT(-, bb1)# and noting that since there’s only one element of #⟦A⟧^(ccI_bb1)# we can, with a slight abuse of notation, also write the term #!# picks out as #!# which gives the equation:</p>
<blockquote>
<p><code class="asciimath">#!_B(tt &quot;g&quot;(t)) = !_A(t)#</code> for any function symbol #ttg : A -&gt; B# and term, #t#, of sort #A#, note <code class="asciimath">#!_A : A -&gt; bb1#</code>.</p>
</blockquote>
<p>This equation states what the isomorphism also fairly directly states: there is exactly one term of sort #bb1# from any sort #A#, namely <code class="asciimath">#!_A(bbx_A)#</code>. The dual notion is called a <strong>void sort</strong> or an <strong>initial sort</strong> and will usually be notated #bb0#, the analog of #!# will be written as #0#. The resulting equation is:</p>
<blockquote>
<p><code class="asciimath">#tt &quot;f&quot;(0_A) = 0_B#</code> for any function symbol #ttf : A -&gt; B#, note #0_A : bb0 -&gt; A#.</p>
</blockquote>
<p>For the next example, I’ll leverage collages. Consider the collage #ccK_2 : ccT ↛ ccT xx ccT# whose bridges from #A -&gt; (B, C)# consist of pairs of terms #t_1 : A -&gt; B# and #t_2 : A -&gt; C#. #ccT# <strong>has pairs</strong> if #ccK_2# has a right representation. We’ll write #(B, C) |-&gt; B xx C# for the representing interpretation’s action on sorts. We’ll write the universal bridge as <code class="asciimath">#(tt &quot;fst&quot;(bbx_(B xx C)), tt &quot;snd&quot;(bbx_(B xx C)))#</code>. The universal property then looks like <code class="asciimath">#(tt &quot;fst&quot;(bbx_(B xx C)), tt &quot;snd&quot;(bbx_(B xx C)))((: t_1, t_2 :)) = (t_1, t_2)#</code> where #(: t_1, t_2 :) : A -&gt; B xx C# is the unique term induced by the bridge #(t_1, t_2)#. The universal property implies the following equations:</p>
<blockquote>
<ul>
<li><code class="asciimath">#(: tt &quot;fst&quot;(bbx_(B xx C)), tt &quot;snd&quot;(bbx_(B xx C))) = bbx_(B xx C)#</code></li>
<li><code class="asciimath">#tt &quot;fst&quot;((: t_1, t_2 :)) = t_1#</code></li>
<li><code class="asciimath">#tt &quot;snd&quot;((: t_1, t_2 :)) = t_2#</code></li>
</ul>
</blockquote>
<center>
<img src="/posts/raw/right-rep-pairs.svg" alt="" width="20%"></img>
</center>
<p>One aspect of note is regardless of whether #ccK_2# has a right representation, i.e. regardless of whether #ccT# has pairs, it always has a left representation. The co-universal bridge is #(bbx_A, bbx_A)# and the unique term <code class="asciimath">#|__(t_1, t_2)__|#</code> is <code class="asciimath">#tt &quot;inl&quot;(t_1, bbx_A)(tt &quot;inr&quot;(bbx_A, t_2)(bbx_(&quot;(&quot;A,A&quot;)&quot;)))#</code>.</p>
<center>
<img src="/posts/raw/left-rep-pairs.svg" alt="" width="20%"></img>
</center>
<p>Define an interpretation #Delta : ccT -&gt; ccT xx ccT# so that #⟦A⟧^Delta -= (A,A)# and similarly for function symbols. #Delta# left represents #ccK_2#. If the interpretation #(B,C) |-&gt; B xx C# right represents #ccK_2#, then we say we have an adjunction between #Delta# and #(- xx =)#, written #Delta ⊣ (- xx =)#, and that #Delta# is left adjoint to #(- xx =)#, and conversely #(- xx =)# is right adjoint #Delta#.</p>
<center>
<img src="/posts/raw/left-right-rep-pairs.svg" alt="" width="20%"></img>
</center>
<p>More generally, whenever we have the situation <code class="asciimath">#ccT_1(⟦-⟧^(ccI_1), =) ~= ccT_2(-, ⟦=⟧^(ccI_2))#</code> we say that #ccI_1 : ccT_2 -&gt; ccT_1# is <strong>left adjoint</strong> to #ccI_2 : ccT_1 -&gt; ccT_2# or conversely that #ccI_2# is <strong>right adjoint</strong> to #ccI_1#. We call this arrangement an <strong>adjunction</strong> and write #ccI_1 ⊣ ccI_2#. Note that we will always have this situation if #ccI_1# left represents and #ccI_2# right represents the same collage. As we noted above, parameterized representability actually determines one adjoint given (its action on sorts and) the other adjoint. With this we can show that adjoints are unique up to isomorphism, that is, given two left adjoints to an interpretation, they must be isomorphic. Similarly for right adjoints. This means that stating something is a left or right adjoint to some other known interpretation essentially completely characterizes it. One issue with adjunctions is that they tend to be wholesale. Let’s say the pair sort #A xx B# existed but no other pair sorts existed, then the (no longer parameterized) representability approach would work just fine, but the adjunction would no longer exist.</p>
<p>Here’s a few of exercises using this. First, a moderately challenging one (until you catch the pattern): spell out the details to the left adjoint to #Delta#. We say a theory <strong>has sums</strong> and write those sums as #A + B# if #(- + =) ⊣ Delta#. Recast void and unit sorts using adjunctions and/or left/right representations. As a terminological note, we say a theory <strong>has finite products</strong> if it has unit sorts and pairs. Similarly, a theory <strong>has finite sums</strong> or <strong>has finite coproducts</strong> if it has void sorts and sums. An even more challenging exercise is the following: a theory <strong>has exponentials</strong> if it has pairs and for every sort #A#, #(A xx -) ⊣ (A =&gt; -)# (note, parameterized representability applies to #A#). Spell out the equations characterizing #A =&gt; B#.</p>
<h2 id="finite-product-theories">Finite Product Theories</h2>
<p>Finite products start to lift us off the ground. So far the theories we’ve been working with have been extremely basic: a language with only unary functions, all terms being just a sequence of applications of function symbols. It shouldn’t be underestimated though. It’s more than enough to do monoid and group theory. A good amount of graph theory can be done with just this. And obviously we were able to establish several general results assuming only this structure. Nevertheless, while we can talk about specific groups, say, we can’t talk about the <em>theory</em> of groups. Finite products change this.</p>
<p>A theory with finite products allows us to talk about multi-ary function symbols and terms by considering unary function symbols from products. This allows us to do all of universal algebra. For example, the <strong>theory of groups</strong>, <code class="asciimath">#ccT_(bb &quot;Grp&quot;)#</code>, consists of a sort #S# and all it’s products which we’ll abbreviate as #S^n# with #S^0 -= bb1# and #S^(n+1) -= S xx S^n#. It has three function symbols #tte : bb1 -&gt; S#, #ttm : S^2 -&gt; S#, and #tti : S -&gt; S# plus the ones that having finite products requires. In fact, instead of just heaping an infinite number of sorts and function symbols into our theory — and we haven’t even gotten to equations — let’s define a compact set of data from which we can generate all this data.</p>
<p>A <strong>signature</strong>, #Sigma#, consists of a collection of sorts, #sigma#, a collection of <em>multi-ary</em> function symbols, and a collection of equations. Equations still remain pairs of terms, but we need to now extend our definition of terms for this context. A <strong>term (in a signature)</strong> is either a variable, <code class="asciimath">#bbx_i^[A_0,A_1,...,A_n]#</code> where #A_i# are sorts and #0 &lt;= i &lt;= n#, the operators <code class="asciimath">#tt &quot;fst&quot;#</code> or <code class="asciimath">#tt &quot;snd&quot;#</code> applied to a term, the unit term written #(::)^A# with sort #A#, a pair of terms written #(: t_1, t_2 :)#, or the (arity correct) application of a multi-ary function symbol to a series of terms, e.g. <code class="asciimath">#tt &quot;f&quot;(t_1, t_2, t_3)#</code>. As a Haskell data declaration, it might look like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">SigTerm</span>
    <span class="fu">=</span> <span class="dt">SigVar</span> [<span class="dt">Sort</span>] <span class="dt">Int</span>
    <span class="fu">|</span> <span class="dt">Fst</span> <span class="dt">SigTerm</span>
    <span class="fu">|</span> <span class="dt">Snd</span> <span class="dt">SigTerm</span>
    <span class="fu">|</span> <span class="dt">Unit</span> <span class="dt">Sort</span>
    <span class="fu">|</span> <span class="dt">Pair</span> <span class="dt">SigTerm</span> <span class="dt">SigTerm</span>
    <span class="fu">|</span> <span class="dt">SigApply</span> <span class="dt">FunctionSymbol</span> [<span class="dt">SigTerm</span>]</code></pre></div>
<p>At this point, sorting (i.e. typing) the terms is no longer trivial, though it is still pretty straightforward. Sorts are either #bb1#, or #A xx B# for sorts #A# and #B#, or a sort #A in sigma#. The source of function symbols or terms are <em>lists</em> of sorts.</p>
<blockquote>
<ul>
<li><code class="asciimath">#bbx_i^[A_0, A_1, ..., A_n] : [A_0, A_1, ..., A_n] -&gt; A_i#</code></li>
<li><code class="asciimath">#(::)^A : [A] -&gt; bb1#</code></li>
<li><code class="asciimath">#(: t_1, t_2 :) : bar S -&gt; T_1 xx T_2#</code> where #t_i : bar S -&gt; T_i#</li>
<li><code class="asciimath">#tt &quot;fst&quot;(t) : bar S -&gt; T_1#</code> where #t : bar S -&gt; T_1 xx T_2#</li>
<li><code class="asciimath">#tt &quot;snd&quot;(t) : bar S -&gt; T_2#</code> where #t : bar S -&gt; T_1 xx T_2#</li>
<li><code class="asciimath">#tt &quot;f&quot;(t_1, ..., t_n) : bar S -&gt; T#</code> where #t_i : bar S -&gt; T_i# and <code class="asciimath">#ttf : [T_1,...,T_n] -&gt; T#</code></li>
</ul>
</blockquote>
<p>The point of a signature was to represent a theory so we can compile a term of a signature into a term of a theory with finite products. The <strong>theory generated from a signature</strong> #Sigma# has the same sorts as #Sigma#. The equations will be equations of #Sigma#, with the terms compiled as will be described momentarily, plus for every pair of sorts the equations that describe pairs and the equations for #!#. Finally, we need to describe how to take a term of the signature and make a function symbol of the theory, but before we do that we need to explain how to convert those sources of the terms which are lists. That’s just a conversion to right nested pairs, <code class="asciimath">#[A_0,...,A_n] |-&gt; A_0 xx (... xx (A_n xx bb1) ... )#</code>. The compilation of a term #t#, which we’ll write as <code class="asciimath">#ccC[t]#</code>, is defined as follows:</p>
<blockquote>
<ul>
<li><code class="asciimath">#ccC[bbx_i^[A_0, A_1, ..., A_n]] = tt &quot;snd&quot;^i(tt &quot;fst&quot;(bbx_(A_i xx(...))))#</code> where <code class="asciimath">#tt &quot;snd&quot;^i#</code> means the #i#-fold application of <code class="asciimath">#tt &quot;snd&quot;#</code></li>
<li><code class="asciimath">#ccC[(::)^A] = !_A#</code></li>
<li><code class="asciimath">#ccC[(: t_1, t_2 :)] = (: ccC[t_1], ccC[t_2] :)#</code></li>
<li><code class="asciimath">#ccC[tt &quot;fst&quot;(t)] = tt &quot;fst&quot;(ccC[t])#</code></li>
<li><code class="asciimath">#ccC[tt &quot;snd&quot;(t)] = tt &quot;snd&quot;(ccC[t])#</code></li>
<li><code class="asciimath">#ccC[tt &quot;f&quot;(t_1, ..., t_n)] = tt &quot;f&quot;((: ccC[t_1], (: ... , (: ccC[t_n], ! :) ... :) :))#</code></li>
</ul>
</blockquote>
<p>As you may have noticed, the generated theory will have an infinite number of sorts, an infinite number of function symbols, and an infinite number of equations no matter what the signature is — even an empty one! Having an infinite number of things isn’t a problem as long as we can algorithmically describe them and this is what the signature provides. Of course, if you’re a (typical) mathematician you nominally don’t care about an algorithmic description. Besides being compact, signatures present a nicer term language. The theories are like a core or assembly language. We could define a slightly nicer variation where we keep a context and manage named variables leading to terms-in-context like:</p>
<blockquote>
<p><code class="asciimath">#x:A, y:B |-- tt &quot;f&quot;(x, x, y)#</code></p>
</blockquote>
<p>which is</p>
<blockquote>
<p><code class="asciimath">#tt &quot;f&quot;(bbx_0^[A,B], bbx_0^[A,B], bbx_1^[A,B])#</code></p>
</blockquote>
<p>for our current term language for signatures. Of course, compilation will be (slightly) trickier for the nicer language.</p>
<p>The benefit of having compiled the signature to a theory, in addition to being able to reuse the results we’ve established for theories, is we only need to define operations on the theory, which is simpler since we only need to deal with pairs and unary function symbols. One example of this is we’d like to extend our notion of interpretation to one that respects the structure of the signature, and we can do that by defining an interpretation of theories that respects finite products.</p>
<p>A <strong>finite product preserving interpretation (into a finite product theory)</strong>, #ccI#, is an interpretation (into a finite product theory) that additionally satisfies:</p>
<blockquote>
<ul>
<li><code class="asciimath">#⟦bb1⟧^ccI ~~ bb1#</code></li>
<li><code class="asciimath">#⟦A xx B⟧^ccI ~~ ⟦A⟧^ccI xx ⟦B⟧^ccI#</code></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code class="asciimath">#⟦!_A⟧^ccI = !_(⟦A⟧^ccI)#</code></li>
<li><code class="asciimath">#⟦tt &quot;fst&quot;(t)⟧^ccI = tt &quot;fst&quot;(⟦t⟧^ccI)#</code></li>
<li><code class="asciimath">#⟦tt &quot;snd&quot;(t)⟧^ccI = tt &quot;snd&quot;(⟦t⟧^ccI)#</code></li>
<li><code class="asciimath">#⟦(: t_1, t_2 :)⟧^ccI = (: ⟦t_1⟧^ccI, ⟦t_2⟧^ccI :)#</code></li>
</ul>
</blockquote>
<p>where, for <code class="asciimath">#bb &quot;Set&quot;#</code>, #bb1 -= {{}}#, #xx# is the cartesian product, <code class="asciimath">#tt &quot;fst&quot;#</code> and <code class="asciimath">#tt &quot;snd&quot;#</code> are the projections, <code class="asciimath">#!_A -= x |-&gt; \{\}#</code>, and #(: f, g :) -= x |-&gt; (: f(x), g(x) :)#.</p>
<p>With signatures, we can return to our theory, now signature, of groups. <code class="asciimath">#Sigma_bb &quot;Grp&quot;#</code> has a single sort #S#, three function symbols <code class="asciimath">#tte : [bb1] -&gt; S#</code>, <code class="asciimath">#tti : [S] -&gt; S#</code>, and <code class="asciimath">#ttm : [S, S] -&gt; S#</code>, with the following equations:</p>
<blockquote>
<ul>
<li><code class="asciimath">#tt &quot;m&quot;(tt &quot;e&quot;((::)^S), bbx_0^S) ~~ bbx_0^S#</code></li>
<li><code class="asciimath">#tt &quot;m&quot;(tt &quot;i&quot;(bbx_0^S), bbx_0^S) ~~ tt &quot;e&quot;((::)^S)#</code></li>
<li><code class="asciimath">#tt &quot;m&quot;(tt &quot;m&quot;(bbx_0^[S,S,S], bbx_1^[S,S,S]), bbx_2^[S,S,S]) ~~ tt &quot;m&quot;(bbx_0^[S,S,S], tt &quot;m&quot;(bbx_1^[S,S,S], bbx_2^[S,S,S]))#</code></li>
</ul>
</blockquote>
<p>or using the nicer syntax:</p>
<blockquote>
<ul>
<li><code class="asciimath">#x:S |-- tt &quot;m&quot;(tt &quot;e&quot;(), x) ~~ x#</code></li>
<li><code class="asciimath">#x:S |-- tt &quot;m&quot;(tt &quot;i&quot;(x), x) ~~ tt &quot;e&quot;()#</code></li>
<li><code class="asciimath">#x:S, y:S, z:S |-- tt &quot;m&quot;(tt &quot;m&quot;(x, y), z) ~~ tt &quot;m&quot;(x, tt &quot;m&quot;(y, z))#</code></li>
</ul>
</blockquote>
<p>An actual group is then just a finite product preserving interpretation of (the theory generated by) this signature. All of universal algebra and much of abstract algebra can be formulated this way.</p>
<h2 id="the-simply-typed-lambda-calculus-and-beyond">The Simply Typed Lambda Calculus and Beyond</h2>
<p>We can consider additionally assuming that our theory has exponentials. I left articulating exactly what that means as an exercise, but the upshot is we have the following two operations:</p>
<p>For any term #t : A xx B -&gt; C#, we have the term <code class="asciimath">#tt &quot;curry&quot;(t) : A -&gt; C^B#</code>. We also have the homomorphism <code class="asciimath">#tt &quot;app&quot;_(AB) : B^A xx A -&gt; B#</code>. They satisfy:</p>
<blockquote>
<ul>
<li><code class="asciimath">#tt &quot;curry&quot;(tt &quot;app&quot;(bbx_(B^A xx A))) = bbx_(B^A)#</code></li>
<li><code class="asciimath">#tt &quot;app&quot;((: tt &quot;curry&quot;(t_1), t_2 :)) = t_1((: bbx_A, t_2 :))#</code> where #t_1 : A xx B -&gt; C# and #t_2 : A -&gt; B#.</li>
</ul>
</blockquote>
<p>We can view these, together with the the product operations, as combinators, and it turns out we can compile the simply typed lambda calculus into the above theory. This is exactly what the <a href="https://en.wikipedia.org/wiki/Categorical_abstract_machine">Categorical Abstract Machine</a> did. The “Caml” in “O’Caml” stands for “Categorical Abstract Machine Language”, though O’Caml no longer uses the CAM. Conversely, every term of the theory can be expressed as a simply typed lambda term. This means we can view the simply typed lambda calculus as just a different presentation of the theory.</p>
<p>At this point, this presentation of category theory starts to connect to the mainstream categorical literature on <a href="https://ncatlab.org/nlab/show/algebraic+theory">universal algebra</a>, <a href="https://ncatlab.org/nlab/show/type+theory#TheInternalLanguageOfACategory">internal languages</a>, <a href="https://ncatlab.org/nlab/show/sketch">sketches</a>, and <a href="https://ncatlab.org/nlab/show/internal+logic">internal logic</a>. This page gives a synopsis of the <a href="https://ncatlab.org/nlab/show/relation+between+type+theory+and+category+theory">relationship between type theory and category theory</a>. For some reason, it is unusual to talk about the internal language of a plain category, but that is exactly what we’ve done here.</p>
<p>I haven’t talked about finite limits or colimits beyond products and coproducts, nor have I talked about even the infinitary versions of products and coproducts, let alone arbitrary limits and colimits. These can be handled the same way as products and coproducts. Formulating a language like signatures or the simply typed lambda calculus is a bit more complicated, but not that hard. I may make a follow-up article covering this among other things. I also have a side project (don’t hold your breath), that implements the internal language of a category with finite limits. The result looks roughly like a simple version of an algebraic specification language like the <a href="https://cseweb.ucsd.edu/~goguen/sys/obj.html">OBJ family</a>. The <code>RING</code> theory described in the <a href="http://maude.lcc.uma.es/manual271/maude-manualch6.html#x41-880006.3">Maude manual</a> gives an idea of what it would look like. In fact, here’s an example of the current actual syntax I’m using.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p>
<pre><code>theory Categories
    type O
    type A
    given src : A -&gt; O
    given tgt : A -&gt; O

    given id : O -&gt; A
    satisfying o:O | src (id o) = o, tgt (id o) = o

    given c : { f:A, g:A | src f = tgt g } -&gt; A
    satisfying (f, g):{ f:A, g:A | src f = tgt g }
        | tgt (c (f, g)) = tgt f, src (c (f, g)) = src g
    satisfying &quot;left unit&quot; (o, f):{ o:O, f:A | tgt f = o }
        | c (id o, f) = f
    satisfying &quot;right unit&quot; (o, f):{ o:O, f:A | src f = o }
        | c (f, id o) = f
    satisfying &quot;associativity&quot; (f, g, h):{ f:A, g:A, h:A | src f = tgt g, src g = tgt h }
        | c (c (f, g), h) = c (f, c (g, h))
endtheory</code></pre>
<p>It turns out this is a particularly interesting spot in the design space. The fact that the theory of theories with finite limits is itself a theory with finite limits has interesting consequences. It is still relatively weak though. For example, it’s not possible to describe the theory of fields in this language.</p>
<p>There are other directions one could go. For example, the internal logic of monoidal categories is (a fragment of) ordered linear logic. You can cross this bridge either way. You can look at different languages and consider what categorical structure is needed to support the features of the language, or you can add features to the category and see how that impacts the internal language. The relationship is similar to the source language and a core/intermediate language in a compiler, e.g. GHC Haskell and <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/FC">System Fc</a>.</p>
<h2 id="decoder">Decoder</h2>
<p>If you’ve looked at category theory at all, you can probably make most of the connections without me telling you. The table below outlines the mapping, but there are some subtleties. First, as a somewhat technical detail, my definition of a theory corresponds to a <em>small</em> category, i.e. a category which has a set of objects and a set of arrows. For more programmer types, you should think of “set” as <code>Set</code> in Agda, i.e. similar to the <code>*</code> kind in Haskell. Usually “category” means “locally small category” which may have a proper class of objects and between any two objects a set of arrows (though the union of all those sets may be a proper class). Again, for programmers, the distinction between “class” and “set” is basically the difference between <code>Set</code> and <code>Set1</code> in Agda.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> To make my definition of theory closer to this, all that is necessary is instead of having a set of function symbols, have a family of sets indexed by pairs of objects. Here’s what a partial definition in Agda of the two scenarios would look like:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="co">-- Small category (the definition I used)</span>
<span class="kw">record</span> SmallCategory <span class="ot">:</span> <span class="dt">Set1</span> <span class="kw">where</span>
    <span class="kw">field</span>
        objects <span class="ot">:</span> <span class="dt">Set</span>
        arrows <span class="ot">:</span> <span class="dt">Set</span>
        src <span class="ot">:</span> arrows <span class="ot">-&gt;</span> objects
        tgt <span class="ot">:</span> arrows <span class="ot">-&gt;</span> objects
        <span class="ot">...</span>

<span class="co">-- Locally small category</span>
<span class="kw">record</span> LocallySmallCategory <span class="ot">:</span> <span class="dt">Set2</span> <span class="kw">where</span>
    <span class="kw">field</span>
        objects <span class="ot">:</span> <span class="dt">Set1</span>
        hom <span class="ot">:</span> objects <span class="ot">-&gt;</span> objects <span class="ot">-&gt;</span> <span class="dt">Set</span>
        <span class="ot">...</span>

<span class="co">-- Different presentation of a small category</span>
<span class="kw">record</span> SmallCategory&#39; <span class="ot">:</span> <span class="dt">Set1</span> <span class="kw">where</span>
    <span class="kw">field</span>
        objects <span class="ot">:</span> <span class="dt">Set</span>
        hom <span class="ot">:</span> objects <span class="ot">-&gt;</span> objects <span class="ot">-&gt;</span> <span class="dt">Set</span>
        <span class="ot">...</span></code></pre></div>
<p>The benefit of the notion of locally small category is that <code>Set</code> itself is a locally small category. The distinction I was making between interpretations into theories and interpretations into <strong>Set</strong> was due to the fact that <strong>Set</strong> wasn’t a theory. If I used a definition theory corresponding to a locally small category, I could have combined the notions of interpretation by making <strong>Set</strong> a theory. The notion of a small category, though, is still useful. Also, an interpretation into <strong>Set</strong> corresponds to the usual notion of a model or semantics, while interpretations into other theories was a less emphasized concept in traditional model theory and universal algebra.</p>
<p>A less technical and more significant difference is that my definition of a theory doesn’t correspond to a category, but rather to a <em>presentation</em> of a category, from which a category can be generated. The analog of arrows in a category is <em>terms</em>, not function symbols. This is a bit more natural route from the model theory/universal algebra/programming side. Similarly, having an explicit collection of equations, rather than just an equivalence relation on terms is part of the presentation of the category but not part of the category itself.</p>
<table class="table table-striped table-sm">
<thead>
<tr>
<th>
model theory
</th>
<th>
category theory
</th>
</thead>
<tbody>
<tr>
<td>
sort
</td>
<td>
object
</td>
</tr>
<tr>
<td>
term
</td>
<td>
arrow
</td>
</tr>
<tr>
<td>
function symbol
</td>
<td>
generating arrow
</td>
</tr>
<tr>
<td>
theory
</td>
<td>
presentation of a (small) category
</td>
</tr>
<tr>
<td>
collage
</td>
<td>
collage, <a href="https://ncatlab.org/nlab/show/cograph+of+a+profunctor">cograph of a profunctor</a>
</td>
</tr>
<tr>
<td>
bridge
</td>
<td>
<a href="https://ncatlab.org/nlab/show/heteromorphism">heteromorphism</a>
</td>
</tr>
<tr>
<td>
signature
</td>
<td>
presentation of a (small) category with finite products
</td>
</tr>
<tr>
<td>
interpretation into sets, aka models
</td>
<td>
a functor into <strong>Set</strong>, a (co)presheaf
</td>
</tr>
<tr>
<td>
interpretation into a theory
</td>
<td>
functor
</td>
</tr>
<tr>
<td>
homomorphism
</td>
<td>
natural transformation
</td>
</tr>
<tr>
<td>
simply typed lambda calculus (with products)
</td>
<td>
a cartesian closed category
</td>
</tr>
</tbody>
</table>
<h2 id="conclusion">Conclusion</h2>
<p>In some ways I’ve stopped just when things were about to get good. I may do a follow-up to elaborate on this good stuff. Some examples are: if I expand the definition so that <strong>Set</strong> becomes a “theory”, then interpretations also form such a “theory”, and these are often what we’re really interested in. The category of finite-product preserving interpretations of the theory of groups essentially <em>is</em> the category of groups. In fact, universal algebra is, in categorical terms, just the study of categories with finite products and finite-product preserving functors from them, particularly into <strong>Set</strong>. It’s easy to generalize this in many directions. It’s also easy to make very general definitions, like a general definition of a free algebraic structure. In general, we’re usually more interested in the interpretations of a theory than the theory itself.</p>
<p>While I often do advocate thinking in terms of internal languages of categories, I’m not sure that it is a preferable perspective for the very basics of category theory. Nevertheless, there are a few reasons for why I wrote this. First, this very syntactical approach is, I think, more accessible to someone coming from a programming background. From this view, a category is a very simple programming language. Adding structure to the category corresponds to adding features to this programming language. Interpretations are denotational semantics.</p>
<p>Another aspect about this presentation that is quite different is the use and emphasis on collages. Collages correspond to profunctors, a crucially important and enabling concept that is rarely covered in categorical introductions. The characterization of profunctors as collages in Vaughn Pratt’s paper (not using that name) was one of the things I enjoyed about that paper and part of what prompted me to start writing this. In earlier drafts of this article, I was unable to incorporate collages in a meaningful way as I was trying to start from profunctors. This approach just didn’t add value. Collages just looked like a bizarre curio and weren’t integrated into the narrative at all. For other reasons, though, I ended up revisiting the idea of a heteromorphism. My (fairly superficial) opinion is that once you have the notion of functors and natural transformations, adding the notion of heteromorphisms has a low power-to-weight ratio, though it does make some things a bit nicer. Nevertheless, in thinking of how best to fit them into this context, it was clear that collages provided the perfect mechanism (which isn’t a big surprise), and the result works rather nicely. When I realized a fact that can be cryptically but compactly represented as #ccK_ccT ≃ bbbI xx ccT# where #bbbI# is the interval category, i.e. two objects with a single arrow joining them, I realized that this is actually an interesting perspective. Since most of this article was written at that point, I wove collages into the narrative replacing some things. If, though, I had started with this perspective from the beginning I suspect I would have made a significantly different article, though the latter sections would likely be similar.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>It’s actually better to organize this as a <em>family</em> of collections of function symbols indexed by pairs of sorts.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Instead of having equations that generate an equivalence relation on (raw) terms, we could simply require an equivalence relation on (raw) terms be directly provided.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Collaging is actually quite natural in this context. I already intend to support one theory importing another. A collage is just a theory that imports two others and then adds function symbols between them.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>For programmers familiar with Agda, at least, if you haven’t made this connection, this might help you understand and appreciate what a “class” is versus a “set” and what “size issues” are, which is typically handled extremely vaguely in a lot of the literature.<a href="#fnref4">↩</a></p></li>
</ol>
</div>]]></description>
    <pubDate>Fri, 25 Nov 2016 06:23:17 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/category-theory-syntactically.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>
<item>
    <title>Constant-time Binary Logarithm</title>
    <link>https://derekelkins.github.io/posts/find-first-set.html</link>
    <description><![CDATA[<h2 id="introduction">Introduction</h2>
<p>I’ve been watching the <a href="https://courses.csail.mit.edu/6.851/spring14/lectures/">Spring 2012 lectures for MIT 6.851 Advanced Data Structures</a> with Prof. Erik Demaine. In lecture 12, “Fusion Trees”, it mentions a constant time algorithm for finding the index of the first most significant 1 bit in a word, i.e. the binary logarithm. Assuming word operations are constant time, i.e. in the Word RAM model, the below algorithm takes 27 word operations (not counting copying). When I compiled it with GHC 8.0.1 -O2 the core of the algorithm was 44 straight-line instructions. The theoretically interesting thing is, other than changing the constants, the same algorithm works for any word size that’s an even power of 2. Odd powers of two need a slight tweak. This is demonstrated for <code>Word64</code>, <code>Word32</code>, and <code>Word16</code>. It should be possible to do this for any arbitrary word size <code>w</code>.</p>
<p>The <code>clz</code> instruction <a href="https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:countLeadingZeros">can be used to implement</a> this function, but this is a potential simulation if that or a similar instruction wasn’t available. It’s probably not the fastest way. Similarly, find first set and count trailing zeros <a href="https://en.wikipedia.org/wiki/Find_first_set">can be implemented</a> in terms of this operation.</p>
<h2 id="code">Code</h2>
<p>Below is the complete code. You can also download it <a href="/posts/raw/FFS.hs">here</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE BangPatterns #-}</span>
<span class="kw">import </span><span class="dt">Data.Word</span>
<span class="kw">import </span><span class="dt">Data.Bits</span>

<span class="co">-- Returns 0-based bit index of most significant bit that is 1. Assumes input is non-zero.</span>
<span class="co">-- That is, 2^indexOfMostSignificant1 x &lt;= x &lt; 2^(indexOfMostSignificant1 x + 1)</span>
<span class="co">-- From Erik Demaine&#39;s presentation in Spring 2012 lectures of MIT 6.851, particularly &quot;Lecture 12: Fusion Trees&quot;.</span>
<span class="co">-- Takes 26 (source-level) straight-line word operations.</span>
<span class="ot">indexOfMostSignificant1 ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span>
indexOfMostSignificant1 w <span class="fu">=</span> idxMsbyte <span class="fu">.|.</span> idxMsbit
    <span class="kw">where</span>
        <span class="co">-- top bits of each byte</span>
        <span class="fu">!</span>wtbs <span class="fu">=</span> w <span class="fu">.&amp;.</span> <span class="bn">0x8080808080808080</span>
        
        <span class="co">-- all but top bits of each byte producing 8 7-bit chunks</span>
        <span class="fu">!</span>wbbs <span class="fu">=</span> w <span class="fu">.&amp;.</span> <span class="bn">0x7F7F7F7F7F7F7F7F</span>              

        <span class="co">-- parallel compare of each 7-bit chunk to 0, top bit set in result if 7-bit chunk was not 0</span>
        <span class="fu">!</span>pc <span class="fu">=</span> parallelCompare <span class="bn">0x8080808080808080</span> wbbs

        <span class="co">-- top bit of each byte set if the byte has any bits set in w</span>
        <span class="fu">!</span>ne <span class="fu">=</span> wtbs <span class="fu">.|.</span> pc                             

        <span class="co">-- a summary of which bytes (except the first) are non-zero as a 7-bit bitfield, i.e. top bits collected into bottom byte</span>
        <span class="fu">!</span>summary <span class="fu">=</span> sketch ne <span class="ot">`unsafeShiftR`</span> <span class="dv">1</span>

        <span class="co">-- parallel compare summary to powers of two</span>
        <span class="fu">!</span>cmpp2 <span class="fu">=</span> parallelCompare <span class="bn">0xFFBF9F8F87838180</span> (<span class="bn">0x0101010101010101</span> <span class="fu">*</span> summary)
        
        <span class="co">-- index of most significant non-zero byte * 8</span>
        <span class="fu">!</span>idxMsbyte <span class="fu">=</span> sumTopBits8 cmpp2                

        <span class="co">-- most significant 7-bits of most significant non-zero byte</span>
        <span class="fu">!</span>msbyte <span class="fu">=</span> ((w <span class="ot">`unsafeShiftR`</span> (fromIntegral idxMsbyte)) <span class="fu">.&amp;.</span> <span class="bn">0xFF</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">1</span>

        <span class="co">-- parallel compare msbyte to powers of two</span>
        <span class="fu">!</span>cmpp2&#39; <span class="fu">=</span> parallelCompare <span class="bn">0xFFBF9F8F87838180</span> (<span class="bn">0x0101010101010101</span> <span class="fu">*</span> msbyte)

        <span class="co">-- index of most significant non-zero bit in msbyte</span>
        <span class="fu">!</span>idxMsbit <span class="fu">=</span> sumTopBits cmpp2&#39; 

        <span class="co">-- Maps top bits of each byte into lower byte assuming all other bits are 0.</span>
        <span class="co">-- 0x2040810204081 = sum [2^j | j &lt;- map (\i -&gt; 49 - 7*i) [0..7]]</span>
        <span class="co">-- In general if w = 2^(2*k+p) and p = 0 or 1 the formula is:</span>
        <span class="co">-- sum [2^j | j &lt;- map (\i -&gt; w-(2^k-1) - 2^(k+p) - (2^(k+p) - 1)*i) [0..2^k-1]]</span>
        <span class="co">-- Followed by shifting right by w - 2^k</span>
        sketch w <span class="fu">=</span> (w <span class="fu">*</span> <span class="bn">0x2040810204081</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">56</span>

        parallelCompare w1 w2 <span class="fu">=</span> complement (w1 <span class="fu">-</span> w2) <span class="fu">.&amp;.</span> <span class="bn">0x8080808080808080</span>
        sumTopBits w <span class="fu">=</span> ((w <span class="ot">`unsafeShiftR`</span> <span class="dv">7</span>) <span class="fu">*</span> <span class="bn">0x0101010101010101</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">56</span>
        sumTopBits8 w <span class="fu">=</span> ((w <span class="ot">`unsafeShiftR`</span> <span class="dv">7</span>) <span class="fu">*</span> <span class="bn">0x0808080808080808</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">56</span>

<span class="ot">indexOfMostSignificant1_w32 ::</span> <span class="dt">Word32</span> <span class="ot">-&gt;</span> <span class="dt">Word32</span>
indexOfMostSignificant1_w32 w <span class="fu">=</span> idxMsbyte <span class="fu">.|.</span> idxMsbit
    <span class="kw">where</span> <span class="fu">!</span>wtbs <span class="fu">=</span> w <span class="fu">.&amp;.</span> <span class="bn">0x80808080</span>
          <span class="fu">!</span>wbbs <span class="fu">=</span> w <span class="fu">.&amp;.</span> <span class="bn">0x7F7F7F7F</span>
          <span class="fu">!</span>pc <span class="fu">=</span> parallelCompare <span class="bn">0x80808080</span> wbbs
          <span class="fu">!</span>ne <span class="fu">=</span> wtbs <span class="fu">.|.</span> pc
          <span class="fu">!</span>summary <span class="fu">=</span> sketch ne <span class="ot">`unsafeShiftR`</span> <span class="dv">1</span>
          <span class="fu">!</span>cmpp2 <span class="fu">=</span> parallelCompare <span class="bn">0xFF838180</span> (<span class="bn">0x01010101</span> <span class="fu">*</span> summary)
          <span class="fu">!</span>idxMsbyte <span class="fu">=</span> sumTopBits8 cmpp2
          <span class="fu">!</span>msbyte <span class="fu">=</span> ((w <span class="ot">`unsafeShiftR`</span> (fromIntegral idxMsbyte)) <span class="fu">.&amp;.</span> <span class="bn">0xFF</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">1</span>
          <span class="fu">!</span>cmpp2&#39; <span class="fu">=</span> parallelCompare <span class="bn">0x87838180</span> (<span class="bn">0x01010101</span> <span class="fu">*</span> msbyte)

          <span class="co">-- extra step when w is not an even power of two</span>
          <span class="fu">!</span>cmpp2&#39;&#39; <span class="fu">=</span> parallelCompare <span class="bn">0xFFBF9F8F</span> (<span class="bn">0x01010101</span> <span class="fu">*</span> msbyte)
          <span class="fu">!</span>idxMsbit <span class="fu">=</span> sumTopBits cmpp2&#39; <span class="fu">+</span> sumTopBits cmpp2&#39;&#39;

          sketch w <span class="fu">=</span> (w <span class="fu">*</span> <span class="bn">0x204081</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">28</span>
          parallelCompare w1 w2 <span class="fu">=</span> complement (w1 <span class="fu">-</span> w2) <span class="fu">.&amp;.</span> <span class="bn">0x80808080</span>
          sumTopBits w <span class="fu">=</span> ((w <span class="ot">`unsafeShiftR`</span> <span class="dv">7</span>) <span class="fu">*</span> <span class="bn">0x01010101</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">24</span>
          sumTopBits8 w <span class="fu">=</span> ((w <span class="ot">`unsafeShiftR`</span> <span class="dv">7</span>) <span class="fu">*</span> <span class="bn">0x08080808</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">24</span>

<span class="ot">indexOfMostSignificant1_w16 ::</span> <span class="dt">Word16</span> <span class="ot">-&gt;</span> <span class="dt">Word16</span>
indexOfMostSignificant1_w16 w <span class="fu">=</span> idxMsnibble <span class="fu">.|.</span> idxMsbit
    <span class="kw">where</span> <span class="fu">!</span>wtbs <span class="fu">=</span> w <span class="fu">.&amp;.</span> <span class="bn">0x8888</span>
          <span class="fu">!</span>wbbs <span class="fu">=</span> w <span class="fu">.&amp;.</span> <span class="bn">0x7777</span>
          <span class="fu">!</span>pc <span class="fu">=</span> parallelCompare <span class="bn">0x8888</span> wbbs
          <span class="fu">!</span>ne <span class="fu">=</span> wtbs <span class="fu">.|.</span> pc
          <span class="fu">!</span>summary <span class="fu">=</span> sketch ne <span class="ot">`unsafeShiftR`</span> <span class="dv">1</span>
          <span class="fu">!</span>cmpp2 <span class="fu">=</span> parallelCompare <span class="bn">0xFB98</span> (<span class="bn">0x1111</span> <span class="fu">*</span> summary)
          <span class="fu">!</span>idxMsnibble <span class="fu">=</span> sumTopBits4 cmpp2
          <span class="fu">!</span>msnibble <span class="fu">=</span> ((w <span class="ot">`unsafeShiftR`</span> (fromIntegral idxMsnibble)) <span class="fu">.&amp;.</span> <span class="bn">0xF</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">1</span>
          <span class="fu">!</span>cmpp2&#39; <span class="fu">=</span> parallelCompare <span class="bn">0xFB98</span> (<span class="bn">0x1111</span> <span class="fu">*</span> msnibble)
          <span class="fu">!</span>idxMsbit <span class="fu">=</span> sumTopBits cmpp2&#39;

          sketch w <span class="fu">=</span> (w <span class="fu">*</span> <span class="bn">0x249</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">12</span>
          parallelCompare w1 w2 <span class="fu">=</span> complement (w1 <span class="fu">-</span> w2) <span class="fu">.&amp;.</span> <span class="bn">0x8888</span>
          sumTopBits w <span class="fu">=</span> ((w <span class="ot">`unsafeShiftR`</span> <span class="dv">3</span>) <span class="fu">*</span> <span class="bn">0x1111</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">12</span>
          sumTopBits4 w <span class="fu">=</span> ((w <span class="ot">`unsafeShiftR`</span> <span class="dv">3</span>) <span class="fu">*</span> <span class="bn">0x4444</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">12</span></code></pre></div>]]></description>
    <pubDate>Thu, 10 Nov 2016 07:48:33 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/find-first-set.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>
<item>
    <title>Quotient Types for Programmers</title>
    <link>https://derekelkins.github.io/posts/quotient-types-for-programmers.html</link>
    <description><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Programmers in typed languages with higher order functions and algebraic data types are already comfortable with most of the basic constructions of set/type theory. In categorical terms, those programmers are familiar with finite products and coproducts and (monoidal/cartesian) closed structure. The main omissions are subset types (equalizers/pullbacks) and quotient types (coequalizers/pushouts) which would round out limits and colimits. Not having a good grasp on either of these constructions dramatically shrinks the world of mathematics that is understandable, but while subset types are fairly straightforward, quotient types are quite a bit less intuitive.</p>
<h2 id="subset-types">Subset Types</h2>
<p>In my opinion, most programmers can more or less immediately understand the notion of a subset type at an intuitive level.<br />
A <strong>subset type</strong> is just a type combined with a predicate on that type that specifies which values of the type we want. For example, we may have something like <code>{ n:Nat | n /= 0 }</code> meaning the type of naturals not equal to #0#. We may use this in the type of the division function for the denominator. Consuming a value of a subset type is easy, a natural not equal to #0# is still just a natural, and we can treat it as such. The difficult part is producing a value of a subset type. To do this, we must, of course, produce a value of the underlying type — <code>Nat</code> in our example — but then we must further convince the type checker that the predicate holds (e.g. that the value does not equal #0#). Most languages provide no mechanism to prove potentially arbitrary facts about code, and this is why they do not support subset types. Dependently typed languages do provide such mechanisms and thus either have or can encode subset types. Outside of dependently typed languages the typical solution is to use an abstract data type and use a runtime check when values of that abstract data type are created.</p>
<h2 id="quotient-types">Quotient Types</h2>
<p>The dual of subset types are quotient types. My impression is that this construction is the most difficult basic construction for people to understand. Further, programmers aren’t much better off, because they have little to which to connect the idea. Before I give a definition, I want to provide the example with which most people are familiar: modular (or clock) arithmetic. A typical way this is first presented is as a system where the numbers “wrap-around”. For example, in arithmetic mod #3#, we count #0#, #1#, #2#, and then wrap back around to #0#. Programmers are well aware that it’s not necessary to guarantee that an input to addition, subtraction, or multiplication mod #3# is either #0#, #1#, or #2#. Instead, the operation can be done and the <code>mod</code> function can be applied at the end. This will give the same result as applying the <code>mod</code> function to each argument at the beginning. For example, #4+7 = 11# and #11 mod 3 = 2#, and #4 mod 3 = 1# and #7 mod 3 = 1# and #1+1 = 2 = 11 mod 3#.</p>
<p>For mathematicians, the type of integers mod #n# is represented by the quotient type #ZZ//n ZZ#. The idea is that the values of #ZZ // n ZZ# are integers except that we agree that any two integers #a# and #b# are treated as equal if #a - b = kn# for some integer #k#. For #ZZ // 3 ZZ#, #… -6 = -3 = 0 = 3 = 6 = …# and #… = -5 = -2 = 1 = 4 = 7 = …# and #… = -4 = -1 = 2 = 5 = 8 = …#.</p>
<h2 id="equivalence-relations">Equivalence Relations</h2>
<p>To start to formalize this, we need the notion of an equivalence relation. An <strong>equivalence relation</strong> is a binary relation <code class="asciimath">#(~~)#</code> which is <strong>reflexive</strong> (#x ~~ x# for all #x#), <strong>symmetric</strong> (if <code class="asciimath">#x ~~ y#</code> then <code class="asciimath">#y ~~ x#</code>), and <strong>transitive</strong> (if <code class="asciimath">#x ~~ y#</code> and <code class="asciimath">#y ~~ z#</code> then <code class="asciimath">#x ~~ z#</code>). We can check that “#a ~~ b# iff there exists an integer #k# such that #a-b = kn#” defines an equivalence relation on the integers for any given #n#. For reflexivity we have #a - a = 0n#. For symmetry we have if #a - b = kn# then #b - a = -kn#. Finally, for transitivity we have if #a - b = k_1 n# and #b - c = k_2 n# then #a - c = (k_1 + k_2)n# which we get by adding the preceding two equations.</p>
<p>Any relation can be extended to an equivalence relation. This is called the reflexive-, symmetric-, transitive-closure of the relation. For an arbitrary binary relation #R# we can define the equivalence relation #(~~_R)# via “#a ~~_R b# iff #a = b# or #R(a, b)# or #b ~~_R a# or #a ~~_R c and c ~~_R b# for some #c#“. To be precise, #~~_R# is the smallest relation satisfying those constraints. In Datalog syntax, this looks like:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">eq_r(<span class="dt">A</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">.</span>
eq_r(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>) <span class="kw">:-</span> r(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>)<span class="kw">.</span>
eq_r(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>) <span class="kw">:-</span> eq_r(<span class="dt">B</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">.</span>
eq_r(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>) <span class="kw">:-</span> eq_r(<span class="dt">A</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> eq_r(<span class="dt">C</span><span class="kw">,</span> <span class="dt">B</span>)<span class="kw">.</span></code></pre></div>
<h2 id="quotient-types-the-type-theory-view">Quotient Types: the Type Theory view</h2>
<p>If #T# is a type, and <code class="asciimath">#(~~)#</code> is an equivalence relation, we use #T // ~~# as the notation for the <strong>quotient type</strong>, which we read as “#T# quotiented by the equivalence relation <code class="asciimath">#(~~)#</code>”. We call #T# the <strong>underlying type</strong> of the quotient type. We then say #a = b# at type #T // ~~# iff #a ~~ b#. Dual to subset types, to produce a value of a quotient type is easy. Any value of the underlying type is a value of the quotient type. (In type theory, this produces the perhaps surprising result that #ZZ# is a <em>subtype</em> of #ZZ // n ZZ#.) As expected, consuming a value of a quotient type is more complicated. To explain this, we need to explain what a function #f : T // ~~ -&gt; X# is for some type #X#. A function #f : T // ~~ -&gt; X# is a function #g : T -&gt; X# which satisfies #g(a) = g(b)# for all #a# and #b# such that #a ~~ b#. We call #f# (or #g#, they are often conflated) <strong>well-defined</strong> if #g# satisfies this condition. In other words, any well-defined function that consumes a quotient type isn’t allowed to produce an output that distinguishes between equivalent inputs. A better way to understand this is that quotient types allow us to change what the notion of equality is for a type. From this perspective, a function being well-defined just means that it is a function. Taking equal inputs to equal outputs is one of the defining characteristics of a function.</p>
<p>Sometimes we can finesse needing to check the side condition. Any function #h : T -&gt; B# gives rise to an equivalence relation on #T# via #a ~~ b# iff #h(a) = h(b)#. In this case, any function #g : B -&gt; X# gives rise to a function #f : T // ~~ -&gt; X# via #f = g @ h#. In particular, when #B = T# we are guaranteed to have a suitable #g# for any function #f : T // ~~ -&gt; X#. In this case, we can implement quotient types in a manner quite similar subset types, namely we make an abstract type and we normalize with the #h# function as we either produce or consume values of the abstract type. A common example of this is rational numbers. We can reduce a rational number to lowest terms either when it’s produced or when the numerator or denominator get accessed, so that we don’t accidentally write functions which distinguish between #1/2# and #2/4#. For modular arithmetic, the mod by #n# function is a suitable #h#.</p>
<h2 id="quotient-types-the-set-theory-view">Quotient Types: the Set Theory view</h2>
<p>In set theory such an #h# function can always be made by mapping the elements of #T# to the equivalence classes that contain them, i.e. #a# gets mapped to #{b | a ~~ b}# which is called the <strong>equivalence class</strong> of #a#. In fact, in set theory, #T // ~~# is usually defined to <em>be</em> the set of equivalence classes of <code class="asciimath">#(~~)#</code>. So, for the example of #ZZ // 3 ZZ#, in set theory, it is a set of exactly three elements: the elements are #{ 3n+k | n in ZZ}# for #k = 0, 1, 2#. Equivalence classes are also called <strong>partitions</strong> and are said to partition the underlying set. Elements of these equivalence classes are called <strong>representatives</strong> of the equivalence class. Often a notation like #[a]# is used for the equivalence class of #a#.</p>
<h2 id="more-examples">More Examples</h2>
<p>Here is a quick run-through of some significant applications of quotient types. I’ll give the underlying type and the equivalence relation and what the quotient type produces. I’ll leave it as an exercise to verify that the equivalence relations really are equivalence relations, i.e. reflexive, symmetric, and transitive. I’ll start with more basic examples. You should work through them to be sure you understand how they work.</p>
<h3 id="integers">Integers</h3>
<p>Integers can be presented as pairs of naturals #(n, m)# with the idea being that the pair represents “#n - m#”. Of course, #1 - 2# should be the same as #2 - 3#. This is expressed as #(n_1, m_1) ~~ (n_2, m_2)# iff #n_1 + m_2 = n_2 + m_1#. Note how this definition only relies on operations on natural numbers. You can explore how to define addition, subtraction, multiplication, and other operations on this representation in a well-defined manner.</p>
<h3 id="rationals">Rationals</h3>
<p>Rationals can be presented very similarly to integers, only with multiplication instead of addition. We also have pairs #(n, d)#, usually written #n/d#, in this case of an integer #n# and a non-zero natural #d#. The equivalence relation is #(n_1, d_1) ~~ (n_2, d_2)# iff #n_1 d_2 = n_2 d_1#.</p>
<h3 id="topological-circles">(Topological) Circles</h3>
<p>We can extend the integers mod #n# to the continuous case. Consider the real numbers with the equivalence relation #r ~~ s# iff #r - s = k# for some integer #k#. You could call this the reals mod #1#. Topologically, this is a circle. If you walk along it far enough, you end up back at a point equivalent to where you started. Occasionally this is written as #RR//ZZ#.</p>
<h3 id="torii">Torii</h3>
<p>Doing the previous example in 2D gives a torus. Specifically, we have pairs of real numbers and the equivalence relation #(x_1, y_1) ~~ (x_2, y_2)# iff #x_1 - x_2 = k# and #y_1 - y_2 = l# for some integers #k# and #l#. Quite a bit of topology relies on similar constructions as will be expanded upon on the section on gluing.</p>
<h3 id="unordered-pairs">Unordered pairs</h3>
<p>Here’s an example that’s a bit closer to programming. Consider the following equivalence relation on arbitrary pairs: #(a_1, b_1) ~~ (a_2, b_2)# iff #a_1 = a_2 and b_1 = b_2# or #a_1 = b_2 and b_1 = a_2#. This just says that a pair is equivalent to either itself, or a swapped version of itself. It’s interesting to consider what a well-defined function is on this type.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<h3 id="gluing-pushouts">Gluing / Pushouts</h3>
<p>Returning to topology and doing a bit more involved construction, we arrive at gluing or pushouts. In topology, we often want to take two topological spaces and glue them together in some specified way. For example, we may want to take two discs and glue their boundaries together. This gives a sphere. We can combine two spaces into one with the disjoint sum (or coproduct, i.e. Haskell’s <code>Either</code> type.) This produces a space that contains both the input spaces, but they don’t interact in any way. You can visualize them as sitting next to each other but not touching. We now want to say that certain pairs of points, one from each of the spaces, are really the same point. That is, we want to quotient by an equivalence relation that would identify those points. We need some mechanism to specify which points we want to identify. One way to accomplish this is to have a pair of functions, #f : C -&gt; A# and #g : C -&gt; B#, where #A# and #B# are the spaces we want to glue together. We can then define a relation #R# on the disjoint sum via #R(a, b)# iff there’s a #c : C# such that <code class="asciimath">#a = tt &quot;inl&quot;(f(c)) and b = tt &quot;inr&quot;(g(c))#</code>. This is not an equivalence relation, but we can extend it to one. The quotient we get is then the gluing of #A# and #B# specified by #C# (or really by #f# and #g#). For our example of two discs, #f# and #g# are the same function, namely the inclusion of the boundary of the disc into the disc. We can also glue a space to itself. Just drop the disjoint sum part. Indeed, the circle and torus are examples.</p>
<h3 id="polynomial-ring-ideals">Polynomial ring ideals</h3>
<p>We write #RR[X]# for the type of polynomials with one indeterminate #X# with real coefficients. For two indeterminates, we write #RR[X, Y]#. Values of these types are just polynomials such as #X^2 + 1# or #X^2 + Y^2#. We can consider quotienting these types by equivalence relations generated from identifications like #X^2 + 1 ~~ 0# or #X^2 - Y ~~ 0#, but we want more than just the reflexive-, symmetric-, transitive-closure. We want this equivalence relation to also respect the operations we have on polynomials, in particular, addition and multiplication. More precisely, we want if #a ~~ b# and #c ~~ d# then #ac ~~ bd# and similarly for addition. An equivalence relation that respects all operations is called a <strong>congruence</strong>. The standard notation for the quotient of #RR[X, Y]# by a congruence generated by both of the previous identifications is #RR[X, Y]//(X^2 + 1, X^2 - Y)#. Now if #X^2 + 1 = 0# in #RR[X, Y]//(X^2 + 1, X^2 - Y)#, then for <em>any</em> polynomial #P(X, Y)#, we have #P(X, Y)(X^2 + 1) = 0# because #0# times anything is #0#. Similarly, for any polynomial #Q(X, Y)#, #Q(X, Y)(X^2 - Y) = 0#. Of course, #0 + 0 = 0#, so it must be the case that #P(X, Y)(X^2 + 1) + Q(X, Y)(X^2 - Y) = 0# for all polynomials #P# and #Q#. In fact, we can show that all elements in the equivalence class of #0# are of this form. You’ve now motivated the concrete definition of a ring ideal and given it’s significance. An <strong>ideal</strong> is an equivalence class of #0# with respect to some congruence. Let’s work out what #RR[X, Y]//(X^2 + 1, X^2 - Y)# looks like concretely. First, since #X^2 - Y = 0#, we have #Y = X^2# and so we see that values of #RR[X, Y]//(X^2 + 1, X^2 - Y)# will be polynomials in only one indeterminate because we can replace all #Y#s with #X^2#s. Since #X^2 = -1#, we can see that all those polynomials will be linear (i.e. of degree 1) because we can just keep replacing #X^2#s with #-1#s, i.e. #X^(n+2) = X^n X^2 = -X^n#. The end result is that an arbitrary polynomial in #RR[X, Y]//(X^2 + 1, X^2 - Y)# looks like #a + bX# for real numbers #a# and #b# and we have #X^2 = -1#. In other words, #RR[X, Y]//(X^2 + 1, X^2 - Y)# is isomorphic to the complex numbers, #CC#.</p>
<p>As a reasonably simple exercise, given a polynomial #P(X) : RR[X]#, what does it get mapped to when embedded into #RR[X]//(X - 3)#, i.e. what is #[P(X)] : RR[X]//(X - 3)#?<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<h3 id="free-algebras-modulo-an-equational-theory">Free algebras modulo an equational theory</h3>
<p>Moving much closer to programming, we have a rather broad and important example that a mathematician might describe as free algebras modulo an equational theory. This example covers several of the preceding examples. In programmer-speak, a free algebra is just a type of abstract syntax trees for some language. We’ll call a specific abstract syntax tree a <strong>term</strong>. An equational theory is just a collection of pairs of terms with the idea being that we’d like these terms to be considered equal. To be a bit more precise, we will actually allow terms to contain (meta)variables. An example equation for an expression language might be <code>Add(</code>#x#<code>,</code>#x#<code>) = Mul(2,</code>#x#<code>)</code>. We call a term with no variables a <strong>ground term</strong>. We say a ground term <strong>matches</strong> another term if there is a consistent substitution for the variables that makes the latter term syntactically equal to the ground term. E.g. <code>Add(3, 3)</code> matches <code>Add(</code>#x#<code>,</code>#x#<code>)</code> via the substitution #x |-&gt;#<code>3</code>. Now, the equations of our equational theory gives rise to a relation on ground terms #R(t_1, t_2)# iff there exists an equation #l = r# such that #t_1# matches #l# and #t_2# matches #r#. This relation can be extended to an equivalence relation on ground terms, and we can then quotient by that equivalence relation.</p>
<p>Let’s consider a worked example. We can consider the theory of monoids. We have two operations (types of AST nodes): <code>Mul(</code>#x#<code>,</code>#y#<code>)</code> and <code>1</code>. We have the following three equations: <code>Mul(1,</code>#x#<code>) =</code>#x#, <code>Mul(</code>#x#<code>, 1) =</code>#x#, and <code>Mul(Mul(</code>#x#<code>,</code>#y#<code>),</code>#z#<code>) = Mul(</code>#x#<code>, Mul(</code>#y#<code>,</code>#z#<code>))</code>. We additionally have a bunch of constants subject to no equations. In this case, it turns out we can define a normalization function, what I called #h# far above, and that the quotient type is isomorphic to lists of constants. Now, we can extend this theory to the theory of groups by adding a new operation, <code>Inv(</code>#x#<code>)</code>, and new equations: <code>Inv(Inv(</code>#x#<code>)) =</code>#x#, <code>Inv(Mul(</code>#x#<code>,</code>#y#<code>)) = Mul(Inv(</code>#y#<code>), Inv(</code>#x#<code>))</code>, and <code>Mul(Inv(</code>#x#<code>),</code>#x#<code>) = 1</code>. If we ignore the last of these equations, you can show that we can normalize to a form that is isomorphic to a list of a disjoint sum of the constants, i.e. <code>[Either Const Const]</code> in Haskell if <code>Const</code> were the type of the constant terms. Quotienting this type by the equivalence relation extended with that final equality corresponds to adding the rule that a <code>Left c</code> cancels out <code>Right c</code> in the list whenever they are adjacent.</p>
<p>This overall example is a fairly profound one. Almost all of abstract algebra can be viewed as an instance of this or a closely related variation. When you hear about things defined in terms of “generators and relators”, it is an example of this sort. Indeed, those “relators” are used to define a relation that will be extended to an equivalence relation. Being defined in this way is arguably what it <em>means</em> for something to be “algebraic”.</p>
<h2 id="postscript">Postscript</h2>
<p>The <a href="http://www.nuprl.org/book/Introduction_Type_Theory.html">Introduction to Type Theory</a> section of the NuPRL book provides a more comprehensive and somewhat more formal presentation of these and related concepts. While the quotient <em>type</em> view of quotients is conceptually different from the standard set theoretic presentation, it is much more amenable to computation as the #ZZ // n ZZ# example begins to illustrate.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>It’s a commutative function.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>It gets mapped to it’s value at #3#, i.e. #P(3)#.<a href="#fnref2">↩</a></p></li>
</ol>
</div>]]></description>
    <pubDate>Fri, 23 Sep 2016 05:21:35 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/quotient-types-for-programmers.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>
<item>
    <title>Constructivist Motto</title>
    <link>https://derekelkins.github.io/posts/constructivist-motto.html</link>
    <description><![CDATA[<blockquote>
<p>I don’t believe classical logic is false; I just believe that it is not true.</p>
</blockquote>]]></description>
    <pubDate>Sat, 07 May 2016 18:12:29 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/constructivist-motto.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>
<item>
    <title>The Mistake Everyone Makes with KnockoutJS</title>
    <link>https://derekelkins.github.io/posts/the-mistake-everyone-makes-with-knockoutjs.html</link>
    <description><![CDATA[<h3 id="introduction">Introduction</h3>
<p><a href="http://knockoutjs.com">Knockout</a> is a nice JavaScript library for making values that automatically update when any of their “dependencies” update. Those dependencies can form an arbitrary directed acyclic graph. Many people seem to think of it as “yet another” templating library, but the core idea which is useful far beyond “templating” is the notion of observable values. One nice aspect is that it is a library and not a framework so you can use it as little or as much as you want and you can integrate it with other libraries and frameworks.</p>
<p>At any rate, this article is more geared toward those who have already decided on using Knockout or a library (in any language) offering similar capabilities. I strongly suspect the issues and solutions I’ll discuss apply to all similar sorts of libraries. While I’ll focus on one particular example, the ideas behind it apply generally. This example, admittedly, is one that almost anyone will implement, and in my experience will do it incorrectly the first time and won’t realize the problem until later.</p>
<h3 id="the-problem">The Problem</h3>
<p>When doing any front-end work, before long there will be a requirement to support “multi-select” of something. Of course, you want the standard select/deselect all functionality and for it to work correctly, and of course you want to do something with the items you’ve selected. Here’s a very simple example:</p>
<div id="#badExample">
Number selected: <span data-bind="text: $data.numberSelected()"></span>
<table>
<tr>
<th>
<input type="checkbox" data-bind="checked: $data.allSelected"/>
</th>
<th>
Item
</th>
</tr>
<!-- ko foreach: { data: $data.items(), as: '$item' } -->
<tr>
<td>
<input type="checkbox" data-bind="checked: $data.selected"/>
</td>
<td data-bind="text: 'Item number: '+$data.body">
</td>
</tr>
<!-- /ko -->
<tr>
<td>
<button data-bind="click: function() { $data.add(); }">
Add
</button>
</td>
</tr>
</table>
</div>
<p>Here, the number selected is an overly simple example of using the selected items. More realistically, the selected items will trigger other items to show up and/or trigger AJAX requests to update the data or populate other data. The HTML for this example is completely straightforward.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;#badExample&quot;</span><span class="kw">&gt;</span>
    Number selected: <span class="kw">&lt;span</span><span class="ot"> data-bind=</span><span class="st">&quot;text: $data.numberSelected()&quot;</span><span class="kw">&gt;&lt;/span&gt;</span>
    <span class="kw">&lt;table&gt;</span>
        <span class="kw">&lt;tr&gt;&lt;th&gt;&lt;input</span><span class="ot"> type=</span><span class="st">&quot;checkbox&quot;</span><span class="ot"> data-bind=</span><span class="st">&quot;checked: $data.allSelected&quot;</span><span class="kw">/&gt;&lt;/th&gt;&lt;th&gt;</span>Item<span class="kw">&lt;/th&gt;&lt;/tr&gt;</span>
        <span class="co">&lt;!-- ko foreach: { data: $data.items(), as: &#39;$item&#39; } --&gt;</span>
        <span class="kw">&lt;tr&gt;&lt;td&gt;&lt;input</span><span class="ot"> type=</span><span class="st">&quot;checkbox&quot;</span><span class="ot"> data-bind=</span><span class="st">&quot;checked: $data.selected&quot;</span><span class="kw">/&gt;&lt;/td&gt;&lt;td</span><span class="ot"> data-bind=</span><span class="st">&quot;text: &#39;Item number: &#39;+$data.body&quot;</span><span class="kw">&gt;&lt;/td&gt;&lt;/tr&gt;</span>
        <span class="co">&lt;!-- /ko --&gt;</span>
        <span class="kw">&lt;tr&gt;&lt;td&gt;&lt;button</span><span class="ot"> data-bind=</span><span class="st">&quot;click: function() { $data.add(); }&quot;</span><span class="kw">&gt;</span>Add<span class="kw">&lt;/button&gt;&lt;/td&gt;&lt;/tr&gt;</span>
    <span class="kw">&lt;/table&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p>The way nearly everyone (including me) first thinks to implement this is by adding a <code>selected</code> observable to each item and then having <code>allSelected</code> depend on all of the <code>selected</code> observables. Since we also want to write to <code>allSelected</code> to change the state of the <code>selected</code> observables we use a <a href="http://knockoutjs.com/documentation/computed-writable.html">writable computed observable</a>. This computed observable will loop through all the items and check to see if they are all set to determine it’s state. When it is updated, it will loop through all the <code>selected</code> observables and set them to the appropriate state. Here’s the full code listing.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> badViewModel <span class="op">=</span> <span class="op">{</span>
    <span class="dt">counter</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span>
    <span class="dt">items</span><span class="op">:</span> <span class="va">ko</span>.<span class="at">observableArray</span>()
<span class="op">};</span>

<span class="va">badViewModel</span>.<span class="at">allSelected</span> <span class="op">=</span> <span class="va">ko</span>.<span class="at">computed</span>(<span class="op">{</span>
    <span class="dt">read</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="kw">var</span> items <span class="op">=</span> <span class="va">badViewModel</span>.<span class="at">items</span>()<span class="op">;</span>
        <span class="kw">var</span> allSelected <span class="op">=</span> <span class="kw">true</span><span class="op">;</span>
        <span class="cf">for</span>(<span class="kw">var</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">items</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span> <span class="co">// Need to make sure we depend on each item, so don&#39;t break out of loop early</span>
            allSelected <span class="op">=</span> allSelected <span class="op">&amp;&amp;</span> items[i].<span class="at">selected</span>()<span class="op">;</span>
        <span class="op">}</span>
        <span class="cf">return</span> allSelected<span class="op">;</span>
    <span class="op">},</span>
    <span class="dt">write</span><span class="op">:</span> <span class="kw">function</span>(newValue) <span class="op">{</span>
        <span class="kw">var</span> items <span class="op">=</span> <span class="va">badViewModel</span>.<span class="at">items</span>()<span class="op">;</span>
        <span class="cf">for</span>(<span class="kw">var</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">items</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
            items[i].<span class="at">selected</span>(newValue)<span class="op">;</span>
        <span class="op">}</span>
    <span class="op">}</span>
<span class="op">}</span>)<span class="op">;</span>

<span class="va">badViewModel</span>.<span class="at">numberSelected</span> <span class="op">=</span> <span class="va">ko</span>.<span class="at">computed</span>(<span class="kw">function</span>() <span class="op">{</span>
    <span class="kw">var</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>
    <span class="kw">var</span> items <span class="op">=</span> <span class="va">badViewModel</span>.<span class="at">items</span>()<span class="op">;</span>
    <span class="cf">for</span>(<span class="kw">var</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">items</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
        <span class="cf">if</span>(items[i].<span class="at">selected</span>()) count<span class="op">++;</span>
    <span class="op">}</span>
    <span class="cf">return</span> count<span class="op">;</span>
<span class="op">}</span>)<span class="op">;</span>

<span class="va">badViewModel</span>.<span class="at">add</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
    <span class="va">badViewModel</span>.<span class="va">items</span>.<span class="at">push</span>(<span class="op">{</span>
        <span class="dt">body</span><span class="op">:</span> <span class="va">badViewModel</span>.<span class="at">counter</span><span class="op">++,</span>
        <span class="dt">selected</span><span class="op">:</span> <span class="va">ko</span>.<span class="at">observable</span>(<span class="kw">false</span>)
    <span class="op">}</span>)<span class="op">;</span>
<span class="op">};</span>

<span class="va">ko</span>.<span class="at">applyBindings</span>(badViewModel<span class="op">,</span> <span class="va">document</span>.<span class="at">getElementById</span>(<span class="st">&#39;#badExample&#39;</span>))<span class="op">;</span></code></pre></div>
<p>This should be relatively straightforward, and it works, so what’s the problem? The problem can be seen in <code>numberSelected</code> (and it also comes up with <code>allSelected</code> which I’ll get to momentarily). <code>numberSelected</code> depends on <em>each</em> <code>selected</code> observable and so it will be fired <em>each</em> time <em>each</em> one updates. That means if you have 100 items, and you use the select all checkbox, <code>numberSelected</code> will be called 100 times. For this example, that doesn’t really matter. For a more realistic example than <code>numberSelected</code>, this may mean rendering one, then two, then three, … then 100 HTML fragments or making 100 AJAX requests. In fact, this same behavior is present in <code>allSelected</code>. When it is written, as it’s writing to the <code>selected</code> observables, it is also triggering <em>itself</em>.</p>
<p>So the problem is updating <code>allSelected</code> or <code>numberSelected</code> can’t be done all at once, or to use database terminology, it can’t be updated atomically. One possible solution in newer versions of Knockout is to use <code>deferredUpdates</code> or, what I did back in the much earlier versions of Knockout, abuse the rate limiting features. The problem with this solution is that it makes updates asynchronous. If you’ve written your code to not care whether it was called synchronously or asynchronously, then this will work fine. If you haven’t, doing this throws you into a world of shared state concurrency and race conditions. In this case, this solution is far worse than the disease.</p>
<h3 id="the-solution">The Solution</h3>
<p>So, what’s the alternative? We want to update all selected items atomically; we can atomically update a single observable; so we’ll put all selected items into a single observable. Now an item determines if it is selected by checking whether it is in the collection of selected items. More abstractly, we make our observables more coarse-grained, and we have a bunch of small computed observables depend on a large observable instead of a large computed observable depending on a bunch of small observables as we had in the previous code. Here’s an example using the exact same HTML and presenting the same overt behavior.</p>
<div id="#goodExample">
Number selected: <span data-bind="text: $data.numberSelected()"></span>
<table>
<tr>
<th>
<input type="checkbox" data-bind="checked: $data.allSelected"/>
</th>
<th>
Item
</th>
</tr>
<!-- ko foreach: { data: $data.items(), as: '$item' } -->
<tr>
<td>
<input type="checkbox" data-bind="checked: $data.selected"/>
</td>
<td data-bind="text: 'Item number: '+$data.body">
</td>
</tr>
<!-- /ko -->
<tr>
<td>
<button data-bind="click: function() { $data.add(); }">
Add
</button>
</td>
</tr>
</table>
</div>
<p>And here’s the code behind this second example:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> goodViewModel <span class="op">=</span> <span class="op">{</span>
    <span class="dt">counter</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span>
    <span class="dt">selectedItems</span><span class="op">:</span> <span class="va">ko</span>.<span class="at">observableArray</span>()<span class="op">,</span>
    <span class="dt">items</span><span class="op">:</span> <span class="va">ko</span>.<span class="at">observableArray</span>()
<span class="op">};</span>

<span class="va">goodViewModel</span>.<span class="at">allSelected</span> <span class="op">=</span> <span class="va">ko</span>.<span class="at">computed</span>(<span class="op">{</span>
    <span class="dt">read</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="cf">return</span> <span class="va">goodViewModel</span>.<span class="at">items</span>().<span class="at">length</span> <span class="op">===</span> <span class="va">goodViewModel</span>.<span class="at">selectedItems</span>().<span class="at">length</span><span class="op">;</span>
    <span class="op">},</span>
    <span class="dt">write</span><span class="op">:</span> <span class="kw">function</span>(newValue) <span class="op">{</span>
        <span class="cf">if</span>(newValue) <span class="op">{</span>
            <span class="va">goodViewModel</span>.<span class="at">selectedItems</span>(<span class="va">goodViewModel</span>.<span class="at">items</span>().<span class="at">slice</span>(<span class="dv">0</span>))<span class="op">;</span> <span class="co">// Need a copy!</span>
        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
            <span class="va">goodViewModel</span>.<span class="va">selectedItems</span>.<span class="at">removeAll</span>()<span class="op">;</span>
        <span class="op">}</span>
    <span class="op">}</span>
<span class="op">}</span>)<span class="op">;</span>

<span class="va">goodViewModel</span>.<span class="at">numberSelected</span> <span class="op">=</span> <span class="va">ko</span>.<span class="at">computed</span>(<span class="kw">function</span>() <span class="op">{</span>
    <span class="cf">return</span> <span class="va">goodViewModel</span>.<span class="at">selectedItems</span>().<span class="at">length</span><span class="op">;</span>
<span class="op">}</span>)<span class="op">;</span>

<span class="va">goodViewModel</span>.<span class="at">add</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
    <span class="kw">var</span> item <span class="op">=</span> <span class="op">{</span> <span class="dt">body</span><span class="op">:</span> <span class="va">goodViewModel</span>.<span class="at">counter</span><span class="op">++</span> <span class="op">}</span>
    <span class="va">item</span>.<span class="at">selected</span> <span class="op">=</span> <span class="va">ko</span>.<span class="at">computed</span>(<span class="op">{</span>
        <span class="dt">read</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
            <span class="cf">return</span> <span class="va">goodViewModel</span>.<span class="va">selectedItems</span>.<span class="at">indexOf</span>(item) <span class="op">&gt;</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span>
        <span class="op">},</span>
        <span class="dt">write</span><span class="op">:</span> <span class="kw">function</span>(newValue) <span class="op">{</span>
            <span class="cf">if</span>(newValue) <span class="op">{</span>
                <span class="va">goodViewModel</span>.<span class="va">selectedItems</span>.<span class="at">push</span>(item)<span class="op">;</span>
            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
                <span class="va">goodViewModel</span>.<span class="va">selectedItems</span>.<span class="at">remove</span>(item)<span class="op">;</span>
            <span class="op">}</span>
        <span class="op">}</span>
    <span class="op">}</span>)<span class="op">;</span>
    <span class="va">goodViewModel</span>.<span class="va">items</span>.<span class="at">push</span>(item)<span class="op">;</span>
<span class="op">};</span>

<span class="va">ko</span>.<span class="at">applyBindings</span>(goodViewModel<span class="op">,</span> <span class="va">document</span>.<span class="at">getElementById</span>(<span class="st">&#39;#goodExample&#39;</span>))<span class="op">;</span></code></pre></div>
<p>One thing to note is that setting <code>allSelected</code> and <code>numberSelected</code> are now both simple operations. A write to an observable triggers a constant number of writes to other observables. In fact, there are only two (non-computed) observables. On the other hand, <em>reading</em> the <code>selected</code> observable is more expensive. Toggling all items has quadratic complexity. In fact, it had quadratic complexity before due to the feedback. However, unlike the previous code, this <em>also</em> has quadratic complexity when any <em>individual</em> item is toggled. Unlike the previous code, though, this is simply due to a poor choice of data structure. Equipping each item with an “ID” field and using an object as a hash map would reduce the complexity to linear. In practice, for this sort of scenario, it tends not to make a big difference. Also, Knockout won’t trigger dependents if the value doesn’t change, so there’s no risk of the extra work propagating into still more extra work. Nevertheless, while I endorse this solution for this particular problem, in general making <em>finer</em> grained observables can help limit the scope of changes so unnecessary work isn’t done.</p>
<p>Still, the real concern and benefit of this latter approach isn’t the asymptotic complexity of the operations, but the <em>atomicity</em> of the operations. In the second solution, every update is atomic. There are no intermediate states on the way to a final state. This means that dependents, represented by <code>numberSelected</code> but which are realistically much more complicated, don’t get triggered excessively and don’t need to “compensate” for unintended intermediate values.</p>
<h3 id="epilogue">Epilogue</h3>
<p>We could take the coarse-graining to its logical conclusion and have the view model for an application be a single observable holding an object representing the entire view model (and containing no observables of its own). Taking this approach actually does have a lot of benefits, albeit there is little reason to use Knockout at that point. Instead this starts to lead to things like Facebook’s <a href="https://facebook.github.io/flux/">Flux</a> pattern and the pattern perhaps most clearly articulated by <a href="http://cycle.js.org/">Cycle JS</a>.</p>
<script lang="text/javascript" src="http://ajax.aspnetcdn.com/ajax/knockout/knockout-3.3.0.js"></script>
<script lang="text/javascript">
// Bad View Model

var badViewModel = {
    counter: 0,
    items: ko.observableArray()
};

badViewModel.allSelected = ko.computed({
    read: function() {
        var items = badViewModel.items();
        var allSelected = true;
        for(var i = 0; i < items.length; i++) { // Need to make sure we depend on each item, so don't break out of loop early
            allSelected = allSelected && items[i].selected();
        }
        return allSelected;
    },
    write: function(newValue) {
        var items = badViewModel.items();
        for(var i = 0; i < items.length; i++) {
            items[i].selected(newValue);
        }
    }
});

badViewModel.numberSelected = ko.computed(function() {
    var count = 0;
    var items = badViewModel.items();
    for(var i = 0; i < items.length; i++) {
        if(items[i].selected()) count++;
    }
    return count;
});

badViewModel.add = function() {
    badViewModel.items.push({
        body: badViewModel.counter++,
        selected: ko.observable(false)
    });
};


// Good View Model

var goodViewModel = {
    counter: 0,
    selectedItems: ko.observableArray(),
    items: ko.observableArray()
};

goodViewModel.allSelected = ko.computed({
    read: function() {
        return goodViewModel.items().length === goodViewModel.selectedItems().length;
    },
    write: function(newValue) {
        if(newValue) {
            goodViewModel.selectedItems(goodViewModel.items().slice(0)); // Need a copy!
        } else {
            goodViewModel.selectedItems.removeAll();
        }
    }
});

goodViewModel.numberSelected = ko.computed(function() {
    return goodViewModel.selectedItems().length;
});

goodViewModel.add = function() {
    var item = { body: goodViewModel.counter++ }
    item.selected = ko.computed({
        read: function() {
            return goodViewModel.selectedItems.indexOf(item) > -1;
        },
        write: function(newValue) {
            if(newValue) {
                goodViewModel.selectedItems.push(item);
            } else {
                goodViewModel.selectedItems.remove(item);
            }
        }
    });
    goodViewModel.items.push(item);
};

ko.applyBindings(badViewModel, document.getElementById('#badExample'));
ko.applyBindings(goodViewModel, document.getElementById('#goodExample'));
</script>]]></description>
    <pubDate>Thu, 05 May 2016 20:38:08 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/the-mistake-everyone-makes-with-knockoutjs.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>
<item>
    <title>Understanding typing judgments</title>
    <link>https://derekelkins.github.io/posts/understanding-typing-judgments.html</link>
    <description><![CDATA[<h3 id="introduction">Introduction</h3>
<p>For many people interested in type systems and type theory, their first encounter with the literature presents them with this:</p>
<p><code class="asciimath">#frac(Gamma,x:tau_1 |--_Sigma e : tau_2)(Gamma |--_Sigma (lambda x:tau_1.e) : tau_1 -&gt; tau_2) -&gt;I#</code></p>
<p><code class="asciimath">#frac(Gamma |--_Sigma f : tau_1 -&gt; tau_2 \qquad Gamma |--_Sigma x : tau_1)(Gamma |--_Sigma f x : tau_2) -&gt;E#</code></p>
<p>Since this notation is ubiquitous, authors (reasonably) expect readers to already be familiar with it and thus provide no explanation. Because the notation is ubiquitous, the beginner looking for alternate resources will not escape it. All they will find is that the notation is everywhere but exists in myriad minor variations which may or may not indicate significant differences. At this point the options are: 1) to muddle on and hope understanding the notation isn’t too important, 2) look for introductory resources which typically take the form of $50+ 500+ page textbooks, or 3) give up.</p>
<p>The goal of this article is to explain the notation part-by-part in common realizations, and to cover the main idea behind the notation which is the idea of an inductively defined relation. To eliminate ambiguity and make hand-waving impossible, I’ll ground the explanations in code, in particular, in <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php">Agda</a>. That means for each example of the informal notation, there will be how it would be realized in Agda.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> It will become clear that I’m am not (just) using Agda as a formal notation to talk about these concepts, but that Agda’s<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> data type mechanism directly captures them<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>. The significance of this is that programmers are already familiar with many of the ideas behind the informal notation, and the notation is just obscuring this familiarity. Admittedly, Agda is itself pretty intimidating. I hope most of this article is accessible to those with familiarity with algebraic data types as they appear in Haskell, ML, Rust, or Swift with little to no need to look up details about Agda. Nevertheless, Agda at least has the benefit, when compared to the informal notation, of having a clear place to go to learn more, an unambiguous meaning, and tools that allow playing around with the ideas.</p>
<!--more-->
<h3 id="parsing-and-reading">Parsing and reading</h3>
<p>To start, if you are not already familiar with it, get familiar with the <a href="https://en.wikipedia.org/wiki/Greek_alphabet#Letters">Greek alphabet</a>. It will be far easier to (mentally) read mathematical notation of any kind if you can say “Gamma x” rather than “right angle thingy x” or “upside-down L x”.</p>
<p>Using the example from the introduction, the whole thing is a <strong>rule</strong>. The “|-&gt;I|” part is just the name of the rule (in this case being short for “|-&gt;| Introduction”). This rule is only <em>part</em> of the definition of the <strong>judgment</strong> of the form:</p>
<p><code class="asciimath">#Gamma |--_Sigma e : tau#</code></p>
<p>The judgment can be viewed as a proposition and the rule is an “if-then” statement read from top to bottom. So the “|-&gt;I|” rule says, “<strong>if</strong> <code class="asciimath">#Gamma, x : tau_1 |--_Sigma e : tau_2#</code> <strong>then</strong> <code class="asciimath">#Gamma |--_Sigma lambda x : tau_1.e : tau_1 -&gt; tau_2#</code>”. It is often profitable to read it bottom-up as “<strong>To prove</strong> <code class="asciimath">#Gamma |--_Sigma lambda x : tau_1.e : tau_1 -&gt; tau_2#</code> <strong>you need to show</strong> <code class="asciimath">#Gamma, x : tau_1 |--_Sigma e : tau_2#</code>”.</p>
<p>So what is the judgment saying? First, the judgment is, in this case, a four argument relation. The arguments of this relation are #Gamma#, #Sigma#, #e#, and #tau#. We could say the name of this relation is the perspicuous <code class="asciimath">#(_)|--_((_)) (_) : (_)#</code>. Note that it does not make sense to ask what “⊢” means or what “:” means anymore than it makes sense to ask what “-&gt;” means in Haskell’s <code class="sourceCode haskell">\ x <span class="ot">-&gt;</span> e</code>.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
<p>In the context of type systems, #Gamma# is called the <strong>context</strong>, #Sigma# is called the <strong>signature</strong>, #e# is the <strong>term</strong> or <strong>expression</strong>, and #tau# is the <strong>type</strong>. Given this, I would read <code class="asciimath">#Gamma |--_Sigma e : tau#</code> as “the expression e has type tau in context gamma given signature sigma.” For the “#-&gt;E#” rule we have, additionally, multiple judgements above the line. These are joined together by conjunction, that is, we’d read “#-&gt;E#” as “<strong>if</strong> <code class="asciimath">#Gamma |--_Sigma f : tau_1 -&gt; tau_2#</code> <strong>and</strong> <code class="asciimath">#Gamma |--_Sigma x : tau_1#</code> <strong>then</strong> <code class="asciimath">#Gamma |--_Sigma f x : tau_2#</code></p>
<p>In most recent type system research multiple judgments are necessary to describe the type system, and so you may see things like <code class="asciimath">#Gamma |-- e &gt; tau#</code> or <code class="asciimath">#Gamma |-- e_1 &quot;~&quot; e_2#</code>. The key thing to remember is that these are completely distinct relations that will have their own definitions (although the collection of them will often be mutually recursively defined).</p>
<h3 id="inductively-defined-relations">Inductively Defined Relations</h3>
<h4 id="relations">Relations</h4>
<p>Relations in set theory are boolean valued functions. Being programmers, and thus constructivists, we want evidence, so a relation |R : A xx B -&gt; bb2| becomes a type constructor <code class="sourceCode agda">R <span class="ot">:</span> <span class="ot">(</span>A , B<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="dt">Set</span></code>. |R(a,b)| holds if we have a value (proof/witness) <code class="sourceCode agda">w <span class="ot">:</span> R a b</code>. An <strong>inductively defined relation</strong> or <strong>judgment</strong> is then just a type constructor for an (inductive) data type. That means, if <code>R</code> is an inductively defined relation, then its definition is <code class="sourceCode agda"><span class="kw">data</span> R <span class="ot">:</span> A <span class="ot">-&gt;</span> B <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="kw">where</span> <span class="ot">...</span></code>. A <strong>rule</strong> is a constructor of this data type. A <strong>derivation</strong> is a value of this data type, and will usually be a tree-like structure. As a bit of ambiguity in the terminology (arguably arising from a common ambiguity in mathematical notation), it’s a bit more natural to use the term “judgment” to refer to something that can be (at the meta level) true or false. For example, we’d say |R(a,b)| is a judgment. Nevertheless, when we say something like “the typing judgment” it’s clear that we’re referring to the whole relation, i.e. |R|.</p>
<h4 id="parameters-of-the-judgments">Parameters of the judgments</h4>
<p>Since a judgment is a relation, we need to describe what the arguments to the relation look like. Typically something like <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">BNF</a> is used. The BNF definitions provide the types used as parameters to the judgments. It is common to use a Fortran-esque style where a naming convention is used to avoid the need to explicitly declare the types of meta-variables. For example, the following says meta-variables like #n#, #m#, and #n_1# are all natural numbers.</p>
<pre><code>n, m ::= Z | S n</code></pre>
<p>BNF definitions translate readily to algebraic data types.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> Nat <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
    Z <span class="ot">:</span> Nat
    S <span class="ot">:</span> Nat <span class="ot">-&gt;</span> Nat</code></pre></div>
<blockquote>
<p>Agda note: <code class="sourceCode agda"><span class="dt">Set</span></code> is what is called <code class="sourceCode haskell"><span class="fu">*</span></code> in Haskell. “Type” would be a better name. Also, these sidebars will cover details about Agda with the aim that readers unfamiliar with Agda don’t get tripped up by tangential details.</p>
</blockquote>
<p>Sometimes it’s not possible to fully capture the constraints on well-formed syntax with BNF. In other words, only a subset of syntactically valid terms are well-formed. For example, <code class="sourceCode agda">Nat Nat</code> is syntactically valid but is not well-formed. We can pick out that subset with a predicate, i.e. a unary relation. This is, of course, nothing but another judgment. As an example, if we wired the <code class="sourceCode agda">Maybe</code> type into our type system, we’d likely have a judgment that looks like <code class="asciimath">#tau\ tt&quot;type&quot;#</code> which would include the following rule:</p>
<p><code class="asciimath">#frac(tau\ tt&quot;type&quot;)((&quot;Maybe&quot;\ tau)\ tt&quot;type&quot;)#</code></p>
<p>In a scenario like this, we’d also have to make sure the rules of our typing judgment also required the types involved to be well-formed. Modifying the example from the introduction, we’d get:</p>
<p><code class="asciimath">#frac(Gamma,x:tau_1 |--_Sigma e : tau_2 \qquad tau_1\ tt&quot;type&quot; \qquad tau_2\ tt&quot;type&quot;)(Gamma |--_Sigma (lambda x:tau_1.e) : tau_1 -&gt; tau_2) -&gt;I#</code></p>
<h4 id="a-simple-inductively-defined-relation-in-agda">A simple inductively defined relation in Agda</h4>
<p>As a very simple example, let’s say we wanted to provide explicit evidence that one natural number was less than or equal to another in Agda. Scenarios like this are common in dependently typed programming, and so we’ll start with the Agda this time and then “informalize” it.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> <span class="ot">_</span>isLessThanOrEqualTo<span class="ot">_</span> <span class="ot">:</span> Nat <span class="ot">-&gt;</span> Nat <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="kw">where</span>
    Z&lt;=n <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> Z isLessThanOrEqualTo n
    Sm&lt;=Sn <span class="ot">:</span> <span class="ot">{</span>m <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> m isLessThanOrEqualTo n <span class="ot">-&gt;</span> <span class="ot">(</span>S m<span class="ot">)</span> isLessThanOrEqualTo <span class="ot">(</span>S n<span class="ot">)</span></code></pre></div>
<blockquote>
<p>Agda notes: In Agda identifiers can contain almost any character so <code class="sourceCode agda">Z&lt;=n</code> is just an identifier. Agda allows any identifier to be used infix (or more generally mixfix). The underscores mark where the arguments go. So <code class="sourceCode agda"><span class="ot">_</span>isLessThanOrEqualTo<span class="ot">_</span></code> is a binary infix operator. Finally, curly brackets indicate implicit arguments which can be omitted and Agda will “guess” their values. Usually, they’ll be obvious to Agda by unification.</p>
</blockquote>
<p>In the informal notation, the types of the arguments are implied by the naming. <code>n</code> is a natural number because it was used as the metavariable (non-terminal) in the BNF for naturals. We also implicitly quantify over all free variables. In the Agda code, this quantification was explicit.</p>
<p><code class="asciimath">#frac()(Z &lt;= n) tt&quot;Z&lt;=n&quot;#</code></p>
<p><code class="asciimath">#frac(m &lt;= n)(S m &lt;= S n) tt&quot;Sm&lt;=Sn&quot;#</code></p>
<p>Again, I want to emphasize that these are <em>defining</em> <code>isLessThanOrEqualTo</code> and |&lt;=|. They can’t be wrong. They can only fail to coincide with our intuitions or to an alternate definition. A derivation that |2 &lt;= 3| looks like:</p>
<p>In Agda:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">twoIsLessThanThree <span class="ot">:</span> <span class="ot">(</span>S <span class="ot">(</span>S Z<span class="ot">))</span> isLessThanOrEqualTo <span class="ot">(</span>S <span class="ot">(</span>S <span class="ot">(</span>S Z<span class="ot">)))</span>
twoIsLessThanThree <span class="ot">=</span> Sm&lt;=Sn <span class="ot">(</span>Sm&lt;=Sn Z&lt;=n<span class="ot">)</span></code></pre></div>
<p>In the informal notation:</p>
<p><code class="asciimath">#frac(frac()(Z &lt;= S Z))(frac(S Z &lt;= S (S Z))(S (S Z) &lt;= S (S (S Z)))#</code></p>
<h3 id="big-step-operational-semantics">Big-step operational semantics</h3>
<p>Here’s a larger example that also illustrates that these judgments do not need to be typing judgments. Here we’re defining a big-step operational semantics for the untyped lambda calculus.</p>
<pre><code>x variable
v ::= λx.e
e ::= v | e e | x</code></pre>
<p>In informal presentations, binders like #lambda# are handled in a fairly relaxed manner. While the details of handling binders are tricky and error-prone, they are usually standard and so authors assume readers can fill in those details and are aware of the concerns (e.g. variable capture). In Agda, of course, we’ll need to spell out the details. There are <a href="https://namebinding.wordpress.com/">many approaches</a> for dealing with binders with different trade-offs. One of the newer and more convenient approaches is parametric higher-order abstract syntax (PHOAS). Higher-order abstract syntax (HOAS) approaches allow us to reuse the binding structure of the host language and thus eliminate much of the work. Below, this is realized by the <code class="sourceCode agda">Lambda</code> constructor taking a function as its argument. In a later section, I’ll use a different approach using deBruijn indices.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="co">-- PHOAS approach to binding</span>
<span class="kw">mutual</span>
    <span class="kw">data</span> Expr <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
        Val <span class="ot">:</span> Value A <span class="ot">-&gt;</span> Expr A
        App <span class="ot">:</span> Expr A <span class="ot">-&gt;</span> Expr A <span class="ot">-&gt;</span> Expr A
        Var <span class="ot">:</span> A <span class="ot">-&gt;</span> Expr A

    <span class="kw">data</span> Value <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
        Lambda <span class="ot">:</span> <span class="ot">(</span>A <span class="ot">-&gt;</span> Expr A<span class="ot">)</span> <span class="ot">-&gt;</span> Value A

<span class="co">-- A closed expression</span>
CExpr <span class="ot">:</span> <span class="dt">Set1</span>
CExpr <span class="ot">=</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> Expr A

<span class="co">-- A closed expression that is a value</span>
CValue <span class="ot">:</span> <span class="dt">Set1</span>
CValue <span class="ot">=</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> Value A</code></pre></div>
<blockquote>
<p>Agda note: <code class="sourceCode agda"><span class="dt">Set1</span></code> is needed for technical reasons that are unimportant. You can just pretend it says <code class="sourceCode agda"><span class="dt">Set</span></code> instead. More important is that the definitions of <code class="sourceCode agda">Expr</code> and <code class="sourceCode agda">Value</code> are a bit different than the definition for <code class="sourceCode agda"><span class="ot">_</span>isLessThanOrEqualTo<span class="ot">_</span></code>. In particular, the argument <code class="sourceCode agda"><span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span></code> occurs to the left of the colon. When an argument occurs to the left of the colon we say it <strong>parameterizes</strong> the data declaration and that it is a <strong>parameter</strong>. When it occurs to the right of the colon we say it <strong>indexes</strong> the data declaration and that it is an <strong>index</strong>. The difference is that parameters must occur uniformly in the return type of the data constructors while indexes can be different in each data constructor. The arguments of an inductively defined relation like <code class="sourceCode agda"><span class="ot">_</span>isLessThanOrEqualTo<span class="ot">_</span></code> will always be indexes (though there could be additional parameters.)</p>
</blockquote>
<p><code class="asciimath">#frac(e_1 darr lambda x.e \qquad e_2 darr v_2 \qquad e[x|-&gt;v_2] darr v)(e_1 e_2 darr v) tt&quot;App&quot;#</code></p>
<p><code class="asciimath">#frac()(v darr v) tt&quot;Trivial&quot;#</code></p>
<p>The #e darr v# judgment (read as “the expression #e# evaluates to the value #v#”) defines a call-by-value evaluation relation. #e[x|-&gt;v]# means “substitute #v# for #x# in the expression #e#”. This notation is not standardized; there are many variants. In more rigorous presentations this operation will be formally defined, but usually the authors assume you are familiar with it. In the <code class="asciimath">#tt&quot;Trivial&quot;#</code> rule, the inclusion of values into expressions is implicitly used. Note that the rule is restricted to values only.</p>
<p>The <code class="asciimath">#tt&quot;App&quot;#</code> rule specifies call-by-value because the #e_2# expression is evaluated and then the resulting value is substituted into #e#. For call-by-name, we’d omit the evaluation of #e_2# and directly substitute #e_2# for #x# in #e#. Whether #e_1# or #e_2# is evaluated first (or in parallel) is not specified in this example.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">subst <span class="ot">:</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> Expr <span class="ot">(</span>Expr A<span class="ot">)</span> <span class="ot">-&gt;</span> Expr A
subst <span class="ot">(</span>Var e<span class="ot">)</span> <span class="ot">=</span> e
subst <span class="ot">(</span>Val <span class="ot">(</span>Lambda b<span class="ot">))</span> <span class="ot">=</span> Val <span class="ot">(</span>Lambda <span class="ot">(λ</span> a <span class="ot">-&gt;</span> subst <span class="ot">(</span>b <span class="ot">(</span>Var a<span class="ot">))))</span>
subst <span class="ot">(</span>App e1 e2<span class="ot">)</span> <span class="ot">=</span> App <span class="ot">(</span>subst e1<span class="ot">)</span> <span class="ot">(</span>subst e2<span class="ot">)</span>

<span class="kw">data</span> <span class="ot">_</span>EvaluatesTo<span class="ot">_</span> <span class="ot">:</span> CExpr <span class="ot">-&gt;</span> CValue <span class="ot">-&gt;</span> <span class="dt">Set1</span> <span class="kw">where</span>
    EvaluateTrivial <span class="ot">:</span> <span class="ot">{</span>v <span class="ot">:</span> CValue<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>Val v<span class="ot">)</span> EvaluatesTo v
    EvaluateApp <span class="ot">:</span> <span class="ot">{</span>e1 <span class="ot">:</span> CExpr<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>e2 <span class="ot">:</span> CExpr<span class="ot">}</span>
        <span class="ot">-&gt;</span> <span class="ot">{</span>e <span class="ot">:</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> A <span class="ot">-&gt;</span> Expr A<span class="ot">}</span>
        <span class="ot">-&gt;</span> <span class="ot">{</span>v2 <span class="ot">:</span> CValue<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>v <span class="ot">:</span> CValue<span class="ot">}</span>
        <span class="ot">-&gt;</span> e1 EvaluatesTo <span class="ot">(</span>Lambda e<span class="ot">)</span>
        <span class="ot">-&gt;</span> e2 EvaluatesTo v2
        <span class="ot">-&gt;</span> <span class="ot">(</span>subst <span class="ot">(</span>e <span class="ot">(</span>Val v2<span class="ot">)))</span> EvaluatesTo v
        <span class="ot">-&gt;</span> <span class="ot">(</span>App e1 e2<span class="ot">)</span> EvaluatesTo v</code></pre></div>
<p>The <code class="sourceCode agda">EvaluateTrivial</code> constructor explicitly uses the <code class="sourceCode agda">Val</code> injection of values into expressions. The <code class="sourceCode agda">EvaluateApp</code> constructor starts off with a series of implicit arguments that introduce and quantify over the variables used in the rule. After those, each judgement above the line in the <code class="asciimath">#tt&quot;App&quot;#</code> rule, becomes an argument to the <code class="sourceCode agda">EvaluateApp</code> constructor.</p>
<p>In this case ↓ is defining a functional relation, meaning for every expression there’s at most one value that the expression evaluates to. So another natural way to interpret ↓ is as a definition, in logic programming style, of a (partial) recursive function. In other words we can use the concept of mode from logic programming and instead of treating the arguments to ↓ as inputs, we can treat the first as an input and the second as an output.</p>
<p>↓ gives rise to a partial function because not every expression has a normal form. For <code class="sourceCode agda"><span class="ot">_</span>EvaluatesTo<span class="ot">_</span></code> this is realized by the fact that we simply won’t be able to construct a term of type <code class="sourceCode agda">e EvaluatesTo v</code> for any <code class="sourceCode agda">v</code> if <code class="sourceCode agda">e</code> doesn’t have a normal form. In fact, we can use the inductive structure of the relationship to help prove that statement. (Unfortunately, Agda doesn’t present a very good experience for data types indexed by functions, so the proof is not nearly as smooth as one would like.)</p>
<h3 id="type-systems">Type systems</h3>
<p>Next we’ll turn to type systems which will present an even larger example, and will introduce some concepts that are specific to type systems (though, of course, they overlap greatly with concepts in logic due to the Curry-Howard correspondence.)</p>
<h4 id="terms-and-types">Terms and types</h4>
<p>Below is an informal presentation of the polymorphic lambda calculus with explicit type abstraction and type application. An interesting fact about the polymorphic lambda calculus is that we don’t need any base types. Via Church-encoding, we can define types like natural numbers and lists.</p>
<pre><code>α type variable
τ ::= τ → τ | ∀α. τ | α

x variable
c constant
v ::= λx:τ.e | Λτ.e | c
e ::= v | e e | e[τ] | x</code></pre>
<p>In this case I’ll be using deBruijn indices to handle the binding structure of the terms and types. This means instead of writing <code class="asciimath">|lambda x.lambda y. x|</code>, you would write <code class="asciimath">|lambda lambda 1|</code> where the |1| counts how many binders (lambdas) you need to traverse to reach the binding site.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> TType <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
    TTVar <span class="ot">:</span> Nat <span class="ot">-&gt;</span> TType                    <span class="co">-- α</span>
    <span class="ot">_</span>=&gt;<span class="ot">_</span> <span class="ot">:</span> TType <span class="ot">-&gt;</span> TType <span class="ot">-&gt;</span> TType          <span class="co">-- τ → τ</span>
    Forall <span class="ot">:</span> TType <span class="ot">-&gt;</span> TType                 <span class="co">-- ∀α. τ</span>

<span class="kw">mutual</span>
    <span class="kw">data</span> TExpr <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
        TVal <span class="ot">:</span> TValue <span class="ot">-&gt;</span> TExpr              <span class="co">-- v</span>
        TApp <span class="ot">:</span> TExpr <span class="ot">-&gt;</span> TExpr <span class="ot">-&gt;</span> TExpr      <span class="co">-- f x</span>
        TTyApp <span class="ot">:</span> TExpr <span class="ot">-&gt;</span> TType <span class="ot">-&gt;</span> TExpr    <span class="co">-- e[τ]</span>
        TVar <span class="ot">:</span> Nat <span class="ot">-&gt;</span> TExpr                 <span class="co">-- x</span>

    <span class="kw">data</span> TValue <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
        TLambda <span class="ot">:</span> TType <span class="ot">-&gt;</span> TExpr <span class="ot">-&gt;</span> TValue  <span class="co">-- λx:τ.e</span>
        TTyLambda <span class="ot">:</span> TExpr <span class="ot">-&gt;</span> TValue         <span class="co">-- Λτ.e</span>
        TConst <span class="ot">:</span> Nat <span class="ot">-&gt;</span> TValue              <span class="co">-- c</span></code></pre></div>
<h4 id="the-context">The Context</h4>
<p>In formulating the typing rules we need to deal with <strong>open terms</strong>, that is terms which refer to variables that they don’t bind. This should only happen if some enclosing terms <em>did</em> bind those variables, so we need to keep track of the variables that have been bound by enclosing terms. For example, when type checking <code class="asciimath">|lambda x:tau.x|</code>, we’ll need to type check the subterm |x| which does not contain enough information in itself for us to know what the type should be. So, we keep track of what variables have been bound (and to what type) in a <strong>context</strong> and then we can just look up the expected type. When authors bother formally spelling out the context, it will look something like the following:</p>
<pre><code>Γ ::= . | Γ, x:τ
Δ ::= . | Δ, α</code></pre>
<p>We see that this is just a (snoc) list. In the first case, |Gamma|, it is a list of pairs of variables and types, i.e. an association list mapping variables to types. Often it will be treated as a finite mapping. In the second case, |Delta|, it is a list of type variables. Since I’m using deBruijn notation, there are no variables so we end up with a list of types in the first case. In the second case, we would end up with a list of nothing in particular, i.e. a list of unit, but that is isomorphic to a natural number. In other words, the only purpose of the type context, |Delta|, is to make sure we don’t use unbound variables, which in deBruijn notation just means we don’t have deBruijn indexes that try to traverse more lambdas than enclose them. The Agda code for the above is completely straight-forward.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> List <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
    Nil <span class="ot">:</span> List A
    <span class="ot">_</span>,<span class="ot">_</span> <span class="ot">:</span> List A <span class="ot">-&gt;</span> A <span class="ot">-&gt;</span> List A

Context <span class="ot">:</span> <span class="dt">Set</span>
Context <span class="ot">=</span> List TType

TypeContext <span class="ot">:</span> <span class="dt">Set</span>
TypeContext <span class="ot">=</span> Nat</code></pre></div>
<h4 id="the-signature">The Signature</h4>
<p>Signatures keep track of what primitive, “user-defined” constants might exist. Often the signature is omitted since nothing particularly interesting happens with it. Indeed, that will be the case for us. Nevertheless, we see that the signature is just another association list mapping constants to types.</p>
<pre><code>Σ ::= . | Σ, c:τ</code></pre>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">Signature <span class="ot">:</span> <span class="dt">Set</span>
Signature <span class="ot">=</span> List TType</code></pre></div>
<p>The main reason I included the signature, beyond just covering it for the cases when it is included, is that sometimes certain rules can be better understood as manipulations of the signature. For example, in <em>logic</em>, universal quantification is often described by a rule like:</p>
<p><code class="asciimath">#frac(Gamma |-- P[x|-&gt;c] \qquad c\ &quot;fresh&quot;)(Gamma |-- forall x.P)#</code></p>
<p>What’s happening and what “freshness” is is made a bit clearer by employing a signature (which for logic is usually just a list of constants similar to our <code>TypeContext</code>):</p>
<p><code class="asciimath">#frac(Gamma |--_(Sigma, c) P[x|-&gt;c] \qquad c notin Sigma)(Gamma |--_Sigma forall x.P)#</code></p>
<h4 id="judgment">Judgment</h4>
<p>To define the typing rules we need two judgements. The first, <code class="asciimath">#Delta |-- tau#</code>, will be a simple judgement that says |tau| is a well formed type in |Delta|. This basically just requires that all variables are bound.</p>
<p><code class="asciimath">#frac(alpha in Delta)(Delta |-- alpha)#</code></p>
<p><code class="asciimath">#frac(Delta, alpha |-- tau)(Delta |-- forall alpha. tau)#</code></p>
<p><code class="asciimath">#frac(Delta |-- tau_1 \qquad Delta |-- tau_2)(Delta |-- tau_1 -&gt; tau_2)#</code></p>
<p>The Agda is</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> <span class="ot">_</span>&lt;<span class="ot">_</span> <span class="ot">:</span> Nat <span class="ot">-&gt;</span> Nat <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="kw">where</span>
    Z&lt;Sn <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> Z &lt; S n
    Sn&lt;SSm <span class="ot">:</span> <span class="ot">{</span>n m <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> n &lt; S m <span class="ot">-&gt;</span> S n &lt; S <span class="ot">(</span>S m<span class="ot">)</span>

<span class="kw">data</span> <span class="ot">_</span>isValidIn<span class="ot">_</span> <span class="ot">:</span> TType <span class="ot">-&gt;</span> TypeContext <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="kw">where</span>
    TyVarJ <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>ctx <span class="ot">:</span> TypeContext<span class="ot">}</span> <span class="ot">-&gt;</span> n &lt; ctx <span class="ot">-&gt;</span> <span class="ot">(</span>TTVar n<span class="ot">)</span> isValidIn ctx
    TyArrJ <span class="ot">:</span> <span class="ot">{</span>t1 t2 <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>ctx <span class="ot">:</span> TypeContext<span class="ot">}</span> <span class="ot">-&gt;</span> t1 isValidIn ctx <span class="ot">-&gt;</span> t2 isValidIn ctx <span class="ot">-&gt;</span> <span class="ot">(</span>t1 =&gt; t2<span class="ot">)</span> isValidIn ctx
    TyForallJ <span class="ot">:</span> <span class="ot">{</span>t <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>ctx <span class="ot">:</span> TypeContext<span class="ot">}</span> <span class="ot">-&gt;</span> t isValidIn <span class="ot">(</span>S ctx<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>Forall t<span class="ot">)</span> isValidIn ctx</code></pre></div>
<p>The meat is the following typing judgement, depending on the judgement defining well-formed types. I’m not really going to explain these rules because, in some sense, there is nothing to explain. Beyond explaining the notation itself, which was the point of the article, the below is “self-explanatory” in the sense that it is a definition, and whether it is a good definition or “meaningful” depends on whether we can prove the theorems we want about it.</p>
<p><code class="asciimath">#frac(c:tau in Sigma \qquad Delta |-- tau)(Delta;Gamma |--_Sigma c : tau) tt&quot;Const&quot;#</code></p>
<p><code class="asciimath">#frac(x:tau in Gamma \qquad Delta |-- tau)(Delta;Gamma |--_Sigma x : tau) tt&quot;Var&quot;#</code></p>
<p><code class="asciimath">#frac(Delta;Gamma |--_Sigma e_1 : tau_1 -&gt; tau_2 \qquad Delta;Gamma |--_Sigma e_2 : tau_1)(Delta;Gamma |--_Sigma e_1 e_2 : tau_2) tt&quot;App&quot;#</code></p>
<p><code class="asciimath">#frac(Delta;Gamma |--_Sigma e : forall alpha. tau_1 \qquad Delta |-- tau_2)(Delta;Gamma |--_Sigma e[tau_2] : tau_1[alpha|-&gt;tau_2]) tt&quot;TyApp&quot;#</code></p>
<p><code class="asciimath">#frac(Delta;Gamma, x:tau_1 |--_Sigma e : tau_2 \qquad Delta |-- tau_1)(Delta;Gamma |--_Sigma (lambda x:tau_1.e) : tau_1 -&gt; tau_2) tt&quot;Abs&quot;#</code></p>
<p><code class="asciimath">#frac(Delta, alpha;Gamma |--_Sigma e : tau)(Delta;Gamma |--_Sigma (Lambda alpha.e) : forall alpha. tau) tt&quot;TyAbs&quot;#</code></p>
<p>Here’s the corresponding Agda code. Note, all Agda is doing for us here is making sure we haven’t written self-contradictory nonsense. In no way is Agda ensuring that this is the “right” definition. For example, it could be the case (but isn’t) that there are no values of this type. Agda would be perfectly content to let us define a type that had no values.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">tySubst <span class="ot">:</span> TType <span class="ot">-&gt;</span> TType <span class="ot">-&gt;</span> TType
tySubst t1 t2 <span class="ot">=</span> tySubst&#39; t1 t2 Z
    <span class="kw">where</span> tySubst&#39; <span class="ot">:</span> TType <span class="ot">-&gt;</span> TType <span class="ot">-&gt;</span> Nat <span class="ot">-&gt;</span> TType
          tySubst&#39; <span class="ot">(</span>TTVar Z<span class="ot">)</span> t2 Z <span class="ot">=</span> t2
          tySubst&#39; <span class="ot">(</span>TTVar Z<span class="ot">)</span> t2 <span class="ot">(</span>S <span class="ot">_)</span> <span class="ot">=</span> TTVar Z
          tySubst&#39; <span class="ot">(</span>TTVar <span class="ot">(</span>S n<span class="ot">))</span> t2 Z <span class="ot">=</span> TTVar <span class="ot">(</span>S n<span class="ot">)</span>
          tySubst&#39; <span class="ot">(</span>TTVar <span class="ot">(</span>S n<span class="ot">))</span> t2 <span class="ot">(</span>S d<span class="ot">)</span> <span class="ot">=</span> tySubst&#39; <span class="ot">(</span>TTVar n<span class="ot">)</span> t2 d
          tySubst&#39; <span class="ot">(</span>t1 =&gt; t2<span class="ot">)</span> t3 d <span class="ot">=</span> tySubst&#39; t1 t3 d =&gt; tySubst&#39; t2 t3 d
          tySubst&#39; <span class="ot">(</span>Forall t1<span class="ot">)</span> t2 d <span class="ot">=</span> tySubst&#39; t1 t2 <span class="ot">(</span>S d<span class="ot">)</span>

<span class="kw">data</span> <span class="ot">_</span>isIn<span class="ot">_</span>at<span class="ot">_</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">:</span> A <span class="ot">-&gt;</span> List A <span class="ot">-&gt;</span> Nat <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="kw">where</span>
    Found <span class="ot">:</span> <span class="ot">{</span>a <span class="ot">:</span> A<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>l <span class="ot">:</span> List A<span class="ot">}</span> <span class="ot">-&gt;</span> a isIn <span class="ot">(</span>l , a<span class="ot">)</span> at Z
    Next <span class="ot">:</span> <span class="ot">{</span>a <span class="ot">:</span> A<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>b <span class="ot">:</span> A<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>l <span class="ot">:</span> List A<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> a isIn l at n <span class="ot">-&gt;</span> a isIn <span class="ot">(</span>l , b<span class="ot">)</span> at <span class="ot">(</span>S n<span class="ot">)</span>

<span class="kw">data</span> <span class="ot">_</span>hasType<span class="ot">_</span>inContext<span class="ot">_</span>and<span class="ot">_</span>given<span class="ot">_</span> <span class="ot">:</span> TExpr <span class="ot">-&gt;</span> TType <span class="ot">-&gt;</span> Context <span class="ot">-&gt;</span> TypeContext <span class="ot">-&gt;</span> Signature <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="kw">where</span>
    ConstJ <span class="ot">:</span> <span class="ot">{</span>t <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>c <span class="ot">:</span> Nat<span class="ot">}</span>
        <span class="ot">-&gt;</span> <span class="ot">{</span>Sigma <span class="ot">:</span> Signature<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Gamma <span class="ot">:</span> Context<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Delta <span class="ot">:</span> TypeContext<span class="ot">}</span>
        <span class="ot">-&gt;</span> t isIn Sigma at c
        <span class="ot">-&gt;</span> t isValidIn Delta
        <span class="ot">-&gt;</span> <span class="ot">(</span>TVal <span class="ot">(</span>TConst c<span class="ot">))</span> hasType t inContext Gamma and Delta given Sigma

    VarJ <span class="ot">:</span> <span class="ot">{</span>t <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>x <span class="ot">:</span> Nat<span class="ot">}</span>
        <span class="ot">-&gt;</span> <span class="ot">{</span>Sigma <span class="ot">:</span> Signature<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Gamma <span class="ot">:</span> Context<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Delta <span class="ot">:</span> TypeContext<span class="ot">}</span>
        <span class="ot">-&gt;</span> t isIn Gamma at x
        <span class="ot">-&gt;</span> t isValidIn Delta
        <span class="ot">-&gt;</span> <span class="ot">(</span>TVar x<span class="ot">)</span> hasType t inContext Gamma and Delta given Sigma

    AppJ <span class="ot">:</span> <span class="ot">{</span>t1 <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>t2 <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>e1 <span class="ot">:</span> TExpr<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>e2 <span class="ot">:</span> TExpr<span class="ot">}</span>
        <span class="ot">-&gt;</span> <span class="ot">{</span>Sigma <span class="ot">:</span> Signature<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Gamma <span class="ot">:</span> Context<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Delta <span class="ot">:</span> TypeContext<span class="ot">}</span>
        <span class="ot">-&gt;</span> e1 hasType <span class="ot">(</span>t1 =&gt; t2<span class="ot">)</span> inContext Gamma and Delta given Sigma
        <span class="ot">-&gt;</span> e2 hasType t1 inContext Gamma and Delta given Sigma
        <span class="ot">-&gt;</span> <span class="ot">(</span>TApp e1 e2<span class="ot">)</span> hasType t2 inContext Gamma and Delta given Sigma

    TyAppJ <span class="ot">:</span> <span class="ot">{</span>t1 <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>t2 <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>e <span class="ot">:</span> TExpr<span class="ot">}</span>
        <span class="ot">-&gt;</span> <span class="ot">{</span>Sigma <span class="ot">:</span> Signature<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Gamma <span class="ot">:</span> Context<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Delta <span class="ot">:</span> TypeContext<span class="ot">}</span>
        <span class="ot">-&gt;</span> e hasType <span class="ot">(</span>Forall t1<span class="ot">)</span> inContext Gamma and Delta given Sigma
        <span class="ot">-&gt;</span> t2 isValidIn Delta
        <span class="ot">-&gt;</span> <span class="ot">(</span>TTyApp e t2<span class="ot">)</span> hasType <span class="ot">(</span>tySubst t1 t2<span class="ot">)</span> inContext Gamma and Delta given Sigma

    AbsJ <span class="ot">:</span> <span class="ot">{</span>t1 <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>t2 <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>e <span class="ot">:</span> TExpr<span class="ot">}</span>
        <span class="ot">-&gt;</span> <span class="ot">{</span>Sigma <span class="ot">:</span> Signature<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Gamma <span class="ot">:</span> Context<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Delta <span class="ot">:</span> TypeContext<span class="ot">}</span>
        <span class="ot">-&gt;</span> e hasType t2 inContext <span class="ot">(</span>Gamma , t1<span class="ot">)</span> and Delta given Sigma
        <span class="ot">-&gt;</span> <span class="ot">(</span>TVal <span class="ot">(</span>TLambda t1 e<span class="ot">))</span> hasType <span class="ot">(</span>t1 =&gt; t2<span class="ot">)</span> inContext Gamma and Delta given Sigma

    TyAbsJ <span class="ot">:</span> <span class="ot">{</span>t <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>e <span class="ot">:</span> TExpr<span class="ot">}</span>
        <span class="ot">-&gt;</span> <span class="ot">{</span>Sigma <span class="ot">:</span> Signature<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Gamma <span class="ot">:</span> Context<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Delta <span class="ot">:</span> TypeContext<span class="ot">}</span>
        <span class="ot">-&gt;</span> e hasType t inContext Gamma and <span class="ot">(</span>S Delta<span class="ot">)</span> given Sigma
        <span class="ot">-&gt;</span> <span class="ot">(</span>TVal <span class="ot">(</span>TTyLambda e<span class="ot">))</span> hasType <span class="ot">(</span>Forall t<span class="ot">)</span> inContext Gamma and Delta given Sigma</code></pre></div>
<p>Here’s a typing derivation for the polymorphic constant function:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">
tyLam <span class="ot">:</span> TExpr <span class="ot">-&gt;</span> TExpr
tyLam e <span class="ot">=</span> TVal <span class="ot">(</span>TTyLambda e<span class="ot">)</span>

lam <span class="ot">:</span> TType <span class="ot">-&gt;</span> TExpr <span class="ot">-&gt;</span> TExpr
lam t e <span class="ot">=</span> TVal <span class="ot">(</span>TLambda t e<span class="ot">)</span>

polyConst
    <span class="ot">:</span> tyLam <span class="ot">(</span>tyLam <span class="ot">(</span>lam <span class="ot">(</span>TTVar Z<span class="ot">)</span> <span class="ot">(</span>lam <span class="ot">(</span>TTVar <span class="ot">(</span>S Z<span class="ot">))</span> <span class="ot">(</span>TVar <span class="ot">(</span>S Z<span class="ot">)))))</span>    <span class="co">-- Λs.Λt.λx:t.λy:s.x</span>
    hasType <span class="ot">(</span>Forall <span class="ot">(</span>Forall <span class="ot">(</span>TTVar Z =&gt; <span class="ot">(</span>TTVar <span class="ot">(</span>S Z<span class="ot">)</span> =&gt; TTVar Z<span class="ot">))))</span>     <span class="co">-- ∀s.∀t.t→s→t</span>
    inContext Nil and Z
    given Nil
polyConst <span class="ot">=</span> TyAbsJ <span class="ot">(</span>TyAbsJ <span class="ot">(</span>AbsJ <span class="ot">(</span>AbsJ <span class="ot">(</span>VarJ <span class="ot">(</span>Next Found<span class="ot">)</span> <span class="ot">(</span>TyVarJ Z&lt;Sn<span class="ot">)))))</span> <span class="co">-- written by Agda</span>

<span class="kw">data</span> False <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>

Not <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">-&gt;</span> <span class="dt">Set</span>
Not A <span class="ot">=</span> A <span class="ot">-&gt;</span> False

wrongType
    <span class="ot">:</span> Not <span class="ot">(</span>tyLam <span class="ot">(</span>lam <span class="ot">(</span>TTVar Z<span class="ot">)</span> <span class="ot">(</span>TVar Z<span class="ot">))</span>   <span class="co">-- Λt.λx:t.x</span>
           hasType <span class="ot">(</span>Forall <span class="ot">(</span>TTVar Z<span class="ot">))</span>       <span class="co">-- ∀t.t</span>
           inContext Nil and Z
           given Nil<span class="ot">)</span>
wrongType <span class="ot">(</span>TyAbsJ <span class="ot">())</span></code></pre></div>
<p>Having written all this, we have not defined a type checking algorithm (though Agda’s <code>auto</code> tactic does a pretty good job); we’ve merely specified what evidence that a program is well-typed is. Explicitly, a type checking algorithm would be a function with the following type:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> Maybe <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
    Nothing <span class="ot">:</span> Maybe A
    Just <span class="ot">:</span> A <span class="ot">-&gt;</span> Maybe A

typeCheck <span class="ot">:</span> <span class="ot">(</span>e <span class="ot">:</span> TExpr<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>t <span class="ot">:</span> TType<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>sig <span class="ot">:</span> Signature<span class="ot">)</span> <span class="ot">-&gt;</span> Maybe <span class="ot">(</span>e hasType t inContext Nil and Z given sig<span class="ot">)</span>
typeCheck <span class="ot">=</span> ?</code></pre></div>
<p>In fact, we’d want to additionally prove that this function never returns <code class="sourceCode agda">Nothing</code> if there does exist a typing derivation that would give <code>e</code> the type <code>t</code> in signature <code>sig</code>. We could formalize this in Agda by instead giving <code class="sourceCode agda">typeCheck</code> the following type:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> Decidable <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
    IsTrue <span class="ot">:</span> A <span class="ot">-&gt;</span> Decidable A
    IsFalse <span class="ot">:</span> Not A <span class="ot">-&gt;</span> Decidable A

typeCheckDec <span class="ot">:</span> <span class="ot">(</span>e <span class="ot">:</span> TExpr<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>t <span class="ot">:</span> TType<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>sig <span class="ot">:</span> Signature<span class="ot">)</span> <span class="ot">-&gt;</span> Decidable <span class="ot">(</span>e hasType t inContext Nil and Z given sig<span class="ot">)</span>
typeCheckDec <span class="ot">=</span> ?</code></pre></div>
<p>This type says that either <code class="sourceCode agda">typeCheckDec</code> will return a typing derivation, or it will return a proof that there is no typing derivation. As the name <code class="sourceCode agda">Decidable</code> suggests, this may not always be possible. Which is to say, type checking may not always be decidable. Note, we can <em>always</em> check that a <em>typing derivation</em> is valid — we just need to verify that we applied the rules correctly — what we can’t necessarily do is <em>find</em> such a derivation given only the expression and the type or prove that no such derivation exists. Similar concerns apply to type inference which could have one of the following types:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">record</span> Σ <span class="ot">(</span>T <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>F <span class="ot">:</span> T <span class="ot">-&gt;</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
    <span class="kw">field</span>
        fst <span class="ot">:</span> T
        snd <span class="ot">:</span> F fst

inferType <span class="ot">:</span> <span class="ot">(</span>e <span class="ot">:</span> TExpr<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>sig <span class="ot">:</span> Signature<span class="ot">)</span> <span class="ot">-&gt;</span> Maybe <span class="ot">(</span>Σ TType <span class="ot">(λ</span> t <span class="ot">→</span> e hasType t inContext Nil and Z given sig<span class="ot">))</span>
inferType <span class="ot">=</span> ?

inferTypeDec <span class="ot">:</span> <span class="ot">(</span>e <span class="ot">:</span> TExpr<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>sig <span class="ot">:</span> Signature<span class="ot">)</span> <span class="ot">-&gt;</span> Decidable <span class="ot">(</span>Σ TType <span class="ot">(λ</span> t <span class="ot">→</span> e hasType t inContext Nil and Z given sig<span class="ot">))</span>
inferTypeDec <span class="ot">=</span> ?</code></pre></div>
<p>where Σ indicates a dependent sum, i.e. a pair where the second component (here of type <code class="sourceCode agda">e hasType t inContext Nil and Z given sig</code>) depends on the first component (here of type <code class="sourceCode agda">TType</code>). With type inference we have the additional concern that there may be multiple possible types an expression could have, and we may want to ensure it returns the “most general” type in some sense. There may not always be a good sense of “most general” type and user-input is required to pick out of the possible types.</p>
<p>Sometimes the rules themselves can be viewed as the defining rules of a logic program and thus directly provide an algorithm. For example, if we eliminate the rules, types, and terms related to polymorphism, we’d get the simply typed lambda calculus. A Prolog program to do type checking can be written in a few lines with a one-to-one correspondence to the type checking rules (and, for simplicitly, also omitting the signature):</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">lookup(z<span class="kw">,</span> [<span class="dt">T</span><span class="fu">|</span><span class="dt">_</span>]<span class="kw">,</span> <span class="dt">T</span>)<span class="kw">.</span>
lookup(s(<span class="dt">N</span>)<span class="kw">,</span> [<span class="dt">_</span><span class="fu">|</span><span class="dt">Ctx</span>]<span class="kw">,</span><span class="dt">T</span>) <span class="kw">:-</span> lookup(<span class="dt">N</span><span class="kw">,</span> <span class="dt">Ctx</span><span class="kw">,</span> <span class="dt">T</span>)<span class="kw">.</span>

typeCheck(<span class="dt">var</span>(<span class="dt">N</span>)<span class="kw">,</span> <span class="dt">Ctx</span><span class="kw">,</span> <span class="dt">T</span>) <span class="kw">:-</span> lookup(<span class="dt">N</span><span class="kw">,</span> <span class="dt">Ctx</span><span class="kw">,</span> <span class="dt">T</span>)<span class="kw">.</span>
typeCheck(app(<span class="dt">F</span><span class="kw">,</span><span class="dt">X</span>)<span class="kw">,</span> <span class="dt">Ctx</span><span class="kw">,</span> <span class="dt">T2</span>) <span class="kw">:-</span> typeCheck(<span class="dt">F</span><span class="kw">,</span> <span class="dt">Ctx</span><span class="kw">,</span> tarr(<span class="dt">T1</span><span class="kw">,</span> <span class="dt">T2</span>))<span class="kw">,</span> typeCheck(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Ctx</span><span class="kw">,</span> <span class="dt">T1</span>)<span class="kw">.</span>
typeCheck(lam(<span class="dt">B</span>)<span class="kw">,</span> <span class="dt">Ctx</span><span class="kw">,</span> tarr(<span class="dt">T1</span><span class="kw">,</span> <span class="dt">T2</span>)) <span class="kw">:-</span> typeCheck(<span class="dt">B</span><span class="kw">,</span> [<span class="dt">T1</span><span class="fu">|</span><span class="dt">Ctx</span>]<span class="kw">,</span> <span class="dt">T2</span>)<span class="kw">.</span></code></pre></div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="/posts/raw/UnderstandingTypingJudgments.agda">This Agda file</a> contains all the code from this article.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Most dependently typed languages, such as Coq or Epigram would also be adequate.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p><a href="https://en.wikipedia.org/wiki/Epigram_%28programming_language%29#Examples">Epigram</a> is most notable by actually using this 2D syntax.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>See <a href="http://cs.stackexchange.com/questions/54508/what-does-%E2%8A%A2-mean-in-operational-semantics/54514#54514">this StackExchange answer</a> for more discussion of this.<a href="#fnref4">↩</a></p></li>
</ol>
</div>]]></description>
    <pubDate>Wed, 13 Apr 2016 02:41:24 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/understanding-typing-judgments.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>
<item>
    <title>High dimensional thought experiment from Hamming</title>
    <link>https://derekelkins.github.io/posts/high-dimensional-thought-experiment.html</link>
    <description><![CDATA[<p>This is a simple mathematical thought experiment from Richard Hamming to demonstrate how poor our intuition for high dimensional spaces is. All that is needed is some basic, middle school level geometry and algebra.</p>
<p>Consider a 2x2 square centered at the origin. In each quadrant place circles as big as possible so that they fit in the square and don’t overlap. They’ll clearly have radius 1/2. See the image below. The question now is what’s the radius of the largest circle centered at the origin that doesn’t overlap the other circles.</p>
<p><img src="/posts/raw/high-dimensional-diagram.svg" alt=""></img></p>
<p>It’s clear from symmetry that the inner circle is going to touch all the other circles at the same time, and it is clear that it is going to touch along the line from the origin to the center of one of the outer circles. So the radius of the inner circle, #r#, is just the distance from the origin to the center of one of the outer circles minus the radius of the outer circle, namely 1/2. As an equation:</p>
<p><code class="asciimath">#r = sqrt(1/2^2 + 1/2^2) - 1/2 = sqrt(2)/2 - 1/2 ~~ 0.207106781#</code></p>
<p>Now if we go to three dimensions we’ll have eight circles instead of four, but everything else is the same except the distances will now be <code class="asciimath">#sqrt(1/2^2 + 1/2^2 + 1/2^2)#</code>. It’s clear that the only difference for varying dimensions is that in dimension #n# we’ll have #n# #1/2^2# terms under the square root sign. So the general solution is easily shown to be:</p>
<p><code class="asciimath">#r = sqrt(n)/2 - 1/2#</code></p>
<p>You should be weirded out now. If you aren’t, here’s a hint: what happens when #n = 10#? Here’s another hint: what happens as #n# approaches #oo#?</p>
<p>3blue1brown has a <a href="https://www.youtube.com/watch?v=zwAD6dRSVyI">video</a> describing this example and presenting one way of regaining intuition about it.</p>]]></description>
    <pubDate>Fri, 04 Dec 2015 01:22:52 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/high-dimensional-thought-experiment.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>
<item>
    <title>Behavioral Reflection</title>
    <link>https://derekelkins.github.io/posts/behavioral-reflection.html</link>
    <description><![CDATA[<h2 id="behavioral-reflection">Behavioral Reflection</h2>
<p>The ultimate goal of behavioral reflection (aka procedural reflection and no doubt other things) is to make a language where programs within the language are able to completely redefine the language as it executes. This is arguably the pinnacle of expressive power. This also means, though, local reasoning about code is utterly impossible, essentially by design.</p>
<p>Smalltalk is probably the language closest to this that is widely used. The Common Lisp MOP (Meta-Object Protocol) is also inspired by research in this vein. The ability to mutate classes and handle calls to missing methods as present in, e.g. Ruby, are also examples of very limited forms of behavioral reflection. (Though, for the latter, often the term “structural reflection” is used instead, reserving “behavioral reflection” for things beyond mere structural reflection.)</p>
<h3 id="very-brief-history">Very Brief History</h3>
<p>The seminal reference for behavioral reflection is Brian Smith’s 1982 <a href="http://publications.csail.mit.edu/lcs/specpub.php?id=840">thesis</a> on 3-LISP. This was followed by the languages <a href="http://cs.au.dk/~hosc/vol01/01-wand-friedman.html">Brown</a>, <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.40.2018&amp;rep=rep1&amp;type=pdf">Blond</a>, <a href="ftp://html.soic.indiana.edu/pub/techreports/TR362.pdf">Refci</a>, and <a href="http://www.is.ocha.ac.jp/~asai/Black/">Black</a> in chronological order. This is not a comprehensive list, and the last time I was in to this was about a decade ago. (Sure enough, there is some new work on Black and some very new citations of Black.)</p>
<!--[Reflection for the Masses](http://www.p-cos.net/documents/s32008.pdf) by Herzeel, Constanza, and D'Hondt.-->
<h3 id="core-idea">Core Idea</h3>
<p>The core idea is simply to expose the state of the (potentially conceptual) interpreter and allow it to be manipulated.</p>
<!--more-->
<p>From this perspective Scheme’s <code>call/cc</code> is a basic, limited example of behavioral reflection. It exposes one part of the state of the interpreter and allows it to be replaced. Delimited continuations (i.e. <code>shift</code> and <code>reset</code>) are a bit more powerful. They expose the same part of the state as <code>call/cc</code>, but they expose it in a more structured manner that allows more manipulations beyond merely replacing it. We could imagine representing the continuation with a less opaque object than a function which would lead to Smalltalk’s <code>MethodContext</code>.</p>
<p>Early Lisps’ fexpr was another example of exposing a different part of the interpreter state, namely the expression under evaluation. The <a href="https://web.cs.wpi.edu/~jshutt/kernel.html">Kernel</a> language explores this in more depth (among other things which can likely also be classified as forms of behavior reflection.)</p>
<p>For a language with mutation the heap would also be exposed. For a language without mutation, mutation can be added using the techniques from <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.43.8213&amp;rep=rep1&amp;type=pdf">Representing Monads</a> since something at least as powerful as delimited continuations will almost certainly be available. At that point, the heap would be first-class.</p>
<p>As an aside, I like to use the word “introspection” for purely read-only access to interpreter state, and reserve the word “reflection” for when manipulations are possible. Terminologically, “reflection” is also often broken down into “structural reflection” for the widely available ability to add and remove methods to classes and similar such operations; and “behavioral” or “procedural” reflection, the ability to manipulate the language itself. To control introspection and, at least, structural reflection, <a href="http://www.bracha.org/mirrors.pdf">mirrors</a> can be used.</p>
<!-- Reflective Tower -->
<h3 id="example">Example</h3>
<p>Making a simple behaviorally reflective language is actually pretty straightforward. If you have an abstract machine for your language, all you need to do is provide one additional primitive operation which gets passed the interpreter state and returns a new interpreter state. It may be clearer and cleaner, perhaps, to split this into two operations: one, often called <code>reify</code>, that provides the interpreter state as a value, and another, often called <code>reflect</code>, that sets the interpreter state to the state represented by the given value. Note that both <code>reify</code> and <code>reflect</code> are (very) impure operations. The more tedious part is marshalling the state of the interpreter into a language level object and vice versa. In the special case of a meta-circular interpreter, this part turns out to be trivial. The following interpreter is NOT meta-circular though.</p>
<p>The approach taken in this example, while simple, is very unstructured. For example, it is possible to write a procedure that when evaluated transforms the language from call-by-value (the CEK machine is an implementation of the CbV lambda calculus), to call-by name. However, to do this requires walking all the code in the environment and continuation and rewriting applications to force their first argument and delay their second argument. Primitives also need to be dealt with. It would be far nicer and cleaner to simply be able to say, “when you do an application, do this instead.” The newer behaviorally reflective languages work more like this.</p>
<p>Note, despite the fact that we do a global transformation, this is not an example of lack of expressiveness. We can define this transformation locally and execute it at run-time without coordination with the rest of the code. In this sense, everything is macro expressible (a la <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.51.4656&amp;rep=rep1&amp;type=pdf">Felleisen</a>) because arbitrary global transformations are macro expressible.</p>
<h3 id="the-code">The Code</h3>
<p>You can get a copy of the full version of the code from <a href="/posts/raw/CEK.hs">here</a>.</p>
<p>I arbitrarily decided to start from the CEK machine: an abstract machine for the untyped call-by-value lambda calculus. (CEK stands for Control-Environment-Kontinuation, these being the three pieces of interpreter state with control being the expression driving evaluation.) While a call-by-value language is probably the way to go because both <code>reify</code> and <code>reflect</code> are very impure operations (particularly <code>reflect</code>), the main motivation for choosing this machine was that the state components correspond in a direct way to concepts that are natural to the programmer. Compare this to the SECD machine which stands for Stack-Environment-Control-Dump.</p>
<p>The AST uses deBruijn indices.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span> 
    <span class="fu">=</span> <span class="dt">EVar</span> <span class="fu">!</span><span class="dt">Int</span> 
    <span class="fu">|</span> <span class="dt">ELam</span> <span class="dt">Expr</span> 
    <span class="fu">|</span> <span class="dt">Expr</span> <span class="fu">:@:</span> <span class="dt">Expr</span></code></pre></div>
<p>The only types of values we have are closures. The two additional pieces of interpreter state are the environment and the continuation (the call stack).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Value</span> <span class="fu">=</span> <span class="dt">Closure</span> <span class="dt">Expr</span> <span class="dt">Env</span>

<span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> [<span class="dt">Value</span>]

<span class="kw">data</span> <span class="dt">Kont</span> <span class="fu">=</span> <span class="dt">Done</span> <span class="fu">|</span> <span class="dt">Arg</span> <span class="dt">Expr</span> <span class="dt">Env</span> <span class="dt">Kont</span> <span class="fu">|</span> <span class="dt">Fun</span> <span class="dt">Value</span> <span class="dt">Kont</span></code></pre></div>
<p>Finally the evaluator is fairly straightforward, and is a straightforward transcription of the operational semantics. Evaluation starts off with the final contination and an empty environment. With a bit of inspection you can see that evaluation is call-by-value and proceeds left-to-right. Derive <code class="sourceCode haskell"><span class="dt">Show</span></code> for <code class="sourceCode haskell"><span class="dt">Expr</span></code> and <code class="sourceCode haskell"><span class="dt">Value</span></code> and these 15 lines of code are a complete interpreter.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">evaluate ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evaluate e <span class="fu">=</span> cek e [] <span class="dt">Done</span>

<span class="ot">cek ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Kont</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
cek (<span class="dt">EVar</span> i)  env                         k <span class="fu">=</span> cek e env&#39; k <span class="kw">where</span> <span class="dt">Closure</span> e env&#39; <span class="fu">=</span> env <span class="fu">!!</span> i
cek (f <span class="fu">:@:</span> x) env                         k <span class="fu">=</span> cek f env (<span class="dt">Arg</span> x env k)
cek (<span class="dt">ELam</span> b)  env                      <span class="dt">Done</span> <span class="fu">=</span> <span class="dt">Closure</span> b env
cek (<span class="dt">ELam</span> b)  env            (<span class="dt">Arg</span> x env&#39; k) <span class="fu">=</span> cek x env&#39; (<span class="dt">Fun</span> (<span class="dt">Closure</span> b env) k)
cek (<span class="dt">ELam</span> b)  env (<span class="dt">Fun</span> (<span class="dt">Closure</span> b&#39; env&#39;) k) <span class="fu">=</span> cek b&#39; (<span class="dt">Closure</span> b env<span class="fu">:</span>env&#39;) k</code></pre></div>
<p>The first stab at adding reflective features looks like this. We add the primitive operation to reify and reflect. We’ll require them to be wrapped in lambdas so the interpreter doesn’t have to deal with unevaluated arguments when interpreting them. Note that <code class="sourceCode haskell">reify</code> doesn’t pass the <code class="sourceCode haskell"><span class="dt">Expr</span></code> part to its argument. This is because the <code class="sourceCode haskell"><span class="dt">Expr</span></code> part would just be <code class="sourceCode haskell"><span class="dt">EReify</span></code>. The arguments of this particular application are stored, unevaluated, in the continuation as arguments needing to be evaluated. So, if we want to define <code class="sourceCode haskell">quote</code> which simply returns the expression representing it’s argument, we’ll have to dig into the continuation to get that argument.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span>
    <span class="fu">=</span> <span class="fu">...</span>
    <span class="fu">|</span> <span class="dt">EReify</span>
    <span class="fu">|</span> <span class="dt">EReflect</span>

<span class="co">-- reify f = f e k</span>
reify <span class="fu">=</span> <span class="dt">ELam</span> <span class="dt">EReify</span>

<span class="co">-- reflect c e k</span>
reflect <span class="fu">=</span> <span class="dt">ELam</span> (<span class="dt">ELam</span> (<span class="dt">ELam</span> <span class="dt">EReflect</span>))</code></pre></div>
<p>And here’s what we’d like to write in the interpreter (and is very close to what we ultimately will write.)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">cek ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Kont</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
<span class="fu">...</span>
cek <span class="dt">EReify</span>   (<span class="dt">Closure</span> b env&#39;<span class="fu">:</span>env) k <span class="fu">=</span> cek b (k<span class="fu">:</span>env<span class="fu">:</span>env&#39;) k
cek <span class="dt">EReflect</span> (k<span class="fu">:</span>e<span class="fu">:</span>c<span class="fu">:</span>_)            _ <span class="fu">=</span> cek c            e k</code></pre></div>
<p>There are two problems with this code: one minor and one major. The minor problem is that the argument to <code class="sourceCode haskell">reify</code> takes two arguments but we can’t just pass them directly to it. We need to follow our calling convention which expects to evaluate arguments one at a time. This problem is easily fixed by pushing an <code class="sourceCode haskell"><span class="dt">Arg</span></code> call stack frame onto the continuation to (trivially) evaluate the continuation.</p>
<p>The major problem is that this doesn’t type check. <code>c</code>, <code>e</code>, <code>env</code>, and <code>k</code> can’t simultaneously be <code class="sourceCode haskell"><span class="dt">Value</span></code>s and <code class="sourceCode haskell"><span class="dt">Expr</span></code>s, <code class="sourceCode haskell"><span class="dt">Env</span></code>s, and <code class="sourceCode haskell"><span class="dt">Kont</span></code>s. We need a way to embed and project <code class="sourceCode haskell"><span class="dt">Expr</span></code>, <code class="sourceCode haskell"><span class="dt">Env</span></code>, and <code class="sourceCode haskell"><span class="dt">Kont</span></code> value into and out of <code class="sourceCode haskell"><span class="dt">Value</span></code>. The embedding is easy; you just fold over the data structure and build up a lambda term representing the Church encoding. The projection from <code class="sourceCode haskell"><span class="dt">Value</span></code>s is… non-obvious, to say the least.</p>
<p>Instead of figuring that out, we can simply add <code class="sourceCode haskell"><span class="dt">Expr</span></code>, <code class="sourceCode haskell"><span class="dt">Env</span></code>, and <code class="sourceCode haskell"><span class="dt">Kont</span></code> to our language as primitive types. This is also, almost certainly, dramatically more efficient.</p>
<p>We extend our AST and <code class="sourceCode haskell"><span class="dt">Value</span></code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span>
    <span class="fu">=</span> <span class="fu">...</span>
    <span class="fu">|</span> <span class="dt">EInject</span> <span class="dt">Value</span>

<span class="co">-- Int so we can manipulate the EVar case.</span>
<span class="kw">data</span> <span class="dt">Value</span> <span class="fu">=</span> <span class="dt">Closure</span> <span class="dt">Expr</span> <span class="dt">Env</span> <span class="fu">|</span> <span class="dt">Int</span> <span class="fu">!</span><span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="fu">|</span> <span class="dt">Env</span> <span class="dt">Env</span> <span class="fu">|</span> <span class="dt">Kont</span> <span class="dt">Kont</span></code></pre></div>
<p>The changes to the interpreter are minimal. We need to change the <code class="sourceCode haskell"><span class="dt">EVar</span></code> case to handle the new kinds of values that can be returned and add a trivial <code class="sourceCode haskell"><span class="dt">EInject</span></code> case. Some cases can be omitted because they would only come up in programs that would “get stuck” anyway. (In our case, “getting stuck” means pattern match failure or index out of bounds.)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inject ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> (<span class="dt">Expr</span>, <span class="dt">Env</span>)
inject (<span class="dt">Closure</span> b env) <span class="fu">=</span> (<span class="dt">ELam</span> b, env)
inject v <span class="fu">=</span> (<span class="dt">EInject</span> v, [])
 
<span class="ot">cek ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Kont</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
cek (<span class="dt">EVar</span> i) env k <span class="fu">=</span> cek e env&#39; k <span class="kw">where</span> (e, env&#39;) <span class="fu">=</span> inject (env <span class="fu">!!</span> i)
<span class="fu">...</span>
cek <span class="dt">EReify</span> (<span class="dt">Closure</span> b env&#39;<span class="fu">:</span>env) k <span class="fu">=</span> cek b (<span class="dt">Env</span> env<span class="fu">:</span>env&#39;) (<span class="dt">Arg</span> (<span class="dt">EInject</span> (<span class="dt">Kont</span> k)) [] k)
cek <span class="dt">EReflect</span> (<span class="dt">Kont</span> k<span class="fu">:</span><span class="dt">Env</span> e<span class="fu">:</span><span class="dt">Expr</span> c<span class="fu">:</span>_) _ <span class="fu">=</span> cek c e k
cek (<span class="dt">EInject</span> v) _ <span class="dt">Done</span> <span class="fu">=</span> v
cek (<span class="dt">EInject</span> v) _ (<span class="dt">Fun</span> (<span class="dt">Closure</span> b&#39; env&#39;) k) <span class="fu">=</span> cek b&#39; (v<span class="fu">:</span>env&#39;) k</code></pre></div>
<p>While this interpreter achieves the goal, it is somewhat limited. We don’t have any means to manipulate the values of these new primitive types, so our manipulation of the interpreter state is limited to replacing a component, e.g. the environment, with some version of it that we got before via <code class="sourceCode haskell">reify</code>. Though it may be limited, it is not trivial. You can implement something close to call/cc if not call/cc itself.</p>
<p>Still, the scenario above of turning the language into a call-by-name language doesn’t seem possible. Modifying the interpreter to support primitive operations defined in Haskell is a simple matter of programming: you add a constructor for primitive operations to the AST, you make a very slight variant of the <code class="sourceCode haskell"><span class="dt">EInject</span></code> case in <code class="sourceCode haskell">cek</code>, and then you tediously make primitives corresponding to each constructor for each type and a fold for each type. See the linked <a href="/posts/raw/CEK.hs">source file</a> for the details.</p>
<p>The file additionally defines a pretty printer and a layer using parametric higher-order abstract syntax because humans are terrible with deBruijn indices. The end result is code that looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">one <span class="fu">=</span> _Suc <span class="fu">:@</span> _Zero

identity <span class="fu">=</span> lam (\x <span class="ot">-&gt;</span> x)

loop <span class="fu">=</span> lam (\x <span class="ot">-&gt;</span> x <span class="fu">:@</span> x) <span class="fu">:@</span> lam (\x <span class="ot">-&gt;</span> x <span class="fu">:@</span> x)

tailEnv <span class="fu">=</span> lam (\e <span class="ot">-&gt;</span> paraEnv <span class="fu">:@</span> e <span class="fu">:@</span> _Nil 
                                  <span class="fu">:@</span> lam (\_ <span class="ot">-&gt;</span> lam (\x <span class="ot">-&gt;</span> lam (\_ <span class="ot">-&gt;</span> x))))

tailKont <span class="fu">=</span> lam (\k <span class="ot">-&gt;</span> paraKont <span class="fu">:@</span> k <span class="fu">:@</span> _Done
                                    <span class="fu">:@</span> lam (\_ <span class="ot">-&gt;</span> lam (\_ <span class="ot">-&gt;</span> lam (\x <span class="ot">-&gt;</span> lam (\_ <span class="ot">-&gt;</span> x))))
                                    <span class="fu">:@</span> lam (\_ <span class="ot">-&gt;</span> lam (\x <span class="ot">-&gt;</span> lam (\_ <span class="ot">-&gt;</span> x))))

eval <span class="fu">=</span> lam (\c <span class="ot">-&gt;</span> reify <span class="fu">:@</span> lam (\e <span class="ot">-&gt;</span> lam (\k <span class="ot">-&gt;</span> reflect <span class="fu">:@</span> c <span class="fu">:@</span> (tailEnv <span class="fu">:@</span> e) <span class="fu">:@</span> k)))

quote <span class="fu">=</span> reify <span class="fu">:@</span> lam (\e <span class="ot">-&gt;</span> lam (\k <span class="ot">-&gt;</span> reflect <span class="fu">:@</span> (_Inject <span class="fu">:@</span> c k) <span class="fu">:@</span> e <span class="fu">:@</span> (tailKont <span class="fu">:@</span> k)))
    <span class="kw">where</span> c k <span class="fu">=</span> paraKont <span class="fu">:@</span> k <span class="fu">:@</span> garbage 
                              <span class="fu">:@</span> lam (\x <span class="ot">-&gt;</span> (lam (\_ <span class="ot">-&gt;</span> lam (\_ <span class="ot">-&gt;</span> lam (\_ <span class="ot">-&gt;</span> x))))) 
                              <span class="fu">:@</span> lam (\_ <span class="ot">-&gt;</span> lam (\_ <span class="ot">-&gt;</span> lam (\_ <span class="ot">-&gt;</span> garbage)))
          garbage <span class="fu">=</span> _Inject <span class="fu">:@</span> _Zero

callCC <span class="fu">=</span> lam (\f <span class="ot">-&gt;</span> reify <span class="fu">:@</span> lam (\e <span class="ot">-&gt;</span> lam (\k <span class="ot">-&gt;</span> 
            f <span class="fu">:@</span> lam (\a <span class="ot">-&gt;</span> reflect <span class="fu">:@</span> (_Inject <span class="fu">:@</span> a) <span class="fu">:@</span> (tailEnv <span class="fu">:@</span> e) <span class="fu">:@</span> k))))

example1 <span class="fu">=</span> evaluate <span class="fu">$</span> quote <span class="fu">:@</span> loop <span class="co">-- output looks like: Expr ((\a -&gt; a a) (\a -&gt; a a))</span>
example2 <span class="fu">=</span> evaluate <span class="fu">$</span> eval <span class="fu">:@</span> (quote <span class="fu">:@</span> loop) <span class="co">-- loops forever</span>
example3 <span class="fu">=</span> evaluate <span class="fu">$</span> callCC <span class="fu">:@</span> lam (\k <span class="ot">-&gt;</span> k <span class="fu">:@</span> one <span class="fu">:@</span> loop) <span class="co">-- escape before evaluating the loop</span>
example4 <span class="fu">=</span> evaluate <span class="fu">$</span> callCC <span class="fu">:@</span> lam (\k <span class="ot">-&gt;</span> lam (\_ <span class="ot">-&gt;</span> loop) <span class="fu">:@</span> (k <span class="fu">:@</span> one)) <span class="co">-- also escape before the loop</span></code></pre></div>]]></description>
    <pubDate>Tue, 17 Nov 2015 00:54:35 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/behavioral-reflection.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>

    </channel>
</rss>
