<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Hedonistic Learning</title>
        <link>https://derekelkins.github.io</link>
        <description><![CDATA[Mostly math, physics, and CS]]></description>
        <atom:link href="https://derekelkins.github.io/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Thu, 10 Nov 2016 07:48:33 UT</lastBuildDate>
        <item>
    <title>Constant-time Find First Set</title>
    <link>https://derekelkins.github.io/posts/find-first-set.html</link>
    <description><![CDATA[<h2 id="introduction">Introduction</h2>
<p>I’ve been watching the <a href="https://courses.csail.mit.edu/6.851/spring14/lectures/">Spring 2012 lectures for MIT 6.851 Advanced Data Structures</a> with Prof. Erik Demaine. In lecture 12, “Fusion Trees”, it mentions a constant time algorithm for <a href="https://en.wikipedia.org/wiki/Find_first_set">find first set bit</a> which finds the index of the first most significant 1 bit in a word. Assuming word operations are constant time, i.e. in the Word RAM model, the below algorithm takes 27 word operations (not counting copying). When I compiled it with GHC 8.0.1 -O2 the core of the algorithm was 44 straight-line instructions. The theoretically interesting thing is, other than changing the constants, the same algorithm works for any word size. This is demonstrated for <code>Word64</code>, <code>Word32</code>, and <code>Word16</code>.</p>
<h2 id="code">Code</h2>
<p>Below is the complete code. You can also download it <a href="./raw/FFS.hs">here</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE BangPatterns #-}</span>
<span class="kw">import </span><span class="dt">Data.Word</span>
<span class="kw">import </span><span class="dt">Data.Bits</span>

<span class="co">-- Returns 0-based bit index of most significant bit that is 1. Assumes input is non-zero.</span>
<span class="co">-- That is, 2^indexOfMostSignificant1 x &lt;= x &lt; 2^(indexOfMostSignificant1 x + 1)</span>
<span class="co">-- From Erik Demaine&#39;s presentation in Spring 2012 lectures of MIT 6.851, particularly &quot;Lecture 12: Fusion Trees&quot;.</span>
<span class="co">-- Takes 27 (source-level) straight-line word operations.</span>
<span class="ot">indexOfMostSignificant1 ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span>
indexOfMostSignificant1 w <span class="fu">=</span> idxMsbyte <span class="fu">.|.</span> idxMsbit
    <span class="kw">where</span> <span class="fu">!</span>wtbs <span class="fu">=</span> w <span class="fu">.&amp;.</span> <span class="bn">0x8080808080808080</span> <span class="co">-- top bits of each byte</span>
          <span class="fu">!</span>wbbs <span class="fu">=</span> w <span class="fu">.&amp;.</span> <span class="bn">0x7F7F7F7F7F7F7F7F</span> <span class="co">-- all but top bits of each byte producing 8 7-bit chunks</span>
          <span class="fu">!</span>pc <span class="fu">=</span> parallelCompare <span class="bn">0x8080808080808080</span> wbbs <span class="co">-- parallel compare of each 7-bit chunk to 0, top bit set in result if 7-bit chunk was not 0</span>
          <span class="fu">!</span>ne <span class="fu">=</span> wtbs <span class="fu">.|.</span> pc <span class="co">-- top bit of each byte set if the byte has any bits set in w</span>
          <span class="fu">!</span>summary <span class="fu">=</span> sketch ne <span class="ot">`unsafeShiftR`</span> <span class="dv">1</span> <span class="co">-- a summary of which bytes are non-zero as an 7-bit bitfield, i.e. top bits collected into bottom byte</span>
          <span class="fu">!</span>cmpp2 <span class="fu">=</span> parallelCompare <span class="bn">0xFFBF9F8F87838180</span> (<span class="bn">0x0101010101010101</span> <span class="fu">*</span> summary) <span class="co">-- parallel compare summary to powers of two, ignoring 2^0</span>
          <span class="fu">!</span>idxMsbyte <span class="fu">=</span> sumTopBits8 cmpp2 <span class="co">-- index of most significant non-zero byte * 8</span>
          <span class="fu">!</span>msbyte <span class="fu">=</span> ((w <span class="ot">`unsafeShiftR`</span> (fromIntegral idxMsbyte)) <span class="fu">.&amp;.</span> <span class="bn">0xFF</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">1</span> <span class="co">-- most significant 7-bits of most significant non-zero byte</span>
          <span class="fu">!</span>cmpp2&#39; <span class="fu">=</span> parallelCompare <span class="bn">0xFFBF9F8F87838180</span> (<span class="bn">0x0101010101010101</span> <span class="fu">*</span> msbyte) <span class="co">-- parallel compare msbyte to powers of two</span>
          <span class="fu">!</span>idxMsbit <span class="fu">=</span> sumTopBits cmpp2&#39; <span class="co">-- index of most significant non-zero bit in msbyte</span>

          sketch w <span class="fu">=</span> (w <span class="fu">*</span> <span class="bn">0x2040810204081</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">56</span>
          parallelCompare w1 w2 <span class="fu">=</span> complement (w1 <span class="fu">-</span> w2) <span class="fu">.&amp;.</span> <span class="bn">0x8080808080808080</span>
          sumTopBits w <span class="fu">=</span> ((w <span class="ot">`unsafeShiftR`</span> <span class="dv">7</span>) <span class="fu">*</span> <span class="bn">0x0101010101010101</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">56</span>
          sumTopBits8 w <span class="fu">=</span> ((w <span class="ot">`unsafeShiftR`</span> <span class="dv">7</span>) <span class="fu">*</span> <span class="bn">0x0808080808080808</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">56</span>

<span class="ot">indexOfMostSignificant1_w32 ::</span> <span class="dt">Word32</span> <span class="ot">-&gt;</span> <span class="dt">Word32</span>
indexOfMostSignificant1_w32 w <span class="fu">=</span> idxMsbyte <span class="fu">.|.</span> idxMsbit
    <span class="kw">where</span> <span class="fu">!</span>wtbs <span class="fu">=</span> w <span class="fu">.&amp;.</span> <span class="bn">0x80808080</span>
          <span class="fu">!</span>wbbs <span class="fu">=</span> w <span class="fu">.&amp;.</span> <span class="bn">0x7F7F7F7F</span>
          <span class="fu">!</span>pc <span class="fu">=</span> parallelCompare <span class="bn">0x80808080</span> wbbs
          <span class="fu">!</span>ne <span class="fu">=</span> wtbs <span class="fu">.|.</span> pc
          <span class="fu">!</span>summary <span class="fu">=</span> sketch ne <span class="ot">`unsafeShiftR`</span> <span class="dv">1</span>
          <span class="fu">!</span>cmpp2 <span class="fu">=</span> parallelCompare <span class="bn">0xFF838180</span> (<span class="bn">0x01010101</span> <span class="fu">*</span> summary)
          <span class="fu">!</span>idxMsbyte <span class="fu">=</span> sumTopBits8 cmpp2
          <span class="fu">!</span>msbyte <span class="fu">=</span> ((w <span class="ot">`unsafeShiftR`</span> (fromIntegral idxMsbyte)) <span class="fu">.&amp;.</span> <span class="bn">0xFF</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">1</span>
          <span class="fu">!</span>cmpp2&#39; <span class="fu">=</span> parallelCompare <span class="bn">0xFF838180</span> (<span class="bn">0x01010101</span> <span class="fu">*</span> msbyte)
          <span class="fu">!</span>idxMsbit <span class="fu">=</span> sumTopBits cmpp2&#39;

          sketch w <span class="fu">=</span> (w <span class="fu">*</span> <span class="bn">0x020409</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">24</span>
          parallelCompare w1 w2 <span class="fu">=</span> complement (w1 <span class="fu">-</span> w2) <span class="fu">.&amp;.</span> <span class="bn">0x80808080</span>
          sumTopBits w <span class="fu">=</span> ((w <span class="ot">`unsafeShiftR`</span> <span class="dv">7</span>) <span class="fu">*</span> <span class="bn">0x01010101</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">24</span>
          sumTopBits8 w <span class="fu">=</span> ((w <span class="ot">`unsafeShiftR`</span> <span class="dv">7</span>) <span class="fu">*</span> <span class="bn">0x08080808</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">24</span>

<span class="ot">indexOfMostSignificant1_w16 ::</span> <span class="dt">Word16</span> <span class="ot">-&gt;</span> <span class="dt">Word16</span>
indexOfMostSignificant1_w16 w <span class="fu">=</span> idxMsnibble <span class="fu">.|.</span> idxMsbit
    <span class="kw">where</span> <span class="fu">!</span>wtbs <span class="fu">=</span> w <span class="fu">.&amp;.</span> <span class="bn">0x8888</span>
          <span class="fu">!</span>wbbs <span class="fu">=</span> w <span class="fu">.&amp;.</span> <span class="bn">0x7777</span>
          <span class="fu">!</span>pc <span class="fu">=</span> parallelCompare <span class="bn">0x8888</span> wbbs
          <span class="fu">!</span>ne <span class="fu">=</span> wtbs <span class="fu">.|.</span> pc
          <span class="fu">!</span>summary <span class="fu">=</span> sketch ne <span class="ot">`unsafeShiftR`</span> <span class="dv">1</span>
          <span class="fu">!</span>cmpp2 <span class="fu">=</span> parallelCompare <span class="bn">0xFB98</span> (<span class="bn">0x1111</span> <span class="fu">*</span> summary)
          <span class="fu">!</span>idxMsnibble <span class="fu">=</span> sumTopBits4 cmpp2
          <span class="fu">!</span>msnibble <span class="fu">=</span> ((w <span class="ot">`unsafeShiftR`</span> (fromIntegral idxMsnibble)) <span class="fu">.&amp;.</span> <span class="bn">0xF</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">1</span>
          <span class="fu">!</span>cmpp2&#39; <span class="fu">=</span> parallelCompare <span class="bn">0xFB98</span> (<span class="bn">0x1111</span> <span class="fu">*</span> msnibble)
          <span class="fu">!</span>idxMsbit <span class="fu">=</span> sumTopBits cmpp2&#39;

          sketch w <span class="fu">=</span> (w <span class="fu">*</span> <span class="bn">0x249</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">12</span>
          parallelCompare w1 w2 <span class="fu">=</span> complement (w1 <span class="fu">-</span> w2) <span class="fu">.&amp;.</span> <span class="bn">0x8888</span>
          sumTopBits w <span class="fu">=</span> ((w <span class="ot">`unsafeShiftR`</span> <span class="dv">3</span>) <span class="fu">*</span> <span class="bn">0x1111</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">12</span>
          sumTopBits4 w <span class="fu">=</span> ((w <span class="ot">`unsafeShiftR`</span> <span class="dv">3</span>) <span class="fu">*</span> <span class="bn">0x4444</span>) <span class="ot">`unsafeShiftR`</span> <span class="dv">12</span></code></pre></div>]]></description>
    <pubDate>Thu, 10 Nov 2016 07:48:33 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/find-first-set.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>
<item>
    <title>Quotient Types for Programmers</title>
    <link>https://derekelkins.github.io/posts/quotient-types-for-programmers.html</link>
    <description><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Programmers in typed languages with higher order functions and algebraic data types are already comfortable with most of the basic constructions of set/type theory. In categorical terms, those programmers are familiar with finite products and coproducts and (monoidal/cartesian) closed structure. The main omissions are subset types (equalizers/pullbacks) and quotient types (coequalizers/pushouts) which would round out limits and colimits. Not having a good grasp on either of these constructions dramatically shrinks the world of mathematics that is understandable, but while subset types are fairly straightforward, quotient types are quite a bit less intuitive.</p>
<h2 id="subset-types">Subset Types</h2>
<p>In my opinion, most programmers can more or less immediately understand the notion of a subset type at an intuitive level.<br />
A <strong>subset type</strong> is just a type combined with a predicate on that type that specifies which values of the type we want. For example, we may have something like <code>{ n:Nat | n /= 0 }</code> meaning the type of naturals not equal to #0#. We may use this in the type of the division function for the denominator. Consuming a value of a subset type is easy, a natural not equal to #0# is still just a natural, and we can treat it as such. The difficult part is producing a value of a subset type. To do this, we must, of course, produce a value of the underlying type — <code>Nat</code> in our example — but then we must further convince the type checker that the predicate holds (e.g. that the value does not equal #0#). Most languages provide no mechanism to prove potentially arbitrary facts about code, and this is why they do not support subset types. Dependently typed languages do provide such mechanisms and thus either have or can encode subset types. Outside of dependently typed languages the typical solution is to use an abstract data type and use a runtime check when values of that abstract data type are created.</p>
<h2 id="quotient-types">Quotient Types</h2>
<p>The dual of subset types are quotient types. My impression is that this construction is the most difficult basic construction for people to understand. Further, programmers aren’t much better off, because they have little to which to connect the idea. Before I give a definition, I want to provide the example with which most people are familiar: modular (or clock) arithmetic. A typical way this is first presented is as a system where the numbers “wrap-around”. For example, in arithmetic mod #3#, we count #0#, #1#, #2#, and then wrap back around to #0#. Programmers are well aware that it’s not necessary to guarantee that an input to addition, subtraction, or multiplication mod #3# is either #0#, #1#, or #2#. Instead, the operation can be done and the <code>mod</code> function can be applied at the end. This will give the same result as applying the <code>mod</code> function to each argument at the beginning. For example, #4+7 = 11# and #11 mod 3 = 2#, and #4 mod 3 = 1# and #7 mod 3 = 1# and #1+1 = 2 = 11 mod 3#.</p>
<p>For mathematicians, the type of integers mod #n# is represented by the quotient type #ZZ//n ZZ#. The idea is that the values of #ZZ // n ZZ# are integers except that we agree that any two integers #a# and #b# are treated as equal if #a - b = kn# for some integer #k#. For #ZZ // 3 ZZ#, #… -6 = -3 = 0 = 3 = 6 = …# and #… = -5 = -2 = 1 = 4 = 7 = …# and #… = -4 = -1 = 2 = 5 = 8 = …#.</p>
<h2 id="equivalence-relations">Equivalence Relations</h2>
<p>To start to formalize this, we need the notion of an equivalence relation. An <strong>equivalence relation</strong> is a binary relation <code class="asciimath">#(~~)#</code> which is <strong>reflexive</strong> (#x ~~ x# for all #x#), <strong>symmetric</strong> (if <code class="asciimath">#x ~~ y#</code> then <code class="asciimath">#y ~~ x#</code>), and <strong>transitive</strong> (if <code class="asciimath">#x ~~ y#</code> and <code class="asciimath">#y ~~ z#</code> then <code class="asciimath">#x ~~ z#</code>). We can check that “#a ~~ b# iff there exists an integer #k# such that #a-b = kn#” defines an equivalence relation on the integers for any given #n#. For reflexivity we have #a - a = 0n#. For symmetry we have if #a - b = kn# then #b - a = -kn#. Finally, for transitivity we have if #a - b = k_1 n# and #b - c = k_2 n# then #a - c = (k_1 + k_2)n# which we get by adding the preceding two equations.</p>
<p>Any relation can be extended to an equivalence relation. This is called the reflexive-, symmetric-, transitive-closure of the relation. For an arbitrary binary relation #R# we can define the equivalence relation #(~~_R)# via “#a ~~_R b# iff #a = b# or #R(a, b)# or #b ~~_R a# or #a ~~_R c and c ~~_R b# for some #c#“. To be precise, #~~_R# is the smallest relation satisfying those constraints. In Datalog syntax, this looks like:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">eq_r(<span class="dt">A</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">.</span>
eq_r(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>) <span class="kw">:-</span> r(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>)<span class="kw">.</span>
eq_r(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>) <span class="kw">:-</span> eq_r(<span class="dt">B</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">.</span>
eq_r(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>) <span class="kw">:-</span> eq_r(<span class="dt">A</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> eq_r(<span class="dt">C</span><span class="kw">,</span> <span class="dt">B</span>)<span class="kw">.</span></code></pre></div>
<h2 id="quotient-types-the-type-theory-view">Quotient Types: the Type Theory view</h2>
<p>If #T# is a type, and <code class="asciimath">#(~~)#</code> is an equivalence relation, we use #T // ~~# as the notation for the <strong>quotient type</strong>, which we read as “#T# quotiented by the equivalence relation <code class="asciimath">#(~~)#</code>”. We call #T# the <strong>underlying type</strong> of the quotient type. We then say #a = b# at type #T // ~~# iff #a ~~ b#. Dual to subset types, to produce a value of a quotient type is easy. Any value of the underlying type is a value of the quotient type. (In type theory, this produces the perhaps surprising result that #ZZ# is a <em>subtype</em> of #ZZ // n ZZ#.) As expected, consuming a value of a quotient type is more complicated. To explain this, we need to explain what a function #f : T // ~~ -&gt; X# is for some type #X#. A function #f : T // ~~ -&gt; X# is a function #g : T -&gt; X# which satisfies #g(a) = g(b)# for all #a# and #b# such that #a ~~ b#. We call #f# (or #g#, they are often conflated) <strong>well-defined</strong> if #g# satisfies this condition. In other words, any well-defined function that consumes a quotient type isn’t allowed to produce an output that distinguishes between equivalent inputs. A better way to understand this is that quotient types allow us to change what the notion of equality is for a type. From this perspective, a function being well-defined just means that it is a function. Taking equal inputs to equal outputs is one of the defining characteristics of a function.</p>
<p>Sometimes we can finesse needing to check the side condition. Any function #h : T -&gt; B# gives rise to an equivalence relation on #T# via #a ~~ b# iff #h(a) = h(b)#. In this case, any function #g : B -&gt; X# gives rise to a function #f : T // ~~ -&gt; X# via #f = g @ h#. In particular, when #B = T# we are guaranteed to have a suitable #g# for any function #f : T // ~~ -&gt; X#. In this case, we can implement quotient types in a manner quite similar subset types, namely we make an abstract type and we normalize with the #h# function as we either produce or consume values of the abstract type. A common example of this is rational numbers. We can reduce a rational number to lowest terms either when it’s produced or when the numerator or denominator get accessed, so that we don’t accidentally write functions which distinguish between #1/2# and #2/4#. For modular arithmetic, the mod by #n# function is a suitable #h#.</p>
<h2 id="quotient-types-the-set-theory-view">Quotient Types: the Set Theory view</h2>
<p>In set theory such an #h# function can always be made by mapping the elements of #T# to the equivalence classes that contain them, i.e. #a# gets mapped to #{b | a ~~ b}# which is called the <strong>equivalence class</strong> of #a#. In fact, in set theory, #T // ~~# is usually defined to <em>be</em> the set of equivalence classes of <code class="asciimath">#(~~)#</code>. So, for the example of #ZZ // 3 ZZ#, in set theory, it is a set of exactly three elements: the elements are #{ 3n+k | n in ZZ}# for #k = 0, 1, 2#. Equivalence classes are also called <strong>partitions</strong> and are said to partition the underlying set. Elements of these equivalence classes are called <strong>representatives</strong> of the equivalence class. Often a notation like #[a]# is used for the equivalence class of #a#.</p>
<h2 id="more-examples">More Examples</h2>
<p>Here is a quick run-through of some significant applications of quotient types. I’ll give the underlying type and the equivalence relation and what the quotient type produces. I’ll leave it as an exercise to verify that the equivalence relations really are equivalence relations, i.e. reflexive, symmetric, and transitive. I’ll start with more basic examples. You should work through them to be sure you understand how they work.</p>
<h3 id="integers">Integers</h3>
<p>Integers can be presented as pairs of naturals #(n, m)# with the idea being that the pair represents “#n - m#”. Of course, #1 - 2# should be the same as #2 - 3#. This is expressed as #(n_1, m_1) ~~ (n_2, m_2)# iff #n_1 + m_2 = n_2 + m_1#. Note how this definition only relies on operations on natural numbers. You can explore how to define addition, subtraction, multiplication, and other operations on this representation in a well-defined manner.</p>
<h3 id="rationals">Rationals</h3>
<p>Rationals can be presented very similarly to integers, only with multiplication instead of addition. We also have pairs #(n, d)#, usually written #n/d#, in this case of an integer #n# and a non-zero natural #d#. The equivalence relation is #(n_1, d_1) ~~ (n_2, d_2)# iff #n_1 d_2 = n_2 d_1#.</p>
<h3 id="topological-circles">(Topological) Circles</h3>
<p>We can extend the integers mod #n# to the continuous case. Consider the real numbers with the equivalence relation #r ~~ s# iff #r - s = k# for some integer #k#. You could call this the reals mod #1#. Topologically, this is a circle. If you walk along it far enough, you end up back at a point equivalent to where you started. Occasionally this is written as #RR//ZZ#.</p>
<h3 id="torii">Torii</h3>
<p>Doing the previous example in 2D gives a torus. Specifically, we have pairs of real numbers and the equivalence relation #(x_1, y_1) ~~ (x_2, y_2)# iff #x_1 - x_2 = k# and #y_1 - y_2 = l# for some integers #k# and #l#. Quite a bit of topology relies on similar constructions as will be expanded upon on the section on gluing.</p>
<h3 id="unordered-pairs">Unordered pairs</h3>
<p>Here’s an example that’s a bit closer to programming. Consider the following equivalence relation on arbitrary pairs: #(a_1, b_1) ~~ (a_2, b_2)# iff #a_1 = a_2 and b_1 = b_2# or #a_1 = b_2 and b_1 = a_2#. This just says that a pair is equivalent to either itself, or a swapped version of itself. It’s interesting to consider what a well-defined function is on this type.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<h3 id="gluing-pushouts">Gluing / Pushouts</h3>
<p>Returning to topology and doing a bit more involved construction, we arrive at gluing or pushouts. In topology, we often want to take two topological spaces and glue them together in some specified way. For example, we may want to take two discs and glue their boundaries together. This gives a sphere. We can combine two spaces into one with the disjoint sum (or coproduct, i.e. Haskell’s <code>Either</code> type.) This produces a space that contains both the input spaces, but they don’t interact in any way. You can visualize them as sitting next to each other but not touching. We now want to say that certain pairs of points, one from each of the spaces, are really the same point. That is, we want to quotient by an equivalence relation that would identify those points. We need some mechanism to specify which points we want to identify. One way to accomplish this is to have a pair of functions, #f : C -&gt; A# and #g : C -&gt; B#, where #A# and #B# are the space we want to glue together. We can then define a relation #R# on the disjoint sum via #R(a, b)# iff there’s a #c : C# such that <code class="asciimath">#a = tt &quot;inl&quot;(f(c)) and b = tt &quot;inr&quot;(g(c))#</code>. This is not an equivalence relation, but we can extend it to one. The quotient we get is then the gluing of #A# and #B# specified by #C# (or really by #f# and #g#). For our example of two discs, #f# and #g# are the same function, namely the inclusion of the boundary of the disc into the disc. We can also glue a space to itself. Just drop the disjoint sum part. Indeed, the circle and torus are examples.</p>
<h3 id="polynomial-ring-ideals">Polynomial ring ideals</h3>
<p>We write #RR[X]# for the type of polynomials with one indeterminate #X# with real coefficients. For two indeterminates, we write #RR[X, Y]#. Values of these types are just polynomials such as #X^2 + 1# or #X^2 + Y^2#. We can consider quotienting these types by equivalence relations generated from identifications like #X^2 + 1 ~~ 0# or #X^2 - Y ~~ 0#, but we want more than just the reflexive-, symmetric-, transitive-closure. We want this equivalence relation to also respect the operations we have on polynomials, in particular, addition and multiplication. More precisely, we want if #a ~~ b# and #c ~~ d# then #ac ~~ bd# and similarly for addition. An equivalence relation that respects all operations is called a <strong>congruence</strong>. The standard notation for the quotient of #RR[X, Y]# by a congruence generated by both of the previous identifications is #RR[X, Y]//(X^2 + 1, X^2 - Y)#. Now if #X^2 + 1 = 0# in #RR[X, Y]//(X^2 + 1, X^2 - Y)#, then for <em>any</em> polynomial #P(X, Y)#, we have #P(X, Y)(X^2 + 1) = 0# because #0# times anything is #0#. Similarly, for any polynomial #Q(X, Y)#, #Q(X, Y)(X^2 - Y) = 0#. Of course, #0 + 0 = 0#, so it must be the case that #P(X, Y)(X^2 + 1) + Q(X, Y)(X^2 - Y) = 0# for all polynomials #P# and #Q#. In fact, we can show that all elements in the equivalence class of #0# are of this form. You’ve now motivated the concrete definition of a ring ideal and given it’s significance. An <strong>ideal</strong> is an equivalence class of #0# with respect to some congruence. Let’s work out what #RR[X, Y]//(X^2 + 1, X^2 - Y)# looks like concretely. First, since #X^2 - Y = 0#, we have #Y = X^2# and so we see that values of #RR[X, Y]//(X^2 + 1, X^2 - Y)# will be polynomials in only one indeterminate because we can replace all #Y#s with #X^2#s. Since #X^2 = -1#, we can see that all those polynomials will be linear (i.e. of degree 1) because we can just keep replacing #X^2#s with #-1#s, i.e. #X^(n+2) = X^n X^2 = -X^n#. The end result is that an arbitrary polynomial in #RR[X, Y]//(X^2 + 1, X^2 - Y)# looks like #a + bX# for real numbers #a# and #b# and we have #X^2 = -1#. In other words, #RR[X, Y]//(X^2 + 1, X^2 - Y)# is isomorphic to the complex numbers, #CC#.</p>
<p>As a reasonably simple exercise, given a polynomial #P(X) : RR[X]#, what does it get mapped to when embedded into #RR[X]//(X - 3)#, i.e. what is #[P(X)] : RR[X]//(X - 3)#?<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<h3 id="free-algebras-modulo-an-equational-theory">Free algebras modulo an equational theory</h3>
<p>Moving much closer to programming, we have a rather broad and important example that a mathematician might describe as free algebras modulo an equational theory. This example covers several of the preceding examples. In programmer-speak, a free algebra is just a type of abstract syntax trees for some language. We’ll call a specific absract syntax tree a <strong>term</strong>. An equational theory is just a collection of pairs of terms with the idea being that we’d like these terms to be considered equal. To be a bit more precise, we will actually allow terms to contain (meta)variables. An example equation for an expression language might be <code>Add(</code>#x#<code>,</code>#x#<code>) = Mul(2,</code>#x#<code>)</code>. We call a term with no variables a <strong>ground term</strong>. We say a ground term <strong>matches</strong> another term if there is a consistent substitution for the variables that makes the latter term syntactically equal to the ground term. E.g. <code>Add(3, 3)</code> matches <code>Add(</code>#x#<code>,</code>#x#<code>)</code> via the substitution #x |-&gt;#<code>3</code>. Now, the equations of our equational theory gives rise to a relation on ground terms #R(t_1, t_2)# iff there exists an equation #l = r# such that #t_1# matches #l# and #t_2# matches #r#. This relation can be extended to an equivalence relation on ground terms, and we can then quotient by that equivalence relation.</p>
<p>Let’s consider a worked example. We can consider the theory of monoids. We have two operations (types of AST nodes): <code>Mul(</code>#x#<code>,</code>#y#<code>)</code> and <code>1</code>. We have the following three equations: <code>Mul(1,</code>#x#<code>) =</code>#x#, <code>Mul(</code>#x#<code>, 1) =</code>#x#, and <code>Mul(Mul(</code>#x#<code>,</code>#y#<code>),</code>#z#<code>) = Mul(</code>#x#<code>, Mul(</code>#y#<code>,</code>#z#<code>))</code>. We additionally have a bunch of constants subject to no equations. In this case, it turns out we can define a normalization function, what I called #h# far above, and that the quotient type is isomorphic to lists of constants. Now, we can extend this theory to the theory of groups by adding a new operation, <code>Inv(</code>#x#<code>)</code>, and new equations: <code>Inv(Inv(</code>#x#<code>)) =</code>#x#, <code>Inv(Mul(</code>#x#<code>,</code>#y#<code>)) = Mul(Inv(</code>#y#<code>), Inv(</code>#x#<code>))</code>, and <code>Mul(Inv(</code>#x#<code>),</code>#x#<code>) = 1</code>. If we ignore the last of these equations, you can show that we can normalize to a form that is isomorphic to a list of a disjoint sum of the constants, i.e. <code>[Either Const Const]</code> in Haskell if <code>Const</code> were the type of the constant terms. Quotienting this type by the equivalence relation extended with that final equality, corresponds to adding the rule that a <code>Left c</code> cancels out <code>Right c</code> in the list whenever they are adjacent.</p>
<p>This overall example is a fairly profound one. Almost all of abstract algebra can be viewed as an instance of this or a closely related variation. When you hear about things defined in terms of “generators and relators”, it is an example of this sort. Indeed, those “relators” are used to define a relation that will be extended to an equivalence relation. Being defined in this way is arguably what it <em>means</em> for something to be “algebraic”.</p>
<h2 id="postscript">Postscript</h2>
<p>The <a href="http://www.nuprl.org/book/Introduction_Type_Theory.html">Introduction to Type Theory</a> section of the NuPRL book provides a more comprehensive and somewhat more formal presentation of these and related concepts. While the quotient <em>type</em> view of quotients is conceptually different from the standard set theoretic presentation, it is much more amenable to computation as the #ZZ // n ZZ# example begins to illustrate.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>It’s a commutative function.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>It gets mapped to it’s value at #3#, i.e. #P(3)#.<a href="#fnref2">↩</a></p></li>
</ol>
</div>]]></description>
    <pubDate>Fri, 23 Sep 2016 05:21:35 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/quotient-types-for-programmers.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>
<item>
    <title>Constructivist Motto</title>
    <link>https://derekelkins.github.io/posts/constructivist-motto.html</link>
    <description><![CDATA[<blockquote>
<p>I don’t believe classical logic is false; I just believe that it is not true.</p>
</blockquote>]]></description>
    <pubDate>Sat, 07 May 2016 18:12:29 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/constructivist-motto.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>
<item>
    <title>The Mistake Everyone Makes with KnockoutJS</title>
    <link>https://derekelkins.github.io/posts/the-mistake-everyone-makes-with-knockoutjs.html</link>
    <description><![CDATA[<h3 id="introduction">Introduction</h3>
<p><a href="http://knockoutjs.com">Knockout</a> is a nice JavaScript library for making values that automatically update when any of their “dependencies” update. Those dependencies can form an arbitrary directed acyclic graph. Many people seem to think of it as “yet another” templating library, but the core idea which is useful far beyond “templating” is the notion of observable values. One nice aspect is that it is a library and not a framework so you can use it as little or as much as you want and you can integrate it with other libraries and frameworks.</p>
<p>At any rate, this article is more geared toward those who have already decided on using Knockout or a library (in any language) offering similar capabilities. I strongly suspect the issues and solutions I’ll discuss apply to all similar sorts of libraries. While I’ll focus on one particular example, the ideas behind it apply generally. This example, admittedly, is one that almost anyone will implement, and in my experience will do it incorrectly the first time and won’t realize the problem until later.</p>
<h3 id="the-problem">The Problem</h3>
<p>When doing any front-end work, before long there will be a requirement to support “multi-select” of something. Of course, you want the standard select/deselect all functionality and for it to work correctly, and of course you want to do something with the items you’ve selected. Here’s a very simple example:</p>
<div id="#badExample">
Number selected: <span data-bind="text: $data.numberSelected()"></span>
<table>
<tr>
<th>
<input type="checkbox" data-bind="checked: $data.allSelected"/>
</th>
<th>
Item
</th>
</tr>
<!-- ko foreach: { data: $data.items(), as: '$item' } -->
<tr>
<td>
<input type="checkbox" data-bind="checked: $data.selected"/>
</td>
<td data-bind="text: 'Item number: '+$data.body">
</td>
</tr>
<!-- /ko -->
<tr>
<td>
<button data-bind="click: function() { $data.add(); }">
Add
</button>
</td>
</tr>
</table>
</div>
<p>Here, the number selected is an overly simple example of using the selected items. More realistically, the selected items will trigger other items to show up and/or trigger AJAX requests to update the data or populate other data. The HTML for this example is completely straightforward.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;#badExample&quot;</span><span class="kw">&gt;</span>
    Number selected: <span class="kw">&lt;span</span><span class="ot"> data-bind=</span><span class="st">&quot;text: $data.numberSelected()&quot;</span><span class="kw">&gt;&lt;/span&gt;</span>
    <span class="kw">&lt;table&gt;</span>
        <span class="kw">&lt;tr&gt;&lt;th&gt;&lt;input</span><span class="ot"> type=</span><span class="st">&quot;checkbox&quot;</span><span class="ot"> data-bind=</span><span class="st">&quot;checked: $data.allSelected&quot;</span><span class="kw">/&gt;&lt;/th&gt;&lt;th&gt;</span>Item<span class="kw">&lt;/th&gt;&lt;/tr&gt;</span>
        <span class="co">&lt;!-- ko foreach: { data: $data.items(), as: &#39;$item&#39; } --&gt;</span>
        <span class="kw">&lt;tr&gt;&lt;td&gt;&lt;input</span><span class="ot"> type=</span><span class="st">&quot;checkbox&quot;</span><span class="ot"> data-bind=</span><span class="st">&quot;checked: $data.selected&quot;</span><span class="kw">/&gt;&lt;/td&gt;&lt;td</span><span class="ot"> data-bind=</span><span class="st">&quot;text: &#39;Item number: &#39;+$data.body&quot;</span><span class="kw">&gt;&lt;/td&gt;&lt;/tr&gt;</span>
        <span class="co">&lt;!-- /ko --&gt;</span>
        <span class="kw">&lt;tr&gt;&lt;td&gt;&lt;button</span><span class="ot"> data-bind=</span><span class="st">&quot;click: function() { $data.add(); }&quot;</span><span class="kw">&gt;</span>Add<span class="kw">&lt;/button&gt;&lt;/td&gt;&lt;/tr&gt;</span>
    <span class="kw">&lt;/table&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p>The way nearly everyone (including me) first thinks to implement this is by adding a <code>selected</code> observable to each item and then having <code>allSelected</code> depend on all of the <code>selected</code> observables. Since we also want to write to <code>allSelected</code> to change the state of the <code>selected</code> observables we use a <a href="http://knockoutjs.com/documentation/computed-writable.html">writable computed observable</a>. This computed observable will loop through all the items and check to see if they are all set to determine it’s state. When it is updated, it will loop through all the <code>selected</code> observables and set them to the appropriate state. Here’s the full code listing.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> badViewModel <span class="op">=</span> <span class="op">{</span>
    <span class="dt">counter</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span>
    <span class="dt">items</span><span class="op">:</span> <span class="va">ko</span>.<span class="at">observableArray</span>()
<span class="op">};</span>

<span class="va">badViewModel</span>.<span class="at">allSelected</span> <span class="op">=</span> <span class="va">ko</span>.<span class="at">computed</span>(<span class="op">{</span>
    <span class="dt">read</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="kw">var</span> items <span class="op">=</span> <span class="va">badViewModel</span>.<span class="at">items</span>()<span class="op">;</span>
        <span class="kw">var</span> allSelected <span class="op">=</span> <span class="kw">true</span><span class="op">;</span>
        <span class="cf">for</span>(<span class="kw">var</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">items</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span> <span class="co">// Need to make sure we depend on each item, so don&#39;t break out of loop early</span>
            allSelected <span class="op">=</span> allSelected <span class="op">&amp;&amp;</span> items[i].<span class="at">selected</span>()<span class="op">;</span>
        <span class="op">}</span>
        <span class="cf">return</span> allSelected<span class="op">;</span>
    <span class="op">},</span>
    <span class="dt">write</span><span class="op">:</span> <span class="kw">function</span>(newValue) <span class="op">{</span>
        <span class="kw">var</span> items <span class="op">=</span> <span class="va">badViewModel</span>.<span class="at">items</span>()<span class="op">;</span>
        <span class="cf">for</span>(<span class="kw">var</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">items</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
            items[i].<span class="at">selected</span>(newValue)<span class="op">;</span>
        <span class="op">}</span>
    <span class="op">}</span>
<span class="op">}</span>)<span class="op">;</span>

<span class="va">badViewModel</span>.<span class="at">numberSelected</span> <span class="op">=</span> <span class="va">ko</span>.<span class="at">computed</span>(<span class="kw">function</span>() <span class="op">{</span>
    <span class="kw">var</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>
    <span class="kw">var</span> items <span class="op">=</span> <span class="va">badViewModel</span>.<span class="at">items</span>()<span class="op">;</span>
    <span class="cf">for</span>(<span class="kw">var</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">items</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
        <span class="cf">if</span>(items[i].<span class="at">selected</span>()) count<span class="op">++;</span>
    <span class="op">}</span>
    <span class="cf">return</span> count<span class="op">;</span>
<span class="op">}</span>)<span class="op">;</span>

<span class="va">badViewModel</span>.<span class="at">add</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
    <span class="va">badViewModel</span>.<span class="va">items</span>.<span class="at">push</span>(<span class="op">{</span>
        <span class="dt">body</span><span class="op">:</span> <span class="va">badViewModel</span>.<span class="at">counter</span><span class="op">++,</span>
        <span class="dt">selected</span><span class="op">:</span> <span class="va">ko</span>.<span class="at">observable</span>(<span class="kw">false</span>)
    <span class="op">}</span>)<span class="op">;</span>
<span class="op">};</span>

<span class="va">ko</span>.<span class="at">applyBindings</span>(badViewModel<span class="op">,</span> <span class="va">document</span>.<span class="at">getElementById</span>(<span class="st">&#39;#badExample&#39;</span>))<span class="op">;</span></code></pre></div>
<p>This should be relatively straightforward, and it works, so what’s the problem? The problem can be seen in <code>numberSelected</code> (and it also comes up with <code>allSelected</code> which I’ll get to momentarily). <code>numberSelected</code> depends on <em>each</em> <code>selected</code> observable and so it will be fired <em>each</em> time <em>each</em> one updates. That means if you have 100 items, and you use the select all checkbox, <code>numberSelected</code> will be called 100 times. For this example, that doesn’t really matter. For a more realistic example than <code>numberSelected</code>, this may mean rendering one, then two, then three, … then 100 HTML fragments or making 100 AJAX requests. In fact, this same behavior is present in <code>allSelected</code>. When it is written, as it’s writing to the <code>selected</code> observables, it is also triggering <em>itself</em>.</p>
<p>So the problem is updating <code>allSelected</code> or <code>numberSelected</code> can’t be done all at once, or to use database terminology, it can’t be updated atomically. One possible solution in newer versions of Knockout is to use <code>deferredUpdates</code> or, what I did back in the much earlier versions of Knockout, abuse the rate limiting features. The problem with this solution is that it makes updates asynchronous. If you’ve written your code to not care whether it was called synchronously or asynchronously, then this will work fine. If you haven’t, doing this throws you into a world of shared state concurrency and race conditions. In this case, this solution is far worse than the disease.</p>
<h3 id="the-solution">The Solution</h3>
<p>So, what’s the alternative? We want to update all selected items atomically; we can atomically update a single observable; so we’ll put all selected items into a single observable. Now an item determines if it is selected by checking whether it is in the collection of selected items. More abstractly, we make our observables more coarse-grained, and we have a bunch of small computed observables depend on a large observable instead of a large computed observable depending on a bunch of small observables as we had in the previous code. Here’s an example using the exact same HTML and presenting the same overt behavior.</p>
<div id="#goodExample">
Number selected: <span data-bind="text: $data.numberSelected()"></span>
<table>
<tr>
<th>
<input type="checkbox" data-bind="checked: $data.allSelected"/>
</th>
<th>
Item
</th>
</tr>
<!-- ko foreach: { data: $data.items(), as: '$item' } -->
<tr>
<td>
<input type="checkbox" data-bind="checked: $data.selected"/>
</td>
<td data-bind="text: 'Item number: '+$data.body">
</td>
</tr>
<!-- /ko -->
<tr>
<td>
<button data-bind="click: function() { $data.add(); }">
Add
</button>
</td>
</tr>
</table>
</div>
<p>And here’s the code behind this second example:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> goodViewModel <span class="op">=</span> <span class="op">{</span>
    <span class="dt">counter</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span>
    <span class="dt">selectedItems</span><span class="op">:</span> <span class="va">ko</span>.<span class="at">observableArray</span>()<span class="op">,</span>
    <span class="dt">items</span><span class="op">:</span> <span class="va">ko</span>.<span class="at">observableArray</span>()
<span class="op">};</span>

<span class="va">goodViewModel</span>.<span class="at">allSelected</span> <span class="op">=</span> <span class="va">ko</span>.<span class="at">computed</span>(<span class="op">{</span>
    <span class="dt">read</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="cf">return</span> <span class="va">goodViewModel</span>.<span class="at">items</span>().<span class="at">length</span> <span class="op">===</span> <span class="va">goodViewModel</span>.<span class="at">selectedItems</span>().<span class="at">length</span><span class="op">;</span>
    <span class="op">},</span>
    <span class="dt">write</span><span class="op">:</span> <span class="kw">function</span>(newValue) <span class="op">{</span>
        <span class="cf">if</span>(newValue) <span class="op">{</span>
            <span class="va">goodViewModel</span>.<span class="at">selectedItems</span>(<span class="va">goodViewModel</span>.<span class="at">items</span>().<span class="at">slice</span>(<span class="dv">0</span>))<span class="op">;</span> <span class="co">// Need a copy!</span>
        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
            <span class="va">goodViewModel</span>.<span class="va">selectedItems</span>.<span class="at">removeAll</span>()<span class="op">;</span>
        <span class="op">}</span>
    <span class="op">}</span>
<span class="op">}</span>)<span class="op">;</span>

<span class="va">goodViewModel</span>.<span class="at">numberSelected</span> <span class="op">=</span> <span class="va">ko</span>.<span class="at">computed</span>(<span class="kw">function</span>() <span class="op">{</span>
    <span class="cf">return</span> <span class="va">goodViewModel</span>.<span class="at">selectedItems</span>().<span class="at">length</span><span class="op">;</span>
<span class="op">}</span>)<span class="op">;</span>

<span class="va">goodViewModel</span>.<span class="at">add</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
    <span class="kw">var</span> item <span class="op">=</span> <span class="op">{</span> <span class="dt">body</span><span class="op">:</span> <span class="va">goodViewModel</span>.<span class="at">counter</span><span class="op">++</span> <span class="op">}</span>
    <span class="va">item</span>.<span class="at">selected</span> <span class="op">=</span> <span class="va">ko</span>.<span class="at">computed</span>(<span class="op">{</span>
        <span class="dt">read</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
            <span class="cf">return</span> <span class="va">goodViewModel</span>.<span class="va">selectedItems</span>.<span class="at">indexOf</span>(item) <span class="op">&gt;</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span>
        <span class="op">},</span>
        <span class="dt">write</span><span class="op">:</span> <span class="kw">function</span>(newValue) <span class="op">{</span>
            <span class="cf">if</span>(newValue) <span class="op">{</span>
                <span class="va">goodViewModel</span>.<span class="va">selectedItems</span>.<span class="at">push</span>(item)<span class="op">;</span>
            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
                <span class="va">goodViewModel</span>.<span class="va">selectedItems</span>.<span class="at">remove</span>(item)<span class="op">;</span>
            <span class="op">}</span>
        <span class="op">}</span>
    <span class="op">}</span>)<span class="op">;</span>
    <span class="va">goodViewModel</span>.<span class="va">items</span>.<span class="at">push</span>(item)<span class="op">;</span>
<span class="op">};</span>

<span class="va">ko</span>.<span class="at">applyBindings</span>(goodViewModel<span class="op">,</span> <span class="va">document</span>.<span class="at">getElementById</span>(<span class="st">&#39;#goodExample&#39;</span>))<span class="op">;</span></code></pre></div>
<p>One thing to note is that setting <code>allSelected</code> and <code>numberSelected</code> are now both simple operations. A write to an observable on triggers a constant number of writes to other observables. In fact, there are only two (non-computed) observables. On the other hand, <em>reading</em> the <code>selected</code> observable is more expensive. Toggling all items has quadratic complexity. In fact, it had quadratic complexity before due to the feedback. However, unlike the previous code, this <em>also</em> has quadratic complexity when any <em>individual</em> item is toggled. Unlike the previous code, though, this is simply due to a poor choice of data structure. Equipping each item with an “ID” field and using an object as a hash map would reduce the complexity to linear. In practice, for this sort of scenario, it tends not to make a big difference. Also, Knockout won’t trigger dependents if the value doesn’t change, so there’s no risk of the extra work propagating into still more extra work. Nevertheless, while I endorse this solution for this particular problem, in general making <em>finer</em> grained observables can help limit the scope of changes so unnecessary work isn’t done.</p>
<p>Still, the real concern and benefit of this latter approach isn’t the asymptotic complexity of the operations, but the <em>atomicity</em> of the operations. In the second solution, every update is atomic. There are no intermediate states on the way to a final state. This means that dependents, represented by <code>numberSelected</code> but which are realistically much more complicated, don’t get triggered excessively and don’t need to “compensate” for unintended intermediate values.</p>
<h3 id="epilogue">Epilogue</h3>
<p>We could take the coarse-graining to its logical conclusion and have the view model for an application be a single observable holding an object representing the entire view model (and containing no observables of its own). Taking this approach actually does have a lot of benefits, albeit there is little reason to use Knockout at that point. Instead this starts to lead to things like Facebook’s <a href="https://facebook.github.io/flux/">Flux</a> pattern and the pattern perhaps most clearly articulated by <a href="http://cycle.js.org/">Cycle JS</a>.</p>
<script lang="text/javascript" src="http://ajax.aspnetcdn.com/ajax/knockout/knockout-3.3.0.js"></script>
<script lang="text/javascript">
// Bad View Model

var badViewModel = {
    counter: 0,
    items: ko.observableArray()
};

badViewModel.allSelected = ko.computed({
    read: function() {
        var items = badViewModel.items();
        var allSelected = true;
        for(var i = 0; i < items.length; i++) { // Need to make sure we depend on each item, so don't break out of loop early
            allSelected = allSelected && items[i].selected();
        }
        return allSelected;
    },
    write: function(newValue) {
        var items = badViewModel.items();
        for(var i = 0; i < items.length; i++) {
            items[i].selected(newValue);
        }
    }
});

badViewModel.numberSelected = ko.computed(function() {
    var count = 0;
    var items = badViewModel.items();
    for(var i = 0; i < items.length; i++) {
        if(items[i].selected()) count++;
    }
    return count;
});

badViewModel.add = function() {
    badViewModel.items.push({
        body: badViewModel.counter++,
        selected: ko.observable(false)
    });
};


// Good View Model

var goodViewModel = {
    counter: 0,
    selectedItems: ko.observableArray(),
    items: ko.observableArray()
};

goodViewModel.allSelected = ko.computed({
    read: function() {
        return goodViewModel.items().length === goodViewModel.selectedItems().length;
    },
    write: function(newValue) {
        if(newValue) {
            goodViewModel.selectedItems(goodViewModel.items().slice(0)); // Need a copy!
        } else {
            goodViewModel.selectedItems.removeAll();
        }
    }
});

goodViewModel.numberSelected = ko.computed(function() {
    return goodViewModel.selectedItems().length;
});

goodViewModel.add = function() {
    var item = { body: goodViewModel.counter++ }
    item.selected = ko.computed({
        read: function() {
            return goodViewModel.selectedItems.indexOf(item) > -1;
        },
        write: function(newValue) {
            if(newValue) {
                goodViewModel.selectedItems.push(item);
            } else {
                goodViewModel.selectedItems.remove(item);
            }
        }
    });
    goodViewModel.items.push(item);
};

ko.applyBindings(badViewModel, document.getElementById('#badExample'));
ko.applyBindings(goodViewModel, document.getElementById('#goodExample'));
</script>]]></description>
    <pubDate>Thu, 05 May 2016 20:38:08 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/the-mistake-everyone-makes-with-knockoutjs.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>
<item>
    <title>Understanding typing judgments</title>
    <link>https://derekelkins.github.io/posts/understanding-typing-judgments.html</link>
    <description><![CDATA[<h3 id="introduction">Introduction</h3>
<p>For many people interested in type systems and type theory, their first encounter with the literature presents them with this:</p>
<p><code class="asciimath">#frac(Gamma,x:tau_1 |--_Sigma e : tau_2)(Gamma |--_Sigma (lambda x:tau_1.e) : tau_1 -&gt; tau_2) -&gt;I#</code></p>
<p><code class="asciimath">#frac(Gamma |--_Sigma f : tau_1 -&gt; tau_2 \qquad Gamma |--_Sigma x : tau_1)(Gamma |--_Sigma f x : tau_2) -&gt;E#</code></p>
<p>Since this notation is ubiquitous, authors (reasonably) expect readers to already be familiar with it and thus provide no explanation. Because the notation is ubiquitous, the beginner looking for alternate resources will not escape it. All they will find is that the notation is everywhere but exists in myriad minor variations which may or may not indicate significant differences. At this point the options are: 1) to muddle on and hope understanding the notation isn’t too important, 2) look for introductory resources which typically take the form of $50+ 500+ page textbooks, or 3) give up.</p>
<p>The goal of this article is to explain the notation part-by-part in common realizations, and to cover the main idea behind the notation which is the idea of an inductively defined relation. To eliminate ambiguity and make hand-waving impossible, I’ll ground the explanations in code, in particular, in <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php">Agda</a>. That means for each example of the informal notation, there will be how it would be realized in Agda.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> It will become clear that I’m am not (just) using Agda as a formal notation to talk about these concepts, but that Agda’s<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> data type mechanism directly captures them<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>. The significance of this is that programmers are already familiar with many of the ideas behind the informal notation, and the notation is just obscuring this familiarity. Admittedly, Agda is itself pretty intimidating. I hope most of this article is accessible to those with familiarity with algebraic data types as they appear in Haskell, ML, Rust, or Swift with little to no need to look up details about Agda. Nevertheless, Agda at least has the benefit, when compared to the informal notation, of having a clear place to go to learn more, an unambiguous meaning, and tools that allow playing around with the ideas.</p>
<!--more-->
<h3 id="parsing-and-reading">Parsing and reading</h3>
<p>To start, if you are not already familiar with it, get familiar with the <a href="https://en.wikipedia.org/wiki/Greek_alphabet#Letters">Greek alphabet</a>. It will be far easier to (mentally) read mathematical notation of any kind if you can say “Gamma x” rather than “right angle thingy x” or “upside-down L x”.</p>
<p>Using the example from the introduction, the whole thing is a <strong>rule</strong>. The “|-&gt;I|” part is just the name of the rule (in this case being short for “|-&gt;| Introduction”). This rule is only <em>part</em> of the definition of the <strong>judgment</strong> of the form:</p>
<p><code class="asciimath">#Gamma |--_Sigma e : tau#</code></p>
<p>The judgment can be viewed as a proposition and the rule is an “if-then” statement read from top to bottom. So the “|-&gt;I|” rule says, “<strong>if</strong> <code class="asciimath">#Gamma, x : tau_1 |--_Sigma e : tau_2#</code> <strong>then</strong> <code class="asciimath">#Gamma |--_Sigma lambda x : tau_1.e : tau_1 -&gt; tau_2#</code>”. It is often profitable to read it bottom-up as “<strong>To prove</strong> <code class="asciimath">#Gamma |--_Sigma lambda x : tau_1.e : tau_1 -&gt; tau_2#</code> <strong>you need to show</strong> <code class="asciimath">#Gamma, x : tau_1 |--_Sigma e : tau_2#</code>”.</p>
<p>So what is the judgment saying? First, the judgment is, in this case, a four argument relation. The arguments of this relation are #Gamma#, #Sigma#, #e#, and #tau#. We could say the name of this relation is the perspicuous <code class="asciimath">#(_)|--_((_)) (_) : (_)#</code>. Note that it does not make sense to ask what “⊢” means or what “:” means anymore than it makes sense to ask what “-&gt;” means in Haskell’s <code class="sourceCode haskell">\ x <span class="ot">-&gt;</span> e</code>.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
<p>In the context of type systems, #Gamma# is called the <strong>context</strong>, #Sigma# is called the <strong>signature</strong>, #e# is the <strong>term</strong> or <strong>expression</strong>, and #tau# is the <strong>type</strong>. Given this, I would read <code class="asciimath">#Gamma |--_Sigma e : tau#</code> as “the expression e has type tau in context gamma given signature sigma.” For the “#-&gt;E#” rule we have, additionally, multiple judgements above the line. These are joined together by conjunction, that is, we’d read “#-&gt;E#” as “<strong>if</strong> <code class="asciimath">#Gamma |--_Sigma f : tau_1 -&gt; tau_2#</code> <strong>and</strong> <code class="asciimath">#Gamma |--_Sigma x : tau_1#</code> <strong>then</strong> <code class="asciimath">#Gamma |--_Sigma f x : tau_2#</code></p>
<p>In most recent type system research multiple judgments are necessary to describe the type system, and so you may see things like <code class="asciimath">#Gamma |-- e &gt; tau#</code> or <code class="asciimath">#Gamma |-- e_1 &quot;~&quot; e_2#</code>. The key thing to remember is that these are completely distinct relations that will have their own definitions (although the collection of them will often be mutually recursively defined).</p>
<h3 id="inductively-defined-relations">Inductively Defined Relations</h3>
<h4 id="relations">Relations</h4>
<p>Relations in set theory are boolean valued functions. Being programmers, and thus constructivists, we want evidence, so a relation |R : A xx B -&gt; bb2| becomes a type constructor <code class="sourceCode agda">R <span class="ot">:</span> <span class="ot">(</span>A , B<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="dt">Set</span></code>. |R(a,b)| holds if we have a value (proof/witness) <code class="sourceCode agda">w <span class="ot">:</span> R a b</code>. An <strong>inductively defined relation</strong> or <strong>judgment</strong> is then just a type constructor for an (inductive) data type. That means, if <code>R</code> is an inductively defined relation, then its definition is <code class="sourceCode agda"><span class="kw">data</span> R <span class="ot">:</span> A <span class="ot">-&gt;</span> B <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="kw">where</span> <span class="ot">...</span></code>. A <strong>rule</strong> is a constructor of this data type. A <strong>derivation</strong> is a value of this data type, and will usually be a tree-like structure. As a bit of ambiguity in the terminology (arguably arising from a common ambiguity in mathematical notation), it’s a bit more natural to use the term “judgment” to refer to something that can be (at the meta level) true or false. For example, we’d say |R(a,b)| is a judgment. Nevertheless, when we say something like “the typing judgment” it’s clear that we’re referring to the whole relation, i.e. |R|.</p>
<h4 id="parameters-of-the-judgments">Parameters of the judgments</h4>
<p>Since a judgment is a relation, we need to describe what the arguments to the relation look like. Typically something like <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">BNF</a> is used. The BNF definitions provide the types used as parameters to the judgments. It is common to use a Fortran-esque style where a naming convention is used to avoid the need to explicitly declare the types of meta-variables. For example, the following says meta-variables like #n#, #m#, and #n_1# are all natural numbers.</p>
<pre><code>n, m ::= Z | S n</code></pre>
<p>BNF definitions translate readily to algebraic data types.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> Nat <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
    Z <span class="ot">:</span> Nat
    S <span class="ot">:</span> Nat <span class="ot">-&gt;</span> Nat</code></pre></div>
<blockquote>
<p>Agda note: <code class="sourceCode agda"><span class="dt">Set</span></code> is what is called <code class="sourceCode haskell"><span class="fu">*</span></code> in Haskell. “Type” would be a better name. Also, these sidebars will cover details about Agda with the aim that readers unfamiliar with Agda don’t get tripped up by tangential details.</p>
</blockquote>
<p>Sometimes it’s not possible to fully capture the constraints on well-formed syntax with BNF. In other words, only a subset of syntactically valid terms are well-formed. For example, <code class="sourceCode agda">Nat Nat</code> is syntactically valid but is not well-formed. We can pick out that subset with a predicate, i.e. a unary relation. This is, of course, nothing but another judgment. As an example, if we wired the <code class="sourceCode agda">Maybe</code> type into our type system, we’d likely have a judgment that looks like <code class="asciimath">#tau\ tt&quot;type&quot;#</code> which would include the following rule:</p>
<p><code class="asciimath">#frac(tau\ tt&quot;type&quot;)((&quot;Maybe&quot;\ tau)\ tt&quot;type&quot;)#</code></p>
<p>In a scenario like this, we’d also have to make sure the rules of our typing judgment also required the types involved to be well-formed. Modifying the example from the introduction, we’d get:</p>
<p><code class="asciimath">#frac(Gamma,x:tau_1 |--_Sigma e : tau_2 \qquad tau_1\ tt&quot;type&quot; \qquad tau_2\ tt&quot;type&quot;)(Gamma |--_Sigma (lambda x:tau_1.e) : tau_1 -&gt; tau_2) -&gt;I#</code></p>
<h4 id="a-simple-inductively-defined-relation-in-agda">A simple inductively defined relation in Agda</h4>
<p>As a very simple example, let’s say we wanted to provide explicit evidence that one natural number was less than or equal to another in Agda. Scenarios like this are common in dependently typed programming, and so we’ll start with the Agda this time and then “informalize” it.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> <span class="ot">_</span>isLessThanOrEqualTo<span class="ot">_</span> <span class="ot">:</span> Nat <span class="ot">-&gt;</span> Nat <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="kw">where</span>
    Z&lt;=n <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> Z isLessThanOrEqualTo n
    Sm&lt;=Sn <span class="ot">:</span> <span class="ot">{</span>m <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> m isLessThanOrEqualTo n <span class="ot">-&gt;</span> <span class="ot">(</span>S m<span class="ot">)</span> isLessThanOrEqualTo <span class="ot">(</span>S n<span class="ot">)</span></code></pre></div>
<blockquote>
<p>Agda notes: In Agda identifiers can contain almost any character so <code class="sourceCode agda">Z&lt;=n</code> is just an identifier. Agda allows any identifier to be used infix (or more generally mixfix). The underscores mark where the arguments go. So <code class="sourceCode agda"><span class="ot">_</span>isLessThanOrEqualTo<span class="ot">_</span></code> is a binary infix operator. Finally, curly brackets indicate implicit arguments which can be omitted and Agda will “guess” their values. Usually, they’ll be obvious to Agda by unification.</p>
</blockquote>
<p>In the informal notation, the types of the arguments are implied by the naming. <code>n</code> is a natural number because it was used as the metavariable (non-terminal) in the BNF for naturals. We also implicitly quantify over all free variables. In the Agda code, this quantification was explicit.</p>
<p><code class="asciimath">#frac()(Z &lt;= n) tt&quot;Z&lt;=n&quot;#</code></p>
<p><code class="asciimath">#frac(m &lt;= n)(S m &lt;= S n) tt&quot;Sm&lt;=Sn&quot;#</code></p>
<p>Again, I want to emphasize that these are <em>defining</em> <code>isLessThanOrEqualTo</code> and |&lt;=|. They can’t be wrong. They can only fail to coincide with our intuitions or to an alternate definition. A derivation that |2 &lt;= 3| looks like:</p>
<p>In Agda:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">twoIsLessThanThree <span class="ot">:</span> <span class="ot">(</span>S <span class="ot">(</span>S Z<span class="ot">))</span> isLessThanOrEqualTo <span class="ot">(</span>S <span class="ot">(</span>S <span class="ot">(</span>S Z<span class="ot">)))</span>
twoIsLessThanThree <span class="ot">=</span> Sm&lt;=Sn <span class="ot">(</span>Sm&lt;=Sn Z&lt;=n<span class="ot">)</span></code></pre></div>
<p>In the informal notation:</p>
<p><code class="asciimath">#frac(frac()(Z &lt;= S Z))(frac(S Z &lt;= S (S Z))(S (S Z) &lt;= S (S (S Z)))#</code></p>
<h3 id="big-step-operational-semantics">Big-step operational semantics</h3>
<p>Here’s a larger example that also illustrates that these judgments do not need to be typing judgments. Here we’re defining a big-step operational semantics for the untyped lambda calculus.</p>
<pre><code>x variable
v ::= λx.e
e ::= v | e e | x</code></pre>
<p>In informal presentations, binders like #lambda# are handled in a fairly relaxed manner. While the details of handling binders are tricky and error-prone, they are usually standard and so authors assume readers can fill in those details and are aware of the concerns (e.g. variable capture). In Agda, of course, we’ll need to spell out the details. There are <a href="https://namebinding.wordpress.com/">many approaches</a> for dealing with binders with different trade-offs. One of the newer and more convenient approaches is parametric higher-order abstract syntax (PHOAS). Higher-order abstract syntax (HOAS) approaches allow us to reuse the binding structure of the host language and thus eliminate much of the work. Below, this is realized by the <code class="sourceCode agda">Lambda</code> constructor taking a function as its argument. In a later section, I’ll use a different approach using deBruijn indices.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="co">-- PHOAS approach to binding</span>
<span class="kw">mutual</span>
    <span class="kw">data</span> Expr <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
        Val <span class="ot">:</span> Value A <span class="ot">-&gt;</span> Expr A
        App <span class="ot">:</span> Expr A <span class="ot">-&gt;</span> Expr A <span class="ot">-&gt;</span> Expr A
        Var <span class="ot">:</span> A <span class="ot">-&gt;</span> Expr A

    <span class="kw">data</span> Value <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
        Lambda <span class="ot">:</span> <span class="ot">(</span>A <span class="ot">-&gt;</span> Expr A<span class="ot">)</span> <span class="ot">-&gt;</span> Value A

<span class="co">-- A closed expression</span>
CExpr <span class="ot">:</span> <span class="dt">Set1</span>
CExpr <span class="ot">=</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> Expr A

<span class="co">-- A closed expression that is a value</span>
CValue <span class="ot">:</span> <span class="dt">Set1</span>
CValue <span class="ot">=</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> Value A</code></pre></div>
<blockquote>
<p>Agda note: <code class="sourceCode agda"><span class="dt">Set1</span></code> is needed for technical reasons that are unimportant. You can just pretend it says <code class="sourceCode agda"><span class="dt">Set</span></code> instead. More important is that the definitions of <code class="sourceCode agda">Expr</code> and <code class="sourceCode agda">Value</code> are a bit different than the definition for <code class="sourceCode agda"><span class="ot">_</span>isLessThanOrEqualTo<span class="ot">_</span></code>. In particular, the argument <code class="sourceCode agda"><span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span></code> occurs to the left of the colon. When an argument occurs to the left of the colon we say it <strong>parameterizes</strong> the data declaration and that it is a <strong>parameter</strong>. When it occurs to the right of the colon we say it <strong>indexes</strong> the data declaration and that it is an <strong>index</strong>. The difference is that parameters must occur uniformly in the return type of the data constructors while indexes can be different in each data constructor. The arguments of an inductively defined relation like <code class="sourceCode agda"><span class="ot">_</span>isLessThanOrEqualTo<span class="ot">_</span></code> will always be indexes (though there could be additional parameters.)</p>
</blockquote>
<p><code class="asciimath">#frac(e_1 darr lambda x.e \qquad e_2 darr v_2 \qquad e[x|-&gt;v_2] darr v)(e_1 e_2 darr v) tt&quot;App&quot;#</code></p>
<p><code class="asciimath">#frac()(v darr v) tt&quot;Trivial&quot;#</code></p>
<p>The #e darr v# judgment (read as “the expression #e# evaluates to the value #v#”) defines a call-by-value evaluation relation. #e[x|-&gt;v]# means “substitute #v# for #x# in the expression #e#”. This notation is not standardized; there are many variants. In more rigorous presentations this operation will be formally defined, but usually the authors assume you are familiar with it. In the <code class="asciimath">#tt&quot;Trivial&quot;#</code> rule, the inclusion of values into expressions is implicitly used. Note that the rule is restricted to values only.</p>
<p>The <code class="asciimath">#tt&quot;App&quot;#</code> rule specifies call-by-value because the #e_2# expression is evaluated and then the resulting value is substituted into #e#. For call-by-name, we’d omit the evaluation of #e_2# and directly substitute #e_2# for #x# in #e#. Whether #e_1# or #e_2# is evaluated first (or in parallel) is not specified in this example.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">subst <span class="ot">:</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> Expr <span class="ot">(</span>Expr A<span class="ot">)</span> <span class="ot">-&gt;</span> Expr A
subst <span class="ot">(</span>Var e<span class="ot">)</span> <span class="ot">=</span> e
subst <span class="ot">(</span>Val <span class="ot">(</span>Lambda b<span class="ot">))</span> <span class="ot">=</span> Val <span class="ot">(</span>Lambda <span class="ot">(λ</span> a <span class="ot">-&gt;</span> subst <span class="ot">(</span>b <span class="ot">(</span>Var a<span class="ot">))))</span>
subst <span class="ot">(</span>App e1 e2<span class="ot">)</span> <span class="ot">=</span> App <span class="ot">(</span>subst e1<span class="ot">)</span> <span class="ot">(</span>subst e2<span class="ot">)</span>

<span class="kw">data</span> <span class="ot">_</span>EvaluatesTo<span class="ot">_</span> <span class="ot">:</span> CExpr <span class="ot">-&gt;</span> CValue <span class="ot">-&gt;</span> <span class="dt">Set1</span> <span class="kw">where</span>
    EvaluateTrivial <span class="ot">:</span> <span class="ot">{</span>v <span class="ot">:</span> CValue<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>Val v<span class="ot">)</span> EvaluatesTo v
    EvaluateApp <span class="ot">:</span> <span class="ot">{</span>e1 <span class="ot">:</span> CExpr<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>e2 <span class="ot">:</span> CExpr<span class="ot">}</span>
        <span class="ot">-&gt;</span> <span class="ot">{</span>e <span class="ot">:</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> A <span class="ot">-&gt;</span> Expr A<span class="ot">}</span>
        <span class="ot">-&gt;</span> <span class="ot">{</span>v2 <span class="ot">:</span> CValue<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>v <span class="ot">:</span> CValue<span class="ot">}</span>
        <span class="ot">-&gt;</span> e1 EvaluatesTo <span class="ot">(</span>Lambda e<span class="ot">)</span>
        <span class="ot">-&gt;</span> e2 EvaluatesTo v2
        <span class="ot">-&gt;</span> <span class="ot">(</span>subst <span class="ot">(</span>e <span class="ot">(</span>Val v2<span class="ot">)))</span> EvaluatesTo v
        <span class="ot">-&gt;</span> <span class="ot">(</span>App e1 e2<span class="ot">)</span> EvaluatesTo v</code></pre></div>
<p>The <code class="sourceCode agda">EvaluateTrivial</code> constructor explicitly uses the <code class="sourceCode agda">Val</code> injection of values into expressions. The <code class="sourceCode agda">EvaluateApp</code> constructor starts off with a series of implicit arguments that introduce and quantify over the variables used in the rule. After those, each judgement above the line in the <code class="asciimath">#tt&quot;App&quot;#</code> rule, becomes an argument to the <code class="sourceCode agda">EvaluateApp</code> constructor.</p>
<p>In this case ↓ is defining a functional relation, meaning for every expression there’s at most one value that the expression evaluates to. So another natural way to interpret ↓ is as a definition, in logic programming style, of a (partial) recursive function. In other words we can use the concept of mode from logic programming and instead of treating the arguments to ↓ as inputs, we can treat the first as an input and the second as an output.</p>
<p>↓ gives rise to a partial function because not every expression has a normal form. For <code class="sourceCode agda"><span class="ot">_</span>EvaluatesTo<span class="ot">_</span></code> this is realized by the fact that we simply won’t be able to construct a term of type <code class="sourceCode agda">e EvaluatesTo v</code> for any <code class="sourceCode agda">v</code> if <code class="sourceCode agda">e</code> doesn’t have a normal form. In fact, we can use the inductive structure of the relationship to help prove that statement. (Unfortunately, Agda doesn’t present a very good experience for data types indexed by functions, so the proof is not nearly as smooth as one would like.)</p>
<h3 id="type-systems">Type systems</h3>
<p>Next we’ll turn to type systems which will present an even larger example, and will introduce some concepts that are specific to type systems (though, of course, they overlap greatly with concepts in logic due to the Curry-Howard correspondence.)</p>
<h4 id="terms-and-types">Terms and types</h4>
<p>Below is an informal presentation of the polymorphic lambda calculus with explicit type abstraction and type application. An interesting fact about the polymorphic lambda calculus is that we don’t need any base types. Via Church-encoding, we can define types like natural numbers and lists.</p>
<pre><code>α type variable
τ ::= τ → τ | ∀α. τ | α

x variable
c constant
v ::= λx:τ.e | Λτ.e | c
e ::= v | e e | e[τ] | x</code></pre>
<p>In this case I’ll be using deBruijn indices to handle the binding structure of the terms and types. This means instead of writing <code class="asciimath">|lambda x.lambda y. x|</code>, you would write <code class="asciimath">|lambda lambda 1|</code> where the |1| counts how many binders (lambdas) you need to traverse to reach the binding site.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> TType <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
    TTVar <span class="ot">:</span> Nat <span class="ot">-&gt;</span> TType                    <span class="co">-- α</span>
    <span class="ot">_</span>=&gt;<span class="ot">_</span> <span class="ot">:</span> TType <span class="ot">-&gt;</span> TType <span class="ot">-&gt;</span> TType          <span class="co">-- τ → τ</span>
    Forall <span class="ot">:</span> TType <span class="ot">-&gt;</span> TType                 <span class="co">-- ∀α. τ</span>

<span class="kw">mutual</span>
    <span class="kw">data</span> TExpr <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
        TVal <span class="ot">:</span> TValue <span class="ot">-&gt;</span> TExpr              <span class="co">-- v</span>
        TApp <span class="ot">:</span> TExpr <span class="ot">-&gt;</span> TExpr <span class="ot">-&gt;</span> TExpr      <span class="co">-- f x</span>
        TTyApp <span class="ot">:</span> TExpr <span class="ot">-&gt;</span> TType <span class="ot">-&gt;</span> TExpr    <span class="co">-- e[τ]</span>
        TVar <span class="ot">:</span> Nat <span class="ot">-&gt;</span> TExpr                 <span class="co">-- x</span>

    <span class="kw">data</span> TValue <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
        TLambda <span class="ot">:</span> TType <span class="ot">-&gt;</span> TExpr <span class="ot">-&gt;</span> TValue  <span class="co">-- λx:τ.e</span>
        TTyLambda <span class="ot">:</span> TExpr <span class="ot">-&gt;</span> TValue         <span class="co">-- Λτ.e</span>
        TConst <span class="ot">:</span> Nat <span class="ot">-&gt;</span> TValue              <span class="co">-- c</span></code></pre></div>
<h4 id="the-context">The Context</h4>
<p>In formulating the typing rules we need to deal with <strong>open terms</strong>, that is terms which refer to variables that they don’t bind. This should only happen if some enclosing terms <em>did</em> bind those variables, so we need to keep track of the variables that have been bound by enclosing terms. For example, when type checking <code class="asciimath">|lambda x:tau.x|</code>, we’ll need to type check the subterm |x| which does not contain enough information in itself for us to know what the type should be. So, we keep track of what variables have been bound (and to what type) in a <strong>context</strong> and then we can just look up the expected type. When authors bother formally spelling out the context, it will look something like the following:</p>
<pre><code>Γ ::= . | Γ, x:τ
Δ ::= . | Δ, α</code></pre>
<p>We see that this is just a (snoc) list. In the first case, |Gamma|, it is a list of pairs of variables and types, i.e. an association list mapping variables to types. Often it will be treated as a finite mapping. In the second case, |Delta|, it is a list of type variables. Since I’m using deBruijn notation, there are no variables so we end up with a list of types in the first case. In the second case, we would end up with a list of nothing in particular, i.e. a list of unit, but that is isomorphic to a natural number. In other words, the only purpose of the type context, |Delta|, is to make sure we don’t use unbound variables, which in deBruijn notation just means we don’t have deBruijn indexes that try to traverse more lambdas than enclose them. The Agda code for the above is completely straight-forward.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> List <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
    Nil <span class="ot">:</span> List A
    <span class="ot">_</span>,<span class="ot">_</span> <span class="ot">:</span> List A <span class="ot">-&gt;</span> A <span class="ot">-&gt;</span> List A

Context <span class="ot">:</span> <span class="dt">Set</span>
Context <span class="ot">=</span> List TType

TypeContext <span class="ot">:</span> <span class="dt">Set</span>
TypeContext <span class="ot">=</span> Nat</code></pre></div>
<h4 id="the-signature">The Signature</h4>
<p>Signatures keep track of what primitive, “user-defined” constants might exist. Often the signature is omitted since nothing particularly interesting happens with it. Indeed, that will be the case for us. Nevertheless, we see that the signature is just another association list mapping constants to types.</p>
<pre><code>Σ ::= . | Σ, c:τ</code></pre>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">Signature <span class="ot">:</span> <span class="dt">Set</span>
Signature <span class="ot">=</span> List TType</code></pre></div>
<p>The main reason I included the signature, beyond just covering it for the cases when it is included, is that sometimes certain rules can be better understood as manipulations of the signature. For example, in <em>logic</em>, universal quantification is often described by a rule like:</p>
<p><code class="asciimath">#frac(Gamma |-- P[x|-&gt;c] \qquad c\ &quot;fresh&quot;)(Gamma |-- forall x.P)#</code></p>
<p>What’s happening and what “freshness” is is made a bit clearer by employing a signature (which for logic is usually just a list of constants similar to our <code>TypeContext</code>):</p>
<p><code class="asciimath">#frac(Gamma |--_(Sigma, c) P[x|-&gt;c] \qquad c notin Sigma)(Gamma |--_Sigma forall x.P)#</code></p>
<h4 id="judgment">Judgment</h4>
<p>To define the typing rules we need two judgements. The first, <code class="asciimath">#Delta |-- tau#</code>, will be a simple judgement that says |tau| is a well formed type in |Delta|. This basically just requires that all variables are bound.</p>
<p><code class="asciimath">#frac(alpha in Delta)(Delta |-- alpha)#</code></p>
<p><code class="asciimath">#frac(Delta, alpha |-- tau)(Delta |-- forall alpha. tau)#</code></p>
<p><code class="asciimath">#frac(Delta |-- tau_1 \qquad Delta |-- tau_2)(Delta |-- tau_1 -&gt; tau_2)#</code></p>
<p>The Agda is</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> <span class="ot">_</span>&lt;<span class="ot">_</span> <span class="ot">:</span> Nat <span class="ot">-&gt;</span> Nat <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="kw">where</span>
    Z&lt;Sn <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> Z &lt; S n
    Sn&lt;SSm <span class="ot">:</span> <span class="ot">{</span>n m <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> n &lt; S m <span class="ot">-&gt;</span> S n &lt; S <span class="ot">(</span>S m<span class="ot">)</span>

<span class="kw">data</span> <span class="ot">_</span>isValidIn<span class="ot">_</span> <span class="ot">:</span> TType <span class="ot">-&gt;</span> TypeContext <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="kw">where</span>
    TyVarJ <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>ctx <span class="ot">:</span> TypeContext<span class="ot">}</span> <span class="ot">-&gt;</span> n &lt; ctx <span class="ot">-&gt;</span> <span class="ot">(</span>TTVar n<span class="ot">)</span> isValidIn ctx
    TyArrJ <span class="ot">:</span> <span class="ot">{</span>t1 t2 <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>ctx <span class="ot">:</span> TypeContext<span class="ot">}</span> <span class="ot">-&gt;</span> t1 isValidIn ctx <span class="ot">-&gt;</span> t2 isValidIn ctx <span class="ot">-&gt;</span> <span class="ot">(</span>t1 =&gt; t2<span class="ot">)</span> isValidIn ctx
    TyForallJ <span class="ot">:</span> <span class="ot">{</span>t <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>ctx <span class="ot">:</span> TypeContext<span class="ot">}</span> <span class="ot">-&gt;</span> t isValidIn <span class="ot">(</span>S ctx<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>Forall t<span class="ot">)</span> isValidIn ctx</code></pre></div>
<p>The meat is the following typing judgement, depending on the judgement defining well-formed types. I’m not really going to explain these rules because, in some sense, there is nothing to explain. Beyond explaining the notation itself, which was the point of the article, the below is “self-explanatory” in the sense that it is a definition, and whether it is a good definition or “meaningful” depends on whether we can prove the theorems we want about it.</p>
<p><code class="asciimath">#frac(c:tau in Sigma \qquad Delta |-- tau)(Delta;Gamma |--_Sigma c : tau) tt&quot;Const&quot;#</code></p>
<p><code class="asciimath">#frac(x:tau in Gamma \qquad Delta |-- tau)(Delta;Gamma |--_Sigma x : tau) tt&quot;Var&quot;#</code></p>
<p><code class="asciimath">#frac(Delta;Gamma |--_Sigma e_1 : tau_1 -&gt; tau_2 \qquad Delta;Gamma |--_Sigma e_2 : tau_1)(Delta;Gamma |--_Sigma e_1 e_2 : tau_2) tt&quot;App&quot;#</code></p>
<p><code class="asciimath">#frac(Delta;Gamma |--_Sigma e : forall alpha. tau_1 \qquad Delta |-- tau_2)(Delta;Gamma |--_Sigma e[tau_2] : tau_1[alpha|-&gt;tau_2]) tt&quot;TyApp&quot;#</code></p>
<p><code class="asciimath">#frac(Delta;Gamma, x:tau_1 |--_Sigma e : tau_2 \qquad Delta |-- tau_1)(Delta;Gamma |--_Sigma (lambda x:tau_1.e) : tau_1 -&gt; tau_2) tt&quot;Abs&quot;#</code></p>
<p><code class="asciimath">#frac(Delta, alpha;Gamma |--_Sigma e : tau)(Delta;Gamma |--_Sigma (Lambda alpha.e) : forall alpha. tau) tt&quot;TyAbs&quot;#</code></p>
<p>Here’s the corresponding Agda code. Note, all Agda is doing for us here is making sure we haven’t written self-contradictory nonsense. In no way is Agda ensuring that this is the “right” definition. For example, it could be the case (but isn’t) that there are no values of this type. Agda would be perfectly content to let us define a type that had no values.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">tySubst <span class="ot">:</span> TType <span class="ot">-&gt;</span> TType <span class="ot">-&gt;</span> TType
tySubst t1 t2 <span class="ot">=</span> tySubst&#39; t1 t2 Z
    <span class="kw">where</span> tySubst&#39; <span class="ot">:</span> TType <span class="ot">-&gt;</span> TType <span class="ot">-&gt;</span> Nat <span class="ot">-&gt;</span> TType
          tySubst&#39; <span class="ot">(</span>TTVar Z<span class="ot">)</span> t2 Z <span class="ot">=</span> t2
          tySubst&#39; <span class="ot">(</span>TTVar Z<span class="ot">)</span> t2 <span class="ot">(</span>S <span class="ot">_)</span> <span class="ot">=</span> TTVar Z
          tySubst&#39; <span class="ot">(</span>TTVar <span class="ot">(</span>S n<span class="ot">))</span> t2 Z <span class="ot">=</span> TTVar <span class="ot">(</span>S n<span class="ot">)</span>
          tySubst&#39; <span class="ot">(</span>TTVar <span class="ot">(</span>S n<span class="ot">))</span> t2 <span class="ot">(</span>S d<span class="ot">)</span> <span class="ot">=</span> tySubst&#39; <span class="ot">(</span>TTVar n<span class="ot">)</span> t2 d
          tySubst&#39; <span class="ot">(</span>t1 =&gt; t2<span class="ot">)</span> t3 d <span class="ot">=</span> tySubst&#39; t1 t3 d =&gt; tySubst&#39; t2 t3 d
          tySubst&#39; <span class="ot">(</span>Forall t1<span class="ot">)</span> t2 d <span class="ot">=</span> tySubst&#39; t1 t2 <span class="ot">(</span>S d<span class="ot">)</span>

<span class="kw">data</span> <span class="ot">_</span>isIn<span class="ot">_</span>at<span class="ot">_</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">:</span> A <span class="ot">-&gt;</span> List A <span class="ot">-&gt;</span> Nat <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="kw">where</span>
    Found <span class="ot">:</span> <span class="ot">{</span>a <span class="ot">:</span> A<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>l <span class="ot">:</span> List A<span class="ot">}</span> <span class="ot">-&gt;</span> a isIn <span class="ot">(</span>l , a<span class="ot">)</span> at Z
    Next <span class="ot">:</span> <span class="ot">{</span>a <span class="ot">:</span> A<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>b <span class="ot">:</span> A<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>l <span class="ot">:</span> List A<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> a isIn l at n <span class="ot">-&gt;</span> a isIn <span class="ot">(</span>l , b<span class="ot">)</span> at <span class="ot">(</span>S n<span class="ot">)</span>

<span class="kw">data</span> <span class="ot">_</span>hasType<span class="ot">_</span>inContext<span class="ot">_</span>and<span class="ot">_</span>given<span class="ot">_</span> <span class="ot">:</span> TExpr <span class="ot">-&gt;</span> TType <span class="ot">-&gt;</span> Context <span class="ot">-&gt;</span> TypeContext <span class="ot">-&gt;</span> Signature <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="kw">where</span>
    ConstJ <span class="ot">:</span> <span class="ot">{</span>t <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>c <span class="ot">:</span> Nat<span class="ot">}</span>
        <span class="ot">-&gt;</span> <span class="ot">{</span>Sigma <span class="ot">:</span> Signature<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Gamma <span class="ot">:</span> Context<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Delta <span class="ot">:</span> TypeContext<span class="ot">}</span>
        <span class="ot">-&gt;</span> t isIn Sigma at c
        <span class="ot">-&gt;</span> t isValidIn Delta
        <span class="ot">-&gt;</span> <span class="ot">(</span>TVal <span class="ot">(</span>TConst c<span class="ot">))</span> hasType t inContext Gamma and Delta given Sigma

    VarJ <span class="ot">:</span> <span class="ot">{</span>t <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>x <span class="ot">:</span> Nat<span class="ot">}</span>
        <span class="ot">-&gt;</span> <span class="ot">{</span>Sigma <span class="ot">:</span> Signature<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Gamma <span class="ot">:</span> Context<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Delta <span class="ot">:</span> TypeContext<span class="ot">}</span>
        <span class="ot">-&gt;</span> t isIn Gamma at x
        <span class="ot">-&gt;</span> t isValidIn Delta
        <span class="ot">-&gt;</span> <span class="ot">(</span>TVar x<span class="ot">)</span> hasType t inContext Gamma and Delta given Sigma

    AppJ <span class="ot">:</span> <span class="ot">{</span>t1 <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>t2 <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>e1 <span class="ot">:</span> TExpr<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>e2 <span class="ot">:</span> TExpr<span class="ot">}</span>
        <span class="ot">-&gt;</span> <span class="ot">{</span>Sigma <span class="ot">:</span> Signature<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Gamma <span class="ot">:</span> Context<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Delta <span class="ot">:</span> TypeContext<span class="ot">}</span>
        <span class="ot">-&gt;</span> e1 hasType <span class="ot">(</span>t1 =&gt; t2<span class="ot">)</span> inContext Gamma and Delta given Sigma
        <span class="ot">-&gt;</span> e2 hasType t1 inContext Gamma and Delta given Sigma
        <span class="ot">-&gt;</span> <span class="ot">(</span>TApp e1 e2<span class="ot">)</span> hasType t2 inContext Gamma and Delta given Sigma

    TyAppJ <span class="ot">:</span> <span class="ot">{</span>t1 <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>t2 <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>e <span class="ot">:</span> TExpr<span class="ot">}</span>
        <span class="ot">-&gt;</span> <span class="ot">{</span>Sigma <span class="ot">:</span> Signature<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Gamma <span class="ot">:</span> Context<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Delta <span class="ot">:</span> TypeContext<span class="ot">}</span>
        <span class="ot">-&gt;</span> e hasType <span class="ot">(</span>Forall t1<span class="ot">)</span> inContext Gamma and Delta given Sigma
        <span class="ot">-&gt;</span> t2 isValidIn Delta
        <span class="ot">-&gt;</span> <span class="ot">(</span>TTyApp e t2<span class="ot">)</span> hasType <span class="ot">(</span>tySubst t1 t2<span class="ot">)</span> inContext Gamma and Delta given Sigma

    AbsJ <span class="ot">:</span> <span class="ot">{</span>t1 <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>t2 <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>e <span class="ot">:</span> TExpr<span class="ot">}</span>
        <span class="ot">-&gt;</span> <span class="ot">{</span>Sigma <span class="ot">:</span> Signature<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Gamma <span class="ot">:</span> Context<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Delta <span class="ot">:</span> TypeContext<span class="ot">}</span>
        <span class="ot">-&gt;</span> e hasType t2 inContext <span class="ot">(</span>Gamma , t1<span class="ot">)</span> and Delta given Sigma
        <span class="ot">-&gt;</span> <span class="ot">(</span>TVal <span class="ot">(</span>TLambda t1 e<span class="ot">))</span> hasType <span class="ot">(</span>t1 =&gt; t2<span class="ot">)</span> inContext Gamma and Delta given Sigma

    TyAbsJ <span class="ot">:</span> <span class="ot">{</span>t <span class="ot">:</span> TType<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>e <span class="ot">:</span> TExpr<span class="ot">}</span>
        <span class="ot">-&gt;</span> <span class="ot">{</span>Sigma <span class="ot">:</span> Signature<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Gamma <span class="ot">:</span> Context<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>Delta <span class="ot">:</span> TypeContext<span class="ot">}</span>
        <span class="ot">-&gt;</span> e hasType t inContext Gamma and <span class="ot">(</span>S Delta<span class="ot">)</span> given Sigma
        <span class="ot">-&gt;</span> <span class="ot">(</span>TVal <span class="ot">(</span>TTyLambda e<span class="ot">))</span> hasType <span class="ot">(</span>Forall t<span class="ot">)</span> inContext Gamma and Delta given Sigma</code></pre></div>
<p>Here’s a typing derivation for the polymorphic constant function:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">
tyLam <span class="ot">:</span> TExpr <span class="ot">-&gt;</span> TExpr
tyLam e <span class="ot">=</span> TVal <span class="ot">(</span>TTyLambda e<span class="ot">)</span>

lam <span class="ot">:</span> TType <span class="ot">-&gt;</span> TExpr <span class="ot">-&gt;</span> TExpr
lam t e <span class="ot">=</span> TVal <span class="ot">(</span>TLambda t e<span class="ot">)</span>

polyConst
    <span class="ot">:</span> tyLam <span class="ot">(</span>tyLam <span class="ot">(</span>lam <span class="ot">(</span>TTVar Z<span class="ot">)</span> <span class="ot">(</span>lam <span class="ot">(</span>TTVar <span class="ot">(</span>S Z<span class="ot">))</span> <span class="ot">(</span>TVar <span class="ot">(</span>S Z<span class="ot">)))))</span>    <span class="co">-- Λs.Λt.λx:t.λy:s.x</span>
    hasType <span class="ot">(</span>Forall <span class="ot">(</span>Forall <span class="ot">(</span>TTVar Z =&gt; <span class="ot">(</span>TTVar <span class="ot">(</span>S Z<span class="ot">)</span> =&gt; TTVar Z<span class="ot">))))</span>     <span class="co">-- ∀s.∀t.t→s→t</span>
    inContext Nil and Z
    given Nil
polyConst <span class="ot">=</span> TyAbsJ <span class="ot">(</span>TyAbsJ <span class="ot">(</span>AbsJ <span class="ot">(</span>AbsJ <span class="ot">(</span>VarJ <span class="ot">(</span>Next Found<span class="ot">)</span> <span class="ot">(</span>TyVarJ Z&lt;Sn<span class="ot">)))))</span> <span class="co">-- written by Agda</span>

<span class="kw">data</span> False <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>

Not <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">-&gt;</span> <span class="dt">Set</span>
Not A <span class="ot">=</span> A <span class="ot">-&gt;</span> False

wrongType
    <span class="ot">:</span> Not <span class="ot">(</span>tyLam <span class="ot">(</span>lam <span class="ot">(</span>TTVar Z<span class="ot">)</span> <span class="ot">(</span>TVar Z<span class="ot">))</span>   <span class="co">-- Λt.λx:t.x</span>
           hasType <span class="ot">(</span>Forall <span class="ot">(</span>TTVar Z<span class="ot">))</span>       <span class="co">-- ∀t.t</span>
           inContext Nil and Z
           given Nil<span class="ot">)</span>
wrongType <span class="ot">(</span>TyAbsJ <span class="ot">())</span></code></pre></div>
<p>Having written all this, we have not defined a type checking algorithm (though Agda’s <code>auto</code> tactic does a pretty good job); we’ve merely specified what evidence that a program is well-typed is. Explicitly, a type checking algorithm would be a function with the following type:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> Maybe <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
    Nothing <span class="ot">:</span> Maybe A
    Just <span class="ot">:</span> A <span class="ot">-&gt;</span> Maybe A

typeCheck <span class="ot">:</span> <span class="ot">(</span>e <span class="ot">:</span> TExpr<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>t <span class="ot">:</span> TType<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>sig <span class="ot">:</span> Signature<span class="ot">)</span> <span class="ot">-&gt;</span> Maybe <span class="ot">(</span>e hasType t inContext Nil and Z given sig<span class="ot">)</span>
typeCheck <span class="ot">=</span> ?</code></pre></div>
<p>In fact, we’d want to additionally prove that this function never returns <code class="sourceCode agda">Nothing</code> if there does exist a typing derivation that would give <code>e</code> the type <code>t</code> in signature <code>sig</code>. We could formalize this in Agda by instead giving <code class="sourceCode agda">typeCheck</code> the following type:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> Decidable <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
    IsTrue <span class="ot">:</span> A <span class="ot">-&gt;</span> Decidable A
    IsFalse <span class="ot">:</span> Not A <span class="ot">-&gt;</span> Decidable A

typeCheckDec <span class="ot">:</span> <span class="ot">(</span>e <span class="ot">:</span> TExpr<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>t <span class="ot">:</span> TType<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>sig <span class="ot">:</span> Signature<span class="ot">)</span> <span class="ot">-&gt;</span> Decidable <span class="ot">(</span>e hasType t inContext Nil and Z given sig<span class="ot">)</span>
typeCheckDec <span class="ot">=</span> ?</code></pre></div>
<p>This type says that either <code class="sourceCode agda">typeCheckDec</code> will return a typing derivation, or it will return a proof that there is no typing derivation. As the name <code class="sourceCode agda">Decidable</code> suggests, this may not always be possible. Which is to say, type checking may not always be decidable. Note, we can <em>always</em> check that a <em>typing derivation</em> is valid — we just need to verify that we applied the rules correctly — what we can’t necessarily do is <em>find</em> such a derivation given only the expression and the type or prove that no such derivation exists. Similar concerns apply to type inference which could have one of the following types:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">record</span> Σ <span class="ot">(</span>T <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>F <span class="ot">:</span> T <span class="ot">-&gt;</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
    <span class="kw">field</span>
        fst <span class="ot">:</span> T
        snd <span class="ot">:</span> F fst

inferType <span class="ot">:</span> <span class="ot">(</span>e <span class="ot">:</span> TExpr<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>sig <span class="ot">:</span> Signature<span class="ot">)</span> <span class="ot">-&gt;</span> Maybe <span class="ot">(</span>Σ TType <span class="ot">(λ</span> t <span class="ot">→</span> e hasType t inContext Nil and Z given sig<span class="ot">))</span>
inferType <span class="ot">=</span> ?

inferTypeDec <span class="ot">:</span> <span class="ot">(</span>e <span class="ot">:</span> TExpr<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>sig <span class="ot">:</span> Signature<span class="ot">)</span> <span class="ot">-&gt;</span> Decidable <span class="ot">(</span>Σ TType <span class="ot">(λ</span> t <span class="ot">→</span> e hasType t inContext Nil and Z given sig<span class="ot">))</span>
inferTypeDec <span class="ot">=</span> ?</code></pre></div>
<p>where Σ indicates a dependent sum, i.e. a pair where the second component (here of type <code class="sourceCode agda">e hasType t inContext Nil and Z given sig</code>) depends on the first component (here of type <code class="sourceCode agda">TType</code>). With type inference we have the additional concern that there may be multiple possible types an expression could have, and we may want to ensure it returns the “most general” type in some sense. There may not always be a good sense of “most general” type and user-input is required to pick out of the possible types.</p>
<p>Sometimes the rules themselves can be viewed as the defining rules of a logic program and thus directly provide an algorithm. For example, if we eliminate the rules, types, and terms related to polymorphism, we’d get the simply typed lambda calculus. A Prolog program to do type checking can be written in a few lines with a one-to-one correspondence to the type checking rules (and, for simplicitly, also omitting the signature):</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">lookup(z<span class="kw">,</span> [<span class="dt">T</span><span class="fu">|</span><span class="dt">_</span>]<span class="kw">,</span> <span class="dt">T</span>)<span class="kw">.</span>
lookup(s(<span class="dt">N</span>)<span class="kw">,</span> [<span class="dt">_</span><span class="fu">|</span><span class="dt">Ctx</span>]<span class="kw">,</span><span class="dt">T</span>) <span class="kw">:-</span> lookup(<span class="dt">N</span><span class="kw">,</span> <span class="dt">Ctx</span><span class="kw">,</span> <span class="dt">T</span>)<span class="kw">.</span>

typeCheck(<span class="dt">var</span>(<span class="dt">N</span>)<span class="kw">,</span> <span class="dt">Ctx</span><span class="kw">,</span> <span class="dt">T</span>) <span class="kw">:-</span> lookup(<span class="dt">N</span><span class="kw">,</span> <span class="dt">Ctx</span><span class="kw">,</span> <span class="dt">T</span>)<span class="kw">.</span>
typeCheck(app(<span class="dt">F</span><span class="kw">,</span><span class="dt">X</span>)<span class="kw">,</span> <span class="dt">Ctx</span><span class="kw">,</span> <span class="dt">T2</span>) <span class="kw">:-</span> typeCheck(<span class="dt">F</span><span class="kw">,</span> <span class="dt">Ctx</span><span class="kw">,</span> tarr(<span class="dt">T1</span><span class="kw">,</span> <span class="dt">T2</span>))<span class="kw">,</span> typeCheck(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Ctx</span><span class="kw">,</span> <span class="dt">T1</span>)<span class="kw">.</span>
typeCheck(lam(<span class="dt">B</span>)<span class="kw">,</span> <span class="dt">Ctx</span><span class="kw">,</span> tarr(<span class="dt">T1</span><span class="kw">,</span> <span class="dt">T2</span>)) <span class="kw">:-</span> typeCheck(<span class="dt">B</span><span class="kw">,</span> [<span class="dt">T1</span><span class="fu">|</span><span class="dt">Ctx</span>]<span class="kw">,</span> <span class="dt">T2</span>)<span class="kw">.</span></code></pre></div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="raw/UnderstandingTypingJudgments.agda">This Agda file</a> contains all the code from this article.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Most dependently typed languages, such as Coq or Epigram would also be adequate.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p><a href="https://en.wikipedia.org/wiki/Epigram_%28programming_language%29#Examples">Epigram</a> is most notable by actually using this 2D syntax.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>See <a href="http://cs.stackexchange.com/questions/54508/what-does-%E2%8A%A2-mean-in-operational-semantics/54514#54514">this StackExchange answer</a> for more discussion of this.<a href="#fnref4">↩</a></p></li>
</ol>
</div>]]></description>
    <pubDate>Wed, 13 Apr 2016 02:41:24 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/understanding-typing-judgments.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>
<item>
    <title>High dimensional thought experiment from Hamming</title>
    <link>https://derekelkins.github.io/posts/high-dimensional-thought-experiment.html</link>
    <description><![CDATA[<p>This is a simple mathematical thought experiment from Richard Hamming to demonstrate how poor our intuition  for high dimensional spaces is. All that is needed is some basic, middle school level geometry and algebra.  Consider a 2x2 square centered at the origin. In each quadrant place circles as big as possible so that they fit in the square and don’t overlap. They’ll clearly have radius 1/2. See the image below. The question now is what’s the radius of the largest circle centered at the origin that doesn’t overlap the other circles.  <img src="raw/high-dimensional-diagram.svg" alt=""></img>  It’s clear from symmetry that the inner circle is going to touch all the other circles at the same time, and it is clear that it is going to touch along the line from the origin to the center of one of the outer circles. So the radius of the inner circle, #r#, is just the distance from the origin to the center of one of the outer circles minus the radius of the outer circle, namely 1/2. As an equation:  <code class="asciimath">#r = sqrt(1/2^2 + 1/2^2) - 1/2 = sqrt(2)/2 - 1/2 ~~ 0.207106781#</code>  Now if we go to three dimensions we’ll have eight circles instead of four, but everything else is the same except the distances will now be <code class="asciimath">#sqrt(1/2^2 + 1/2^2 + 1/2^2)#</code>. It’s clear that the only  difference for varying dimensions is that in dimension #n# we’ll have #n# #1/2^2# terms under the square root sign. So the general solution is easily shown to be:  <code class="asciimath">#r = sqrt(n)/2 - 1/2#</code>  You should be weirded out now. If you aren’t, here’s a hint: what happens when #n = 10#? Here’s another hint: what happens as #n# approaches #oo#?</p>]]></description>
    <pubDate>Fri, 04 Dec 2015 01:22:52 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/high-dimensional-thought-experiment.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>
<item>
    <title>Behavioral Reflection</title>
    <link>https://derekelkins.github.io/posts/behavioral-reflection.html</link>
    <description><![CDATA[<h2 id="behavioral-reflection">Behavioral Reflection</h2>
<p>The ultimate goal of behavioral reflection (aka procedural reflection and no doubt other things) is to make a language where programs within the language are able to completely redefine the language as it executes. This is arguably the pinnacle of expressive power. This also means, though, local reasoning about code is utterly impossible, essentially by design.</p>
<p>Smalltalk is probably the language closest to this that is widely used. The Common Lisp MOP (Meta-Object Protocol) is also inspired by research in this vein. The ability to mutate classes and handle calls to missing methods as present in, e.g. Ruby, are also examples of very limited forms of behavioral reflection. (Though, for the latter, often the term “structural reflection” is used instead, reserving “behavioral reflection” for things beyond mere structural reflection.)</p>
<h3 id="very-brief-history">Very Brief History</h3>
<p>The seminal reference for behavioral reflection is Brian Smith’s 1982 <a href="http://publications.csail.mit.edu/lcs/specpub.php?id=840">thesis</a> on 3-LISP. This was followed by the languages <a href="http://cs.au.dk/~hosc/vol01/01-wand-friedman.html">Brown</a>, <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.40.2018&amp;rep=rep1&amp;type=pdf">Blond</a>, <a href="ftp://html.soic.indiana.edu/pub/techreports/TR362.pdf">Refci</a>, and <a href="http://www.is.ocha.ac.jp/~asai/Black/">Black</a> in chronological order. This is not a comprehensive list, and the last time I was in to this was about a decade ago. (Sure enough, there is some new work on Black and some very new citations of Black.)</p>
<!--[Reflection for the Masses](http://www.p-cos.net/documents/s32008.pdf) by Herzeel, Constanza, and D'Hondt.-->
<h3 id="core-idea">Core Idea</h3>
<p>The core idea is simply to expose the state of the (potentially conceptual) interpreter and allow it to be manipulated.</p>
<!--more-->
<p>From this perspective Scheme’s <code>call/cc</code> is a basic, limited example of behavioral reflection. It exposes one part of the state of the interpreter and allows it to be replaced. Delimited continuations (i.e. <code>shift</code> and <code>reset</code>) are a bit more powerful. They expose the same part of the state as <code>call/cc</code>, but they expose it in a more structured manner that allows more manipulations beyond merely replacing it. We could imagine representing the continuation with a less opaque object than a function which would lead to Smalltalk’s <code>MethodContext</code>.</p>
<p>Early Lisps’ fexpr was another example of exposing a different part of the interpreter state, namely the expression under evaluation. The <a href="https://web.cs.wpi.edu/~jshutt/kernel.html">Kernel</a> language explores this in more depth (among other things which can likely also be classified as forms of behavior reflection.)</p>
<p>For a language with mutation the heap would also be exposed. For a language without mutation, mutation can be added using the techniques from <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.43.8213&amp;rep=rep1&amp;type=pdf">Representing Monads</a> since something at least as powerful as delimited continuations will almost certainly be available. At that point, the heap would be first-class.</p>
<p>As an aside, I like to use the word “introspection” for purely read-only access to interpreter state, and reserve the word “reflection” for when manipulations are possible. Terminologically, “reflection” is also often broken down into “structural reflection” for the widely available ability to add and remove methods to classes and similar such operations; and “behavioral” or “procedural” reflection, the ability to manipulate the language itself. To control introspection and, at least, structural reflection, <a href="http://www.bracha.org/mirrors.pdf">mirrors</a> can be used.</p>
<!-- Reflective Tower -->
<h3 id="example">Example</h3>
<p>Making a simple behaviorally reflective language is actually pretty straightforward. If you have an abstract machine for your language, all you need to do is provide one additional primitive operation which gets passed the interpreter state and returns a new interpreter state. It may be clearer and cleaner, perhaps, to split this into two operations: one, often called <code>reify</code>, that provides the interpreter state as a value, and another, often called <code>reflect</code>, that sets the interpreter state to the state represented by the given value. Note that both <code>reify</code> and <code>reflect</code> are (very) impure operations. The more tedious part is marshalling the state of the interpreter into a language level object and vice versa. In the special case of a meta-circular interpreter, this part turns out to be trivial. The following interpreter is NOT meta-circular though.</p>
<p>The approach taken in this example, while simple, is very unstructured. For example, it is possible to write a procedure that when evaluated transforms the language from call-by-value (the CEK machine is an implementation of the CbV lambda calculus), to call-by name. However, to do this requires walking all the code in the environment and continuation and rewriting applications to force their first argument and delay their second argument. Primitives also need to be dealt with. It would be far nicer and cleaner to simply be able to say, “when you do an application, do this instead.” The newer behaviorally reflective languages work more like this.</p>
<p>Note, despite the fact that we do a global transformation, this is not an example of lack of expressiveness. We can define this transformation locally and execute it at run-time without coordination with the rest of the code. In this sense, everything is macro expressible (a la <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.51.4656&amp;rep=rep1&amp;type=pdf">Felleisen</a>) because arbitrary global transformations are macro expressible.</p>
<h3 id="the-code">The Code</h3>
<p>You can get a copy of the full version of the code from <a href="raw/CEK.hs">here</a>.</p>
<p>I arbitrarily decided to start from the CEK machine: an abstract machine for the untyped call-by-value lambda calculus. (CEK stands for Control-Environment-Kontinuation, these being the three pieces of interpreter state with control being the expression driving evaluation.) While a call-by-value language is probably the way to go because both <code>reify</code> and <code>reflect</code> are very impure operations (particularly <code>reflect</code>), the main motivation for choosing this machine was that the state components correspond in a direct way to concepts that are natural to the programmer. Compare this to the SECD machine which stands for Stack-Environment-Control-Dump.</p>
<p>The AST uses deBruijn indices.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span> 
    <span class="fu">=</span> <span class="dt">EVar</span> <span class="fu">!</span><span class="dt">Int</span> 
    <span class="fu">|</span> <span class="dt">ELam</span> <span class="dt">Expr</span> 
    <span class="fu">|</span> <span class="dt">Expr</span> <span class="fu">:@:</span> <span class="dt">Expr</span></code></pre></div>
<p>The only types of values we have are closures. The two additional pieces of interpreter state are the environment and the continuation (the call stack).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Value</span> <span class="fu">=</span> <span class="dt">Closure</span> <span class="dt">Expr</span> <span class="dt">Env</span>

<span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> [<span class="dt">Value</span>]

<span class="kw">data</span> <span class="dt">Kont</span> <span class="fu">=</span> <span class="dt">Done</span> <span class="fu">|</span> <span class="dt">Arg</span> <span class="dt">Expr</span> <span class="dt">Env</span> <span class="dt">Kont</span> <span class="fu">|</span> <span class="dt">Fun</span> <span class="dt">Value</span> <span class="dt">Kont</span></code></pre></div>
<p>Finally the evaluator is fairly straightforward, and is a straightforward transcription of the operational semantics. Evaluation starts off with the final contination and an empty environment. With a bit of inspection you can see that evaluation is call-by-value and proceeds left-to-right. Derive <code class="sourceCode haskell"><span class="dt">Show</span></code> for <code class="sourceCode haskell"><span class="dt">Expr</span></code> and <code class="sourceCode haskell"><span class="dt">Value</span></code> and these 15 lines of code are a complete interpreter.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">evaluate ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evaluate e <span class="fu">=</span> cek e [] <span class="dt">Done</span>

<span class="ot">cek ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Kont</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
cek (<span class="dt">EVar</span> i)  env                         k <span class="fu">=</span> cek e env&#39; k <span class="kw">where</span> <span class="dt">Closure</span> e env&#39; <span class="fu">=</span> env <span class="fu">!!</span> i
cek (f <span class="fu">:@:</span> x) env                         k <span class="fu">=</span> cek f env (<span class="dt">Arg</span> x env k)
cek (<span class="dt">ELam</span> b)  env                      <span class="dt">Done</span> <span class="fu">=</span> <span class="dt">Closure</span> b env
cek (<span class="dt">ELam</span> b)  env            (<span class="dt">Arg</span> x env&#39; k) <span class="fu">=</span> cek x env&#39; (<span class="dt">Fun</span> (<span class="dt">Closure</span> b env) k)
cek (<span class="dt">ELam</span> b)  env (<span class="dt">Fun</span> (<span class="dt">Closure</span> b&#39; env&#39;) k) <span class="fu">=</span> cek b&#39; (<span class="dt">Closure</span> b env<span class="fu">:</span>env&#39;) k</code></pre></div>
<p>The first stab at adding reflective features looks like this. We add the primitive operation to reify and reflect. We’ll require them to be wrapped in lambdas so the interpreter doesn’t have to deal with unevaluated arguments when interpreting them. Note that <code class="sourceCode haskell">reify</code> doesn’t pass the <code class="sourceCode haskell"><span class="dt">Expr</span></code> part to its argument. This is because the <code class="sourceCode haskell"><span class="dt">Expr</span></code> part would just be <code class="sourceCode haskell"><span class="dt">EReify</span></code>. The arguments of this particular application are stored, unevaluated, in the continuation as arguments needing to be evaluated. So, if we want to define <code class="sourceCode haskell">quote</code> which simply returns the expression representing it’s argument, we’ll have to dig into the continuation to get that argument.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span>
    <span class="fu">=</span> <span class="fu">...</span>
    <span class="fu">|</span> <span class="dt">EReify</span>
    <span class="fu">|</span> <span class="dt">EReflect</span>

<span class="co">-- reify f = f e k</span>
reify <span class="fu">=</span> <span class="dt">ELam</span> <span class="dt">EReify</span>

<span class="co">-- reflect c e k</span>
reflect <span class="fu">=</span> <span class="dt">ELam</span> (<span class="dt">ELam</span> (<span class="dt">ELam</span> <span class="dt">EReflect</span>))</code></pre></div>
<p>And here’s what we’d like to write in the interpreter (and is very close to what we ultimately will write.)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">cek ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Kont</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
<span class="fu">...</span>
cek <span class="dt">EReify</span>   (<span class="dt">Closure</span> b env&#39;<span class="fu">:</span>env) k <span class="fu">=</span> cek b (k<span class="fu">:</span>env<span class="fu">:</span>env&#39;) k
cek <span class="dt">EReflect</span> (k<span class="fu">:</span>e<span class="fu">:</span>c<span class="fu">:</span>_)            _ <span class="fu">=</span> cek c            e k</code></pre></div>
<p>There are two problems with this code: one minor and one major. The minor problem is that the argument to <code class="sourceCode haskell">reify</code> takes two arguments but we can’t just pass them directly to it. We need to follow our calling convention which expects to evaluate arguments one at a time. This problem is easily fixed by pushing an <code class="sourceCode haskell"><span class="dt">Arg</span></code> call stack frame onto the continuation to (trivially) evaluate the continuation.</p>
<p>The major problem is that this doesn’t type check. <code>c</code>, <code>e</code>, <code>env</code>, and <code>k</code> can’t simultaneously be <code class="sourceCode haskell"><span class="dt">Value</span></code>s and <code class="sourceCode haskell"><span class="dt">Expr</span></code>s, <code class="sourceCode haskell"><span class="dt">Env</span></code>s, and <code class="sourceCode haskell"><span class="dt">Kont</span></code>s. We need a way to embed and project <code class="sourceCode haskell"><span class="dt">Expr</span></code>, <code class="sourceCode haskell"><span class="dt">Env</span></code>, and <code class="sourceCode haskell"><span class="dt">Kont</span></code> value into and out of <code class="sourceCode haskell"><span class="dt">Value</span></code>. The embedding is easy; you just fold over the data structure and build up a lambda term representing the Church encoding. The projection from <code class="sourceCode haskell"><span class="dt">Value</span></code>s is… non-obvious, to say the least.</p>
<p>Instead of figuring that out, we can simply add <code class="sourceCode haskell"><span class="dt">Expr</span></code>, <code class="sourceCode haskell"><span class="dt">Env</span></code>, and <code class="sourceCode haskell"><span class="dt">Kont</span></code> to our language as primitive types. This is also, almost certainly, dramatically more efficient.</p>
<p>We extend our AST and <code class="sourceCode haskell"><span class="dt">Value</span></code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span>
    <span class="fu">=</span> <span class="fu">...</span>
    <span class="fu">|</span> <span class="dt">EInject</span> <span class="dt">Value</span>

<span class="co">-- Int so we can manipulate the EVar case.</span>
<span class="kw">data</span> <span class="dt">Value</span> <span class="fu">=</span> <span class="dt">Closure</span> <span class="dt">Expr</span> <span class="dt">Env</span> <span class="fu">|</span> <span class="dt">Int</span> <span class="fu">!</span><span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="fu">|</span> <span class="dt">Env</span> <span class="dt">Env</span> <span class="fu">|</span> <span class="dt">Kont</span> <span class="dt">Kont</span></code></pre></div>
<p>The changes to the interpreter are minimal. We need to change the <code class="sourceCode haskell"><span class="dt">EVar</span></code> case to handle the new kinds of values that can be returned and add a trivial <code class="sourceCode haskell"><span class="dt">EInject</span></code> case. Some cases can be omitted because they would only come up in programs that would “get stuck” anyway. (In our case, “getting stuck” means pattern match failure or index out of bounds.)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inject ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> (<span class="dt">Expr</span>, <span class="dt">Env</span>)
inject (<span class="dt">Closure</span> b env) <span class="fu">=</span> (<span class="dt">ELam</span> b, env)
inject v <span class="fu">=</span> (<span class="dt">EInject</span> v, [])
 
<span class="ot">cek ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Kont</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
cek (<span class="dt">EVar</span> i) env k <span class="fu">=</span> cek e env&#39; k <span class="kw">where</span> (e, env&#39;) <span class="fu">=</span> inject (env <span class="fu">!!</span> i)
<span class="fu">...</span>
cek <span class="dt">EReify</span> (<span class="dt">Closure</span> b env&#39;<span class="fu">:</span>env) k <span class="fu">=</span> cek b (<span class="dt">Env</span> env<span class="fu">:</span>env&#39;) (<span class="dt">Arg</span> (<span class="dt">EInject</span> (<span class="dt">Kont</span> k)) [] k)
cek <span class="dt">EReflect</span> (<span class="dt">Kont</span> k<span class="fu">:</span><span class="dt">Env</span> e<span class="fu">:</span><span class="dt">Expr</span> c<span class="fu">:</span>_) _ <span class="fu">=</span> cek c e k
cek (<span class="dt">EInject</span> v) _ <span class="dt">Done</span> <span class="fu">=</span> v
cek (<span class="dt">EInject</span> v) _ (<span class="dt">Fun</span> (<span class="dt">Closure</span> b&#39; env&#39;) k) <span class="fu">=</span> cek b&#39; (v<span class="fu">:</span>env&#39;) k</code></pre></div>
<p>While this interpreter achieves the goal, it is somewhat limited. We don’t have any means to manipulate the values of these new primitive types, so our manipulation of the interpreter state is limited to replacing a component, e.g. the environment, with some version of it that we got before via <code class="sourceCode haskell">reify</code>. Though it may be limited, it is not trivial. You can implement something close to call/cc if not call/cc itself.</p>
<p>Still, the scenario above of turning the language into a call-by-name language doesn’t seem possible. Modifying the interpreter to support primitive operations defined in Haskell is a simple matter of programming: you add a constructor for primitive operations to the AST, you make a very slight variant of the <code class="sourceCode haskell"><span class="dt">EInject</span></code> case in <code class="sourceCode haskell">cek</code>, and then you tediously make primitives corresponding to each constructor for each type and a fold for each type. See the linked <a href="raw/CEK.hs">source file</a> for the details.</p>
<p>The file additionally defines a pretty printer and a layer using parametric higher-order abstract syntax because humans are terrible with deBruijn indices. The end result is code that looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">one <span class="fu">=</span> _<span class="dt">Suc</span> <span class="fu">:@</span> _<span class="dt">Zero</span>

identity <span class="fu">=</span> lam (\x <span class="ot">-&gt;</span> x)

loop <span class="fu">=</span> lam (\x <span class="ot">-&gt;</span> x <span class="fu">:@</span> x) <span class="fu">:@</span> lam (\x <span class="ot">-&gt;</span> x <span class="fu">:@</span> x)

tailEnv <span class="fu">=</span> lam (\e <span class="ot">-&gt;</span> paraEnv <span class="fu">:@</span> e <span class="fu">:@</span> _<span class="dt">Nil</span> 
                                  <span class="fu">:@</span> lam (\_ <span class="ot">-&gt;</span> lam (\x <span class="ot">-&gt;</span> lam (\_ <span class="ot">-&gt;</span> x))))

tailKont <span class="fu">=</span> lam (\k <span class="ot">-&gt;</span> paraKont <span class="fu">:@</span> k <span class="fu">:@</span> _<span class="dt">Done</span>
                                    <span class="fu">:@</span> lam (\_ <span class="ot">-&gt;</span> lam (\_ <span class="ot">-&gt;</span> lam (\x <span class="ot">-&gt;</span> lam (\_ <span class="ot">-&gt;</span> x))))
                                    <span class="fu">:@</span> lam (\_ <span class="ot">-&gt;</span> lam (\x <span class="ot">-&gt;</span> lam (\_ <span class="ot">-&gt;</span> x))))

eval <span class="fu">=</span> lam (\c <span class="ot">-&gt;</span> reify <span class="fu">:@</span> lam (\e <span class="ot">-&gt;</span> lam (\k <span class="ot">-&gt;</span> reflect <span class="fu">:@</span> c <span class="fu">:@</span> (tailEnv <span class="fu">:@</span> e) <span class="fu">:@</span> k)))

quote <span class="fu">=</span> reify <span class="fu">:@</span> lam (\e <span class="ot">-&gt;</span> lam (\k <span class="ot">-&gt;</span> reflect <span class="fu">:@</span> (_<span class="dt">Inject</span> <span class="fu">:@</span> c k) <span class="fu">:@</span> e <span class="fu">:@</span> (tailKont <span class="fu">:@</span> k)))
    <span class="kw">where</span> c k <span class="fu">=</span> paraKont <span class="fu">:@</span> k <span class="fu">:@</span> garbage 
                              <span class="fu">:@</span> lam (\x <span class="ot">-&gt;</span> (lam (\_ <span class="ot">-&gt;</span> lam (\_ <span class="ot">-&gt;</span> lam (\_ <span class="ot">-&gt;</span> x))))) 
                              <span class="fu">:@</span> lam (\_ <span class="ot">-&gt;</span> lam (\_ <span class="ot">-&gt;</span> lam (\_ <span class="ot">-&gt;</span> garbage)))
          garbage <span class="fu">=</span> _<span class="dt">Inject</span> <span class="fu">:@</span> _<span class="dt">Zero</span>

callCC <span class="fu">=</span> lam (\f <span class="ot">-&gt;</span> reify <span class="fu">:@</span> lam (\e <span class="ot">-&gt;</span> lam (\k <span class="ot">-&gt;</span> 
            f <span class="fu">:@</span> lam (\a <span class="ot">-&gt;</span> reflect <span class="fu">:@</span> (_<span class="dt">Inject</span> <span class="fu">:@</span> a) <span class="fu">:@</span> (tailEnv <span class="fu">:@</span> e) <span class="fu">:@</span> k))))

example1 <span class="fu">=</span> evaluate <span class="fu">$</span> quote <span class="fu">:@</span> loop <span class="co">-- output looks like: Expr ((\a -&gt; a a) (\a -&gt; a a))</span>
example2 <span class="fu">=</span> evaluate <span class="fu">$</span> eval <span class="fu">:@</span> (quote <span class="fu">:@</span> loop) <span class="co">-- loops forever</span>
example3 <span class="fu">=</span> evaluate <span class="fu">$</span> callCC <span class="fu">:@</span> lam (\k <span class="ot">-&gt;</span> k <span class="fu">:@</span> one <span class="fu">:@</span> loop) <span class="co">-- escape before evaluating the loop</span>
example4 <span class="fu">=</span> evaluate <span class="fu">$</span> callCC <span class="fu">:@</span> lam (\k <span class="ot">-&gt;</span> lam (\_ <span class="ot">-&gt;</span> loop) <span class="fu">:@</span> (k <span class="fu">:@</span> one)) <span class="co">-- also escape before the loop</span></code></pre></div>]]></description>
    <pubDate>Tue, 17 Nov 2015 00:54:35 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/behavioral-reflection.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>
<item>
    <title>You know more about presheaves than you think</title>
    <link>https://derekelkins.github.io/posts/you-know-more-about-presheaves-than-you-think.html</link>
    <description><![CDATA[<h3 id="the-category-of-graphs-as-a-presheaf">The category of graphs as a presheaf</h3>
<p>Here’s a small example of why people find category theory interesting. Consider the category, call it |ccC|, consisting of two objects, which we’ll imaginatively name |0| and |1|, and two non-identity arrows |s,t : 0 -&gt; 1|. The category of graphs (specifically directed multigraphs with loops) is the category of presheaves over |ccC|, which is to say, it’s the category of contravariant functors from |ccC| to <code class="asciimath">|cc&quot;Set&quot;|</code>. I’ll spell out what that means momentarily, but first think about what has been done. We’ve provided a complete definition of not only graphs but the entire category of graphs and graph homomorphisms given you’re familiar with very basic category theory<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. This is somewhat magical.</p>
<p>Spelling things out, |G| is a contravariant functor from |ccC| to <code class="asciimath">|cc&quot;Set&quot;|</code>. This means that |G| takes each object of |ccC| to a set, i.e. |G(0) = V| and |G(1) = E| for arbitrary sets |V| and |E|, but which will represent the vertices and edges of our graph. In addition, |G| takes the arrows in |ccC| to a (set) function, but, because it’s contravariant, it flips the arrows around. So we have, for example, |G(s) : G(1) -&gt; G(0)| or |G(s) : E -&gt; V|, and similarly for |t|. |G(s)| is a function that takes an edge and gives its source vertex, and |G(t)| gives the target. The arrows in the category of graphs are just natural transformations between the functors. In this case, that means if we have two graphs |G| and |H|, a graph homomorphism |f : G -&gt; H| is a pair of functions |f_0 : G(0) -&gt; H(0)| and |f_1 : G(1) -&gt; H(1)| that satisfy |H(s) @ f_1 = f_0 @ G(s)| and |H(t) @ f_1 = f_0 @ G(t)|. With a bit of thought you can see that all this says is that we must map the source and target of an edge |e| to the source and target of the edge |f_1(e)|. You may also have noticed that <em>any</em> pair of sets and pair of functions between them is a graph. In other words, graphs are very simple things. This takes out a lot of the magic, though it is nice that we get the right notion of graph homomorphism for free. Let me turn the magic up to 11.</p>
<!--more-->
<p>Presheaves are extremely important in category theory, so categorists know a lot about them. It turns out that they have a lot of structure (mostly because <code class="asciimath">|cc&quot;Set&quot;|</code> has a lot of structure). In particular, in the categorical jargon, if |ccC| is small (and finite is definitely small), then the category of presheaves over |ccC| is a complete and cocomplete elementary topos with a natural number object. For those of you learning category theory who’ve gotten beyond the basics, proving this is a <em>very</em> good and important exercise. In programmer-speak, that says we can do dependently typed lambda calculus with algebraic data and codata types in that category. To be clear, this is not saying we have a lambda calculus with a graph type. It’s saying we have a lambda calculus where <em>all</em> our types have graph structure.</p>
<h3 id="beyond-graphs">Beyond graphs</h3>
<p>But set that aside for now. This isn’t an article about graphs so let’s start generalizing away from them. We’ll start with a baby step. You can probably guess how we’d go about making edge labeled graphs. We’d add another object to |ccC|, say |2|, and an arrow from |2| to |1|, call it |l_e| — remember that the arrows are “backwards” because presheaves are contravariant. You may start seeing a pattern already. One way to start formalizing that pattern is to say for every object of |ccC| we have an abstract data type with a field for each arrow into that object. In our example, |1| has three arrows into it, namely |s|, |t|, and |l_e|. We can view an element |e in F(1)| for a presheaf |F| as having fields <code>e.s</code>, <code>e.t</code> and <code>e.l_e</code>. Since <code class="asciimath">|cc&quot;Set&quot;|</code> has (non-constructive, non-computable) decidable equality for everything, we can tell |e| from |e’| even if <code>e.s = e'.s</code> and <code>e.t = e'.t</code> and <code>e.l_e = e'.l_e</code>. This is different from a normal abstract data type (in a purely functional language) where an abstract data type with three fields would be isomorphic to a 3-tuple. The extra ability to differentiate them could be modeled by having a fourth field that returned something that could only be compared for equality, kind of like <a href="https://hackage.haskell.org/package/base/docs/Data-Unique.html">Data.Unique</a> (ignoring the <code>Ord</code> instance…) It may look like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Vertex</span> <span class="co">-- abstract</span>
<span class="ot">vertexId ::</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Unique</span>

<span class="kw">data</span> <span class="dt">Label</span> <span class="co">-- abstract</span>
<span class="ot">labelId ::</span> <span class="dt">Label</span> <span class="ot">-&gt;</span> <span class="dt">Unique</span>

<span class="kw">data</span> <span class="dt">Edge</span> <span class="co">-- abstract</span>
<span class="ot">edgeId ::</span> <span class="dt">Edge</span> <span class="ot">-&gt;</span> <span class="dt">Unique</span>
<span class="ot">src ::</span> <span class="dt">Edge</span> <span class="ot">-&gt;</span> <span class="dt">Vertex</span>
<span class="ot">tgt ::</span> <span class="dt">Edge</span> <span class="ot">-&gt;</span> <span class="dt">Vertex</span>
<span class="ot">label ::</span> <span class="dt">Edge</span> <span class="ot">-&gt;</span> <span class="dt">Label</span></code></pre></div>
<p>Of course, if these are literally all the functions we have for these types (plus some constants otherwise we can’t make anything), then these abstract types might as well be records. Anything else they have is unobservable and thus superfluous.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Vertex</span> <span class="fu">=</span> <span class="dt">Vertex</span> {<span class="ot"> vertexId ::</span> <span class="dt">Unique</span> }

<span class="kw">data</span> <span class="dt">EdgeLabel</span> <span class="fu">=</span> <span class="dt">EdgeLabel</span> {<span class="ot"> edgeLabelId ::</span> <span class="dt">Unique</span> }

<span class="kw">data</span> <span class="dt">Edge</span> <span class="fu">=</span> <span class="dt">Edge</span> { 
<span class="ot">    edgeId ::</span> <span class="dt">Unique</span>, 
<span class="ot">    src ::</span> <span class="dt">Vertex</span>, 
<span class="ot">    tgt ::</span> <span class="dt">Vertex</span>,
<span class="ot">    edgeLabel ::</span> <span class="dt">EdgeLabel</span>
}</code></pre></div>
<p>This starts to suggest that we can just turn each object in our category |ccC| into a record with an ID field. Each arrow in to that object becomes an additional field. This almost works. We’ll come back to this, but let’s take another baby step.</p>
<p>Something a bit more interesting happens if we want to label the vertices. We proceed as before: add another object, call it |3|, and another arrow |l_v : 3 -&gt; 0|. This time, though, we’re not finished. |ccC| is supposed to be a category, so we can compose arrows and thus we have two composites but no arrow for the composites to be, namely: |s @ l_v| and |t @ l_v|. The abstract data type intuition suggests that whenever we run into this situation, we should add a distinct arrow for each composite. For the purpose of labeling vertices, this is the right way to go: we want to think of each vertex as having a vertex label field with no constraints. There is, however, another choice. We could add <em>one</em> new arrow and have both composites be equal to it. What that would say is that for every edge, the source and the target vertices must have the same label. It’s easy to see that that would lead to every vertex in a connected component having the same label. In code, the former choice would look like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">VertexLabel</span> <span class="fu">=</span> <span class="dt">VertexLabel</span> {<span class="ot"> vertexLabelId ::</span> <span class="dt">Unique</span> }

<span class="kw">data</span> <span class="dt">Vertex</span> <span class="fu">=</span> <span class="dt">Vertex</span> { 
<span class="ot">    vertexId ::</span> <span class="dt">Unique</span>,
<span class="ot">    vertexLabel ::</span> <span class="dt">VertexLabel</span>
}

<span class="kw">data</span> <span class="dt">EdgeLabel</span> <span class="fu">=</span> <span class="dt">EdgeLabel</span> {<span class="ot"> edgeLabelId ::</span> <span class="dt">Unique</span> }

<span class="kw">data</span> <span class="dt">Edge</span> <span class="fu">=</span> <span class="dt">Edge</span> { 
<span class="ot">    edgeId ::</span> <span class="dt">Unique</span>, 
<span class="ot">    src ::</span> <span class="dt">Vertex</span>, 
<span class="ot">    tgt ::</span> <span class="dt">Vertex</span>,
<span class="ot">    edgeLabel ::</span> <span class="dt">EdgeLabel</span>
    <span class="co">-- With our earlier &quot;rule&quot; to add a field for each arrow</span>
    <span class="co">-- we should also have:</span>
    <span class="co">--    srcVertexLabel :: VertexLabel</span>
    <span class="co">--    tgtVertexLabel :: VertexLabel</span>
    <span class="co">-- but, by definition, these are:</span>
    <span class="co">--    vertexLabel . src and</span>
    <span class="co">--    vertexLabel . tgt respectively.</span>
    <span class="co">-- So we don&#39;t explicitly add a field for composite arrows.</span>
}</code></pre></div>
<p>The latter choice would look the same, except there would be an extra constraint that we can’t capture in Haskell, namely <code class="sourceCode haskell">vertexLabel <span class="fu">.</span> src <span class="fu">==</span> vertexLabel <span class="fu">.</span> tgt</code>.</p>
<p>If we stick to the abstract data type intuition and we have a cycle in the arrows in |ccC|, then the requirement to add a distinct arrow for each composite means we need to add a countably infinite number of arrows, so |ccC| is no longer finite. It is still “small” though, so that’s no problem. We could say we have a finite <em>graph</em> of the non-composite arrows and possibly some equations like |s @ l_v = t @ l_v| and we generate a category from that graph subject to those equations by adding in all composites as necessary. We will use the arrows in this graph to decide on the fields for our abstract data types, rather than the arrows in the category so we don’t end up with an infinity of fields in our data types. Even when there aren’t an infinite number of arrows in our category, this is still useful since we aren’t going to add a field to our edges to hold each vertex’s label, since we can just get the vertex and then get the label.</p>
<p>Some of you have probably thought of another more appropriate intuition. A presheaf is a database. The category which our presheaf is over, what we’ve been calling |ccC| <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> is sort of like a schema. You don’t specify types, but you do specify foreign key relationships plus some additional integrity constraints that don’t fit in to the typical ones supported by databases.</p>
<h3 id="presheaves-as-databases">Presheaves as databases</h3>
<p>For our earlier example:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> VertexLabel (<span class="kw">Id</span> uniqueidentifier <span class="kw">PRIMARY</span> <span class="kw">KEY</span>);
<span class="kw">CREATE</span> Vertex (
    <span class="kw">Id</span> uniqueidentifier <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,
    <span class="kw">Label</span> uniqueidentifier <span class="kw">REFERENCES</span> VertexLabel(<span class="kw">Id</span>)
);
<span class="kw">CREATE</span> EdgeLabel (<span class="kw">Id</span> uniqueidentifier <span class="kw">PRIMARY</span> <span class="kw">KEY</span>);
<span class="kw">CREATE</span> Edge (
    <span class="kw">Id</span> uniqueidentifier <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,
    Src uniqueidentifier <span class="kw">REFERENCES</span> VertexLabel(<span class="kw">Id</span>),
    Tgt uniqueidentifier <span class="kw">REFERENCES</span> VertexLabel(<span class="kw">Id</span>),
    <span class="kw">Label</span> uniqueidentifier <span class="kw">REFERENCES</span> EdgeLabel(<span class="kw">Id</span>)
    <span class="co">-- Nothing stops us from having additional columns here and elsewhere</span>
    <span class="co">-- corresponding to the fact that our types were really abstract data</span>
    <span class="co">-- types in the Haskell, and to the fact that we can choose an arbitrary</span>
    <span class="co">-- set as long as it has at least this much structure.  They won&#39;t be</span>
    <span class="co">-- preserved by &quot;homomorphisms&quot; though.</span>
);</code></pre></div>
<p>To be clear, each presheaf corresponds to a database <em>with data</em>. Inserting a row into a table is a homomorphism of presheaves, but so is adding a (not preserved by homomorphism) column. The schema above corresponds to the |ccC| part of the presheaf.</p>
<p>If we had made that second choice before where we had only <em>one</em> arrow back that would lead to the following integrity constraint:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">NOT</span> <span class="kw">EXISTS</span>(<span class="kw">SELECT</span> *
           <span class="kw">FROM</span> Edge e
           <span class="kw">JOIN</span> Vertex src <span class="kw">ON</span> e.Src = src.Id
           <span class="kw">JOIN</span> Vertex tgt <span class="kw">ON</span> e.Tgt = tgt.Id
           <span class="kw">WHERE</span> src.Label &lt;&gt; tgt.Label)</code></pre></div>
<p>It turns out this intuition is completely general. You can actually think of all of presheaf theory as a (slightly unusual) database theory. More objects just means more tables. More arrows means more foreign keys and potentially additional integrity constraints. It’s not exactly relational though. In fact, in some ways it’s a bit closer to SQL<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> or object databases. You can turn this around too going back to the point at the beginning. Whether or not we can think of <em>all</em> presheaves like databases or all databases like presheaves, we can certainly think of <em>this</em> example, and many like it, as presheaves. This means for many “databases”, we can talk about doing dependently typed programming where our types <em>are</em> databases of the given shape. This also dramatically shifts the focus in database theory from databases to database migrations, i.e. homomorphisms of databases.</p>
<p>David Spivak is the one who has done the most on this, so I’ll refer you to his <a href="http://math.mit.edu/~dspivak/informatics/pure/">work</a>. He also has a better story for schemas that are much closer to normal schemas. I’ll end as I began:</p>
<p>Here’s a small example of why people find category theory interesting.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>“very basic category theory” means knowing the definitions of categories, isomorphisms, functors, and natural transformations<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>remember the presheaf is the <em>functor</em> from |ccC^(op) -&gt; cc“Set”|<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>SQL is hardly the relational ideal<a href="#fnref3">↩</a></p></li>
</ol>
</div>]]></description>
    <pubDate>Mon, 02 Nov 2015 12:04:45 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/you-know-more-about-presheaves-than-you-think.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>
<item>
    <title>The three styles of category theory</title>
    <link>https://derekelkins.github.io/posts/styles-of-category-theory.html</link>
    <description><![CDATA[<h3 id="introduction">Introduction</h3>
<p>Arguably (1-)category theory is the study of universal properties. There are three standard formulations of the notion of universal property which are all equivalent. Most introductions to category theory will cover all three and how they relate. By systematically preferring one formulation above the others, three styles of doing category theory arise with distinctive constructions and proof styles.</p>
<p>I noticed this trichotomy many years ago, but I haven’t heard anyone explicitly identify and compare these styles. Furthermore, in my opinion, one of these styles, the one I call <strong>Set</strong>-category theory, is significantly easier to use than the others, but seems poorly represented in introductions to category theory.</p>
<p>For myself, it wasn’t until I read <a href="http://www.tac.mta.ca/tac/reprints/articles/10/tr10abs.html">Basic Concepts of Enriched Category Theory</a> by G. M. Kelly and was introduced to indexed (co)limits (aka weighted (co)limits), that I began to recognize and appreciate <strong>Set</strong>-category theory. Indexed (co)limits are virtually absent from category theory introductions, and the closely related notion of (co)ends are also very weakly represented despite being far more useful than (conical) (co)limits. I don’t know why this is. Below I’ll be more focused on comparing the styles than illustrating the usefulness of indexed (co)limits. I may write an article about that in the future; in the mean time you can read “Basic Concepts of Enriched Category Theory” and just ignore the enriched aspect. Admittedly, it is definitely <em>not</em> an introduction to category theory.</p>
<!--more-->
<h3 id="universality">Universality</h3>
<p>What follows are three equivalent formulations of the notion of universal property including proofs of equivalence.</p>
<h4 id="initiality">Initiality</h4>
<p>Initiality is by far the simplest formulation of universal properties to understand because it is a very special case, albeit a special case that can be finagled to cover the general case.</p>
<p>An object, typically denoted |0|, is <strong>initial</strong> iff for every object in the category there exists a unique arrow from |0|. If |A| is an object in the category, we can write |(:A:) : 0 -&gt; A| for the unique arrow.</p>
<h4 id="representability">Representability</h4>
<p>Representability isn’t as simple or intuitive as initiality, but it is still pretty simple.</p>
<p>A functor |F : C^(op) -&gt; Set| is <strong>representable</strong> iff |F ~= Hom(-,Y)| for some |Y|. Note that this is an isomorphism between functors, i.e. a natural isomorphism. We say |Y| <strong>represents</strong> the functor |F|. A functor |G : C -&gt; Set| is <strong>co-representable</strong> iff |G ~= Hom(X,-)| for some |X|. Similarly we say |X| <strong>(co-)represents</strong> the functor |G|. Representable and co-representable aren’t actually different; if we set |D = C^(op)| then we could say |F| is co-representable as a functor from |D| and it would mean the same thing.</p>
<p>Now we need to prove initiality and (co-)representability equivalent. One direction is easy, |0| co-represents the functor |lambda C . {**}|.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> It’s easy to show that this says exactly that |0| is initial.</p>
<p>I’ll hold off on the other direction and instead prove the circular implication: <strong>Representability</strong> |=&gt;| <strong>Initiality</strong> |=&gt;| <strong>Universal Arrow</strong> |=&gt;| <strong>Representability</strong>. Right now we’ve done the first step; we can recast initiality as representability. Next we’ll show that we can recast universal arrows as initiality and representability as a universal arrow and we’ll have shown them all equivalent.</p>
<h4 id="universal-arrow">Universal arrow</h4>
<p>Let |U : C -&gt; D| be a functor. |eta : A -&gt; UX| is a <strong>universal arrow</strong> iff for all |f : A -&gt; UY| there exists a unique arrow |(:f:) : X -&gt; Y| such that |f = U(:f:) @ eta|. Dually, let |F : C -&gt; D| be a functor, then |epsilon : FX -&gt; A| is a <strong>co-universal arrow</strong> iff for all |g : FY -&gt; A| there exists a unique arrow |(:g:) : Y -&gt; X| such that |g = epsilon @ F(:g:)|. Again, these are equivalent notions. A co-universal arrow is just a universal arrow in the opposite category.</p>
<p>Now to prove <strong>Initiality</strong> |=&gt;| <strong>Universal Arrow</strong>. Consider the (comma) category whose objects are pairs |(f, Y)| where |f : A -&gt; UY| and whose arrows |k : (f, Y) -&gt; (g, Z)| are arrows |k : Y -&gt; Z| such that |g = Uk @ f|. |eta| is a universal arrow iff |(eta, X)| is initial in this category. This is easy to check.</p>
<p>Finally, <strong>Universal Arrow</strong> |=&gt;| <strong>Representability</strong>. Let |G : C -&gt; Set|. The claim is there exists a universal arrow <code class="asciimath">|eta : {**} -&gt; GX|</code> iff |X| co-represents |G|. Doing the backwards direction first, if |X| co-represents |G| then there is an element of |GX| that corresponds to |id : X -&gt; X|. Have |eta| pick out that element. Given another element |y : {**} -&gt; GY| we need to find a unique arrow |(:y:) : X -&gt; Y| such that |G(:y:)(eta) = y|. Naturality of the isomorphism making |X| co-represent |G| says: |f @ phi_A(a) = phi_B(Gf(a))| where |phi : G ~= Hom(X,-)|, |f : A -&gt; B|, and |a in GA|. Applying |phi_Y| to both sides of the earlier equation and using |phi_X(eta) = id| we get: |(:y:) = phi_Y(y)| showing that |(:y:)| exists and is unique and thus |eta| is a universal arrow.</p>
<p>Next we need to show that |eta : {**} -&gt; GX| being a universal arrow implies that |X| co-represents |G|. We immediately have a parameterized bijection namely |(: - :)_Y : GY ~= Hom(X,Y)|. All we need to do is show that it is natural in |Y| which is to say |f @ (:a:)_A = (:Gf(a):)_B| where |f : A -&gt; B|. We have |Gf(a) = Gf(G(:a:)(eta)) = (Gf @ G(:a:))(eta) = G(f @ (:a:))(eta)|. Using |f = (:Gf(eta):)_B| which is a consequence of |eta| being universal, we get |(:Gf(a):)_B = f @ (:a:)_A| as desired.</p>
<h3 id="initiality-1">Initiality</h3>
<p>In the initiality style of doing category theory, the main exercise is defining an appropriate category. This is pretty difficult from both a creativity perspective and a notational perspective. Once an appropriate category is defined, though, the proofs are typically not too hard. Perhaps the main tool is the comma category as that allows the compact and flexible specification of many categories, though it can often take a touch of creativity to recognize a category as a comma category. Technically, the proof above implies that for any universal property there’s an appropriate comma category in which the universal object is the initial object.</p>
<p>This style is often seen in introductions to category theory. If you’ve ever read about categories of (co)cones or wedges, then you’ve seen an example of this style with an ad-hoc definition of the relevant categories. In practice, the categories needed to characterize a specific universal property are of little interest on their own so the effort spent defining them isn’t repaid. The main exception is the category of |F|-algebras for some functor |F|. (Incidentally, the category of |F|-algebras is a full subcategory of a comma category.)</p>
<p>The style of proof is to leverage the uniqueness of the mediating morphism to equate two seemingly different things. Lambek’s lemma is an excellent illustration of this proof style.</p>
<h3 id="set-category-theory"><strong>Set</strong>-category theory</h3>
<p>The core of this style of category theory is representability and its parameterized variant. Representability alone is already very powerful and ergonomic. Every limit or colimit in a category represents a limit of homsets. This means all the tools and intuitions of set theory are available. This is the basis for my naming of this style: we elucidate the structure of a category by relating it to the structure of the category of sets.</p>
<p>The main tools of this style are (co)ends, indexed (co)limits, and adjunctions in the form |Hom(FA,B) ~= Hom(A,UB)|. In particular, the intimate connection between ends/indexed limits and sets of natural transformations significantly eases moving up and down functor categories.</p>
<p>By far the best part of this approach is the style of proof. By leveraging continuity properties, characterizations in terms of (parameterized) representability, some general isomorphisms, and occasionally some hand-crafted isomorphisms, nearly any categorical theorem can be proven in a dozen or less isomorphisms. The presentation looks and feels very much like solving an algebraic equation. The proofs are easy to read and easy to write.</p>
<p>The main drawback of this style is that most of the properties above weaken and some disappear when working in enriched or higher categories.</p>
<h3 id="cat-category-theory"><strong>Cat</strong>-category theory</h3>
<p>Arguably, this style should be based on universal arrows. While it technically is, in practice, it’s rare that one talks about universal arrows and instead the parameterized version, namely adjunctions in their unit/counit formulation are the main tool. After adjunctions would be Kan extensions. All of these are concepts that live naturally at the level of 2-categories which makes them much easier to generalize.</p>
<p>The main style of proof is diagram chasing, i.e. proving typically several equalities. On the one hand, proving an equation is straight-forward equational reasoning; on the other hand, there tend to be several equations that need to be proven at a time, they tend to be fine-grained and thus detailed and tedious, and often general results don’t obviously apply. The solution to most of these problems is to use string diagrams instead. Many of the bureaucratic details completely disappear and the proofs become crystal clear. A wonderful example of this style of proof is proving that an adjunction gives rise to a monad. With normal diagram chasing it’s mildly tedious. With string diagrams it proves itself.</p>
<p>One issue that comes up in this style is the elegant definitions tend to be wholesale. For example, there’s a nice adjunction that characterizes all limits of any given shape. Unfortunately, the adjunction only exists if all the limits of that shape exists. If they don’t all exist, then you need to use some other method to talk about the limits that do exist. Technically, universal arrows could handle this, but usually representability is used instead.</p>
<!-- ### Yoneda-->
<h3 id="conclusion">Conclusion</h3>
<p>Ultimately, one should become familiar with all these approaches. There are definitely problems that fit nicer in some than others. However, when it comes to universal properties the <strong>Set</strong>-category theory wins hands down. <strong>Cat</strong>-category theory tends to be more useful when working with structures that aren’t characterized by a universal property such as monoidal structure. Initiality has its niche with initial algebras. I don’t have any ideas on where it might also be a profitable perspective. In fact, I’m not completely sure it’s a good thing that we think about initial algebras as initial algebras. There are interesting interactions between initial algebras and adjunctions for example and it’s not clear to me that they wouldn’t be more accessible with a different presentation of initial algebras.</p>
<h3 id="texts-illustrating-these-approaches">Texts illustrating these approaches</h3>
<ul>
<li>Representatives of initiality:
<ul>
<li><a href="http://maartenfokkinga.github.io/utwente/mmf92b.pdf">A Gentle Introduction to Category Theory – the calculational approach –</a> by Maarten Fokkinga</li>
</ul></li>
<li>Representatives of <strong>Set</strong>-category theory:
<ul>
<li><a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/WGP10.pdf">Reason Isomorphically!</a> by Ralf Hinze</li>
<li><a href="http://arxiv.org/abs/1501.02503">This is the (co)end, my only (co)friend</a> by Fosco Loregian</li>
<li><a href="http://www.tac.mta.ca/tac/reprints/articles/10/tr10abs.html">Basic Concepts of Enriched Category Theory</a> by G. M. Kelly</li>
</ul></li>
<li>Representatives of <strong>Cat</strong>-category theory:
<ul>
<li><a href="http://www.dcs.ed.ac.uk/home/dt/CT/categories.pdf">Category Theory Lecture Notes</a> by Daniele Turi</li>
</ul></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>|{**}| is just some singleton set.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></description>
    <pubDate>Wed, 30 Sep 2015 05:45:11 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/styles-of-category-theory.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>
<item>
    <title>Differentiation under the integral</title>
    <link>https://derekelkins.github.io/posts/differentiation-under-the-integral.html</link>
    <description><![CDATA[<p><a href="raw/DiffUnderIntegral.pdf">Here</a> is a PDF with an informal proof of a very general form of <a href="https://en.wikipedia.org/wiki/Differentiation_under_the_integral_sign">differentiation under the integral</a>.</p>
<p>It’s formulated using geometric algebra and provides a simple demonstration of using some of the basic identities in geometric calculus.</p>
<p>The end result is:</p>
<p><img src="raw/diff-under-integral.svg" alt="d/(dt) int_(D(t)) L_t(x; d^m x) = int_(D(t)) dot L_t(x; (d^m x ^^ (del x)/(del t)) * dot grad_x) + int_(del D(t)) L_t(x; d^(m-1) x ^^ (del x)/(del t)) + int_(D(t))(del L_t(x; d^m x))/(del t)"></img></p>
<!--
> `#d/(dt) int_(cc"D"(t)) bb"L"_t(bb"x"; d^m bb"x") 
>    = int_(cc"D"(t)) dot bb"L"_t(bb"x"; (d^m bb"x" ^^ (del x)/(del t)) * dot grad_(bb"x"))#
>  # + int_(del cc"D"(t)) bb"L"_t(bb"x"; d^(m-1) bb"x" ^^ (del x)/(del t))#
>  # + int_(cc"D"(t))(del bb"L"_t(bb"x"; d^m bb"x"))/(del t)#`{.asciimath}
-->]]></description>
    <pubDate>Mon, 14 Sep 2015 07:53:29 UT</pubDate>
    <guid>https://derekelkins.github.io/posts/differentiation-under-the-integral.html</guid>
    <dc:creator>Derek Elkins</dc:creator>
</item>

    </channel>
</rss>
