<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="A blog mostly on math, physics, and computer science.">
    <meta name="author" content="Derek Elkins">
    <!--<link rel="icon" href="/images/favicon.ico">-->

    <title>Recursive Helping</title>
    <!-- Bootstrap core CSS -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom styles for this template -->
    <link href="../css/blog.css" rel="stylesheet">
    <link href="../css/syntax.css" rel="stylesheet">
  </head>

  <body>
    <div class="blog-masthead">
      <div class="container">
        <nav class="blog-nav">
          <a class="blog-nav-item " href="../">Home</a>
          <a class="blog-nav-item " href="../about.html">About</a>
          <a class="blog-nav-item " href="../contact.html">Contact</a>
          <a class="blog-nav-item " href="../readinglist.html">Reading List</a>
          <a class="blog-nav-item " href="../archive.html">Archive</a>
          <a class="blog-nav-item pull-right" href="../rss.xml">RSS</a>
          <a class="blog-nav-item pull-right" href="../atom.xml">Atom</a>
        </nav>
      </div>
    </div>

    <div class="container">
      
      
      <div class="row">
        
        <div class="col-sm-12 blog-main">
        
          <div class="blog-post">
    <h2 class="blog-post-title" style="margin-top: 30px;">Recursive Helping</h2>
    <p class="blog-post-meta">April 30, 2020 06:06 UTC 
        
        (Last updated on April 30, 2020 06:07 UTC)
    </p>
    <h6 class="blog-post-meta">
        
        Tags: <a title="All pages tagged 'programming'." href="../tags/programming.html">programming</a>, <a title="All pages tagged 'concurrency'." href="../tags/concurrency.html">concurrency</a>
        
    </h6>

    <h2 id="introduction">Introduction</h2>
<p>Recursive helping is a technique for implementing lock-free concurrent data structures and algorithms. I’m going to illustrate this in the case of implementing a multi-variable compare-and-swap (MCAS) in terms of a single variable compare-and-swap. Basically everything I’m going to talk about comes from Keir Fraser’s PhD Thesis, <a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.html">Practical Lock-Freedom</a> (2004) which I <strong>strongly</strong> recommend. Fraser’s thesis goes much further than this, e.g. fine-grained lock-free implementations of software transactional memory (STM)<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Fraser went on to contribute to the initial implementations of STM in Haskell, though his thesis uses C++.</p>
<!--more-->
<p>First, some prerequisites.</p>
<h2 id="terms">Terms</h2>
<p>I imagine most developers when they hear the term “lock-free” take it to mean a concurrent algorithm implemented without using locks. It, however, has a technical definition. Assuming a concurrent application is functionally correct, e.g. it does the right thing if it terminates no matter how things are scheduled, we still have three liveness problems in decreasing order of severity:</p>
<ul>
<li><strong>Deadlock</strong> - the application getting stuck in state where no subprocesses can be scheduled</li>
<li><strong>Livelock</strong> - the application fails to make progress despite subprocesses being scheduled, e.g. endlessly retrying</li>
<li><strong>Starvation</strong> - some subprocesses never make progress even though the application as a whole makes progress</li>
</ul>
<p>In parallel, we have three properties corresponding to programs that cannot exhibit the above behaviors:</p>
<ul>
<li><strong>Obstruction-free</strong> - no deadlock, you’ll get this if you don’t use locks</li>
<li><strong>Lock-free</strong> - obstruction-free and no livelock</li>
<li><strong>Wait-free</strong> - lock-free and no starvation</li>
</ul>
<p>Wait-freedom is the most desirable property but was difficult to achieve with reasonable efficiency. However, <a href="https://dl.acm.org/doi/10.1145/2692916.2555261">relatively recent techniques</a> (2014) may do for wait-free algorithms what Fraser’s thesis did for lock-free algorithms, namely reduce a research problem to an exercise. These techniques, however, still start from a lock-free algorithm. Obstruction-freedom is usually what you get from concurrency control mechanisms that abort and retry in the case of conflicts. To achieve lock-freedom, we need to avoid losing and redoing work, or at least doing so repeatedly indefinitely.</p>
<p>See Fraser’s thesis for more formal definitions.</p>
<p>I’ll use “<strong>lockless</strong>” to mean an algorithm implemented without using locks.</p>
<h2 id="compare-and-swap">Compare-and-Swap</h2>
<p>The usual primitive used to implement and describe lockless algorithms is <a href="https://en.wikipedia.org/wiki/Compare-and-swap">compare-and-swap</a>, often just called <code>cas</code>. There are other possibilities, but <code>cas</code> is <a href="https://dl.acm.org/doi/10.1145/114005.102808">universal</a>, relatively simple, and widely implemented, e.g. as the <code>cmpxchg</code> operation for the x86 architecture. The following is a specification of a <code>cas</code> operation in Haskell with the additional note that this intended to be performed atomically (which it would not be in Haskell).</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">cas ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>cas ref old new <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    curr <span class="ot">&lt;-</span> readIORef ref</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> curr <span class="op">==</span> old <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        writeIORef ref new</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> curr</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> curr</span></code></pre></div>
<h2 id="specification-of-multiple-compare-and-swap">Specification of Multiple Compare-and-Swap</h2>
<p>The specification of multiple compare-and-swap is the straightforward extension to the above to several variables.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mcasSpec ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [(<span class="dt">IORef</span> a, a, a)] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>mcasSpec entries <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    eqs <span class="ot">&lt;-</span> forM entries <span class="op">$</span> \(ref, old, _) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        curr <span class="ot">&lt;-</span> readIORef ref</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> (curr <span class="op">==</span> old)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="fu">and</span> eqs <span class="kw">then</span> <span class="kw">do</span> <span class="co">-- if all equal</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        forM_ entries <span class="op">$</span> \(ref, _, new) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>            writeIORef ref new</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> <span class="dt">True</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> <span class="dt">False</span></span></code></pre></div>
<p>The above is, again, intended to be executed atomically. It will be convenient to allow a bit more flexibility in the type producing the type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mcas ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [(<span class="dt">MCASRef</span> a, a, a)] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span></code></pre></div>
<p>where we have</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Abstract.</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">MCASRef</span> a <span class="ot">=</span> <span class="dt">MCASRef</span> {<span class="ot"> unMCASRef ::</span> <span class="dt">IORef</span> (<span class="dt">Either</span> (<span class="dt">T</span> a) a) } <span class="kw">deriving</span> ( <span class="dt">Eq</span> )</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">newMCASRef ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">MCASRef</span> a)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>newMCASRef v <span class="ot">=</span> <span class="dt">MCASRef</span> <span class="op">&lt;$&gt;</span> newIORef (<span class="dt">Right</span> v)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="ot">readMCASRef ::</span> <span class="dt">MCASRef</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- Will be implemented below.</span></span></code></pre></div>
<p>The idea here is that, in addition to values of type <code>a</code>, we can also store values of type <code>T a</code> into the pointers for internal use, and we can unambiguously distinguish them from values of type <code>a</code>. <code>T a</code> can be any type constructor you like.</p>
<p>In the code below, I will assume <code>IORef</code>s have an <code>Ord</code> instance, i.e. that they can be sorted. This is <em>not</em> true, but an approach as in <a href="https://hackage.haskell.org/package/ioref-stable-0.1.1.0">ioref-stable</a> could be used to accomplish this. Alternatively, <code>Ptr</code>s to <code>StablePtr</code>s could be used.</p>
<p>We won’t worry about memory consistency concerns here. That is, we’ll assume sequential consistency where all CPU cores see all updates immediately.</p>
<p>I recommend stopping here and thinking about how you would implement <code>mcas</code> in terms of <code>cas</code> while, of course, achieving the desired atomicity. The solution I’ll present – the one from Fraser’s thesis – is moderately involved, so if the approach you come up with is very simple, then you’ve probably made a mistake. Unsurprisingly, the solution I’ll present makes use of the additional flexibility in the type and the ability to sort <code>IORef</code>s. I’m not claiming it is impossible to accomplish this without these though. For example, you could apply a universal construction which witnesses the universality of <code>cas</code>.</p>
<h2 id="recursive-helping">Recursive Helping</h2>
<p>Lockless algorithms typically proceed by attempting an operation and detecting conflicts, e.g. as in multi-version concurrency control. This requires storing enough information to tell that a conflicting operation has occurred/is occurring. Once a conflict is detected, the simplest solution is typically to abort and retry hoping that there isn’t a conflict the next time. This clearly leads to the possibility of livelock.</p>
<p>Instead of aborting, the later invocation of the operation could instead help the earlier one to complete, thereby getting it out of its way. This ensures that the first invocation will always, eventually complete giving us lock-freedom. However, this doesn’t guarantee that once the second invocation finishes helping the first invocation that a third invocation won’t jump in before the second invocation gets a chance to start on its own work. In this case, the second invocation will help the third invocation to complete before attempting to start itself. A process can end up spending all its time helping other processes while never getting its own work done, leading to starvation.</p>
<p>To perform recursive helping, we need an invocation to store enough information so that subsequent, overlapping invocations are able to assist. To accomplish this, we’ll store a (pointer to a) “descriptor” containing the parameters of the invocation being helped and potentially additional information<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. This is what we’ll use for the <code>T</code> type constructor.</p>
<p>The general approach will be: at the beginning of the operation we will attempt to “install” a descriptor in the first field we touch utilizing <code>cas</code>. There are then three possible outcomes. If we fail and find a value, then the operation has failed. If we fail and find an existing descriptor, then we (potentially recursively) help that descriptor. If we succeed, then we have successfully “acquired” the field and we “help” ourselves. We can have many processes all trying to help the same invocation at the same time, so it is still important that multiple identical help calls don’t interfere with each other. Just because we’re helping an invocation of an operation doesn’t mean that that the original process isn’t still executing.</p>
<p>Since we’ll be replacing pointers to values with pointers to descriptors, reading the value becomes non-trivial. In particular, if when we read a pointer we get a descriptor, we’ll need to help the invocation described to completion. We will need to keep doing this until we successfully read a value.</p>
<h2 id="conditional-compare-and-swap">Conditional Compare-and-Swap</h2>
<p>An operation we’ll use in the implementations of <code>mcas</code> is a conditional compare-and-swap (CCAS) where we only perform the swap if, additionally, an additional variable is set to a given value. It has the following specification.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Specification. Implementations should perform this atomically.</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">ccasSpec ::</span> (<span class="dt">Eq</span> a, <span class="dt">Eq</span> c) <span class="ot">=&gt;</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IORef</span> c <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>ccasSpec ref old new condRef check <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    curr <span class="ot">&lt;-</span> readIORef ref</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    cond <span class="ot">&lt;-</span> readIORef condRef</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> cond <span class="op">==</span> check <span class="op">&amp;&amp;</span> curr <span class="op">==</span> old <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        writeIORef ref new</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> ()</span></code></pre></div>
<p>We’ll need to show that this can be implemented in terms of <code>cas</code>, or rather a version with modifications similar to those mentioned for <code>mcas</code>. This will be a simple instance of the recursive helping approach that will be applied in the implementation of <code>mcas</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">CCASDescriptor</span> a c <span class="ot">=</span> <span class="dt">IORef</span> (<span class="dt">CCASRef</span> a c, a, a, <span class="dt">IORef</span> c, c)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">CCASRef</span> a c <span class="ot">=</span> <span class="dt">CCASRef</span> {<span class="ot"> unCCASRef ::</span> <span class="dt">IORef</span> (<span class="dt">Either</span> (<span class="dt">CCASDescriptor</span> a c) a) } <span class="kw">deriving</span> ( <span class="dt">Eq</span>, <span class="dt">Ord</span> )</span></code></pre></div>
<p>We begin with the types. As described above, a <code>CCASRef</code> is just an <code>IORef</code> that holds either a value or a descriptor, and the descriptor is just an <code>IORef</code> pointing at a tuple holding the arguments to <code>ccas</code>. We won’t actually modify this latter <code>IORef</code> and instead are just using it for its object identity. It could be replaced with a read-only <code>IVar</code> or a <code>Unique</code> could be allocated and used as an identifier instead. In a lower-level language, this <code>IORef</code> corresponds to having a pointer to the descriptor.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">newCCASRef ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">CCASRef</span> a c)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>newCCASRef v <span class="ot">=</span> <span class="dt">CCASRef</span> <span class="op">&lt;$&gt;</span> newIORef (<span class="dt">Right</span> v)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">readCCASRef ::</span> (<span class="dt">Eq</span> a, <span class="dt">Eq</span> c) <span class="ot">=&gt;</span> <span class="dt">CCASRef</span> a c <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>readCCASRef ref <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">&lt;-</span> readIORef (unCCASRef ref)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> x <span class="kw">of</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Right</span> v <span class="ot">-&gt;</span> <span class="fu">return</span> v</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Left</span> d <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            ccasHelp d</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>            readCCASRef ref</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- Not atomic. This CAS can fail even when it would be impossible if `ccas` was truly atomic.</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- Example: ccas a reference to the same value but where the condRef is False. The ccas fails</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- and thus should behave as a no-op, but if a `casCCASRef` occurs during the course of the ccas,</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- the `casCCASRef` can fail even though it should succeed in all cases.</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="ot">casCCASRef ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">CCASRef</span> a c <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>casCCASRef (<span class="dt">CCASRef</span> ref) old new <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    curr <span class="ot">&lt;-</span> cas ref (<span class="dt">Right</span> old) (<span class="dt">Right</span> new)</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (curr <span class="op">==</span> <span class="dt">Right</span> old)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="ot">tryReadCCASRef ::</span> <span class="dt">CCASRef</span> a c <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> a)</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>tryReadCCASRef ref <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">&lt;-</span> readIORef (unCCASRef ref)</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (<span class="kw">case</span> x <span class="kw">of</span> <span class="dt">Left</span> _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>; <span class="dt">Right</span> v <span class="ot">-&gt;</span> <span class="dt">Just</span> v)</span></code></pre></div>
<p>To get them out of the way, the following functions implement the reference-like aspects of a <code>CCASRef</code>. The descriptor is an internal implementation detail. The interface is meant to look like a normal reference to a value of type <code>a</code>. The main notes are:</p>
<ul>
<li>since the <code>CCASRef</code> may not contain a value when we read, we loop helping to complete the <code>ccas</code> until it does,</li>
<li><code>casCCASRef</code> is a slightly simplified <code>cas</code> used in<code>mcas</code> but should be not be considered part of the interface, and</li>
<li><code>tryReadCCASRef</code> is used in the implementation of <code>mcas</code>, but you quite possibly wouldn’t provide it otherwise.</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ccas ::</span> (<span class="dt">Eq</span> a, <span class="dt">Eq</span> c) <span class="ot">=&gt;</span> <span class="dt">CCASRef</span> a c <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IORef</span> c <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>ccas ref old new condRef check <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    d <span class="ot">&lt;-</span> newIORef (ref, old, new, condRef, check)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    v <span class="ot">&lt;-</span> cas (unCCASRef ref) (<span class="dt">Right</span> old) (<span class="dt">Left</span> d)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    go d v</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> go d (<span class="dt">Left</span> d') <span class="ot">=</span> <span class="kw">do</span> <span class="co">-- descriptor already there</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>            ccasHelp d'</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>            v <span class="ot">&lt;-</span> cas (unCCASRef ref) (<span class="dt">Right</span> old) (<span class="dt">Left</span> d)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>            go d v</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        go d (<span class="dt">Right</span> curr) <span class="op">|</span> curr <span class="op">==</span> old <span class="ot">=</span> ccasHelp d <span class="co">-- we succeeded</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>                          <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">return</span> ()   <span class="co">-- we failed</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="ot">ccasHelp ::</span> (<span class="dt">Eq</span> a, <span class="dt">Eq</span> c) <span class="ot">=&gt;</span> <span class="dt">CCASDescriptor</span> a c <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>ccasHelp d <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">CCASRef</span> ref, old, new, condRef, check) <span class="ot">&lt;-</span> readIORef d</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    cond <span class="ot">&lt;-</span> readIORef condRef</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">&lt;-</span> cas ref (<span class="dt">Left</span> d) (<span class="dt">Right</span> <span class="op">$!</span> <span class="kw">if</span> cond <span class="op">==</span> check <span class="kw">then</span> new <span class="kw">else</span> old)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> ()</span></code></pre></div>
<p>Here we illustrate the (not so recursive) helping pattern. <code>ccas</code> allocates a descriptor and then attempts to “acquire” the reference. There are three possibilities.</p>
<ol type="1">
<li>We find a descriptor already there, in which case we help it and then try to acquire the reference again.</li>
<li>The CAS succeeds and thus we successfully “acquire” the reference. We then “help ourselves”.</li>
<li>The CAS fails with an unexpected (non-descriptor) value. Thus, the CCAS fails and we do nothing.</li>
</ol>
<p>Helping, implemented by <code>ccasHelp</code>, just performs the logic of CCAS. If we’ve gotten to <code>ccasHelp</code>, we know the invocation described by the descriptor did, in fact, find the expected value there. By installing our descriptor, we’ve effectively “locked out” any other calls to <code>ccas</code> until we complete. We can thus check the <code>condRef</code> at our leisure. As long as our descriptor is still in the <code>CCASRef</code>, which we check via a <code>cas</code>, we know that there have been no intervening operations, including other processes completing this <code>ccas</code>. <code>ccasHelp</code> is idempotent in the sense that running it multiple times, even in parallel, with the same descriptor is the same as running it once. This is due to the fact that we only (successfully) CAS in the descriptor once, so we can only CAS it out at most once.</p>
<h2 id="multiple-compare-and-swap">Multiple Compare-and-Swap</h2>
<p>The setup for MCAS is much the same as CCAS. The main additional complexity comes from the fact that we need to simultaneously “acquire” multiple references. This is handled by a two-phase approach. In the first phase, we attempt to “acquire” each reference. We proceed to the second phase once we’ve either seen that the MCAS is going to fail, or we have successfully “acquired” each reference. In the second phase, we either reset all the “acquired” references to their old values if the MCAS failed or to their new values if it succeeded. The MCAS will be considered to have occurred atomically at the point we record this decision, via a CAS, i.e. between the two phases.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MCASStatus</span> <span class="ot">=</span> <span class="dt">UNDECIDED</span> <span class="op">|</span> <span class="dt">FAILED</span> <span class="op">|</span> <span class="dt">SUCCESSFUL</span> <span class="kw">deriving</span> ( <span class="dt">Eq</span> )</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MCASDescriptor'</span> a <span class="ot">=</span> <span class="dt">MCASDescriptor</span> [(<span class="dt">MCASRef</span> a, a, a)] (<span class="dt">IORef</span> <span class="dt">MCASStatus</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">MCASDescriptor</span> a <span class="ot">=</span> <span class="dt">IORef</span> (<span class="dt">MCASDescriptor'</span> a)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">MCASRef</span> a <span class="ot">=</span> <span class="dt">MCASRef</span> {<span class="ot"> unMCASRef ::</span> <span class="dt">CCASRef</span> (<span class="dt">Either</span> (<span class="dt">MCASDescriptor</span> a) a) <span class="dt">MCASStatus</span> }</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> ( <span class="dt">Eq</span>, <span class="dt">Ord</span> )</span></code></pre></div>
<p>As with CCAS, an <code>MCASRef</code> is a reference, in this case a <code>CCASRef</code>, that either holds a value or a descriptor. The descriptor holds the arguments of <code>mcas</code>, as with <code>ccas</code>, but it additionally holds a status reference. This status reference will be used as the condition reference of the CCAS. In particular, as we’ll see, we will only perform <code>ccas</code>’s when the status is <code>UNDECIDED</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">newMCASRef ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">MCASRef</span> a)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>newMCASRef v <span class="ot">=</span> <span class="dt">MCASRef</span> <span class="op">&lt;$&gt;</span> newCCASRef (<span class="dt">Right</span> v)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="ot">readMCASRef ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">MCASRef</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>readMCASRef ref <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">&lt;-</span> readCCASRef (unMCASRef ref)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> x <span class="kw">of</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Right</span> v <span class="ot">-&gt;</span> <span class="fu">return</span> v</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Left</span> d <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>            mcasHelp d</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            readMCASRef ref</span></code></pre></div>
<p>There’s nothing to say about the reference interface functions. They are essentially identical to the CCAS ones for the same reasons only with <code>CCASRef</code>s instead of <code>IORef</code>s.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mcas ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [(<span class="dt">MCASRef</span> a, a, a)] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>mcas entries <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    status <span class="ot">&lt;-</span> newIORef <span class="dt">UNDECIDED</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    d <span class="ot">&lt;-</span> newIORef (<span class="dt">MCASDescriptor</span> (sortOn (\(ref, _, _) <span class="ot">-&gt;</span> ref) entries) status)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    mcasHelp d</span></code></pre></div>
<p>The <code>mcas</code> function is fairly straightforward. It allocates a status reference and a descriptor and delegates most of the work to <code>mcasHelp</code>. The main but critical subtlety is the sort. This is critical to ensuring termination.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mcasHelp ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">MCASDescriptor</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>mcasHelp d <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MCASDescriptor</span> entries statusRef <span class="ot">&lt;-</span> readIORef d</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> phase1 [] <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>            _ <span class="ot">&lt;-</span> cas statusRef <span class="dt">UNDECIDED</span> <span class="dt">SUCCESSFUL</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>            phase2</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        phase1 ((<span class="dt">MCASRef</span> ref, old, new)<span class="op">:</span>es) <span class="ot">=</span> tryAcquire ref old new es</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        tryAcquire ref old new es <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>            _ <span class="ot">&lt;-</span> ccas ref (<span class="dt">Right</span> old) (<span class="dt">Left</span> d) statusRef <span class="dt">UNDECIDED</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            v <span class="ot">&lt;-</span> tryReadCCASRef ref</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">case</span> v <span class="kw">of</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Just</span> (<span class="dt">Left</span> d') <span class="op">|</span> d <span class="op">==</span> d' <span class="ot">-&gt;</span> phase1 es <span class="co">-- successful acquisition</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>                               <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">-&gt;</span> <span class="kw">do</span> <span class="co">-- help someone else</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>                                    mcasHelp d'</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>                                    tryAcquire ref old new es</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Just</span> (<span class="dt">Right</span> curr) <span class="op">|</span> curr <span class="op">==</span> old <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>                    status <span class="ot">&lt;-</span> readIORef statusRef</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">if</span> status <span class="op">==</span> <span class="dt">UNDECIDED</span> <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>                        tryAcquire ref old new es <span class="co">-- failed to acquire but could still succeed</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>                        phase2</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>                _ <span class="ot">-&gt;</span> <span class="kw">do</span> <span class="co">-- failed MCAS</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>                    _ <span class="ot">&lt;-</span> cas statusRef <span class="dt">UNDECIDED</span> <span class="dt">FAILED</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>                    phase2</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>        phase2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>            status <span class="ot">&lt;-</span> readIORef statusRef</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> succeeded <span class="ot">=</span> status <span class="op">==</span> <span class="dt">SUCCESSFUL</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>            forM_ entries <span class="op">$</span> \(<span class="dt">MCASRef</span> ref, old, new) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>                casCCASRef ref (<span class="dt">Left</span> d) (<span class="dt">Right</span> (<span class="kw">if</span> succeeded <span class="kw">then</span> new <span class="kw">else</span> old))</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>            <span class="fu">return</span> succeeded</span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>    phase1 entries </span></code></pre></div>
<p><code>phase1</code> attempts to “acquire” each <code>MCASRef</code> by using <code>tryAcquire</code> which will move <code>phase1</code> to the next entry each time it succeeds. Therefore, if <code>phase1</code> reaches the end of the list and there was no interference, we will have successfully “acquired” all references. We record this with a CAS against <code>statusRef</code>. If this CAS succeeds, then the MCAS will be considered successful and conceptually to have occurred at this point. If the CAS fails, then some other process has already completed this MCAS, possibly in success or failure. We then move to <code>phase2</code>.</p>
<p><code>tryAcquire</code> can also detect that the MCAS should fail. In this case, we immediately attempt to record this fact via a CAS into <code>statusRef</code>. As with the successful case, this CAS succeeding marks the conceptual instant that the MCAS completes. As before, we then move on to <code>phase2</code>.</p>
<p>We never enter <code>phase2</code> without <code>statusRef</code> being set to either <code>SUCCESSFUL</code> or <code>FAILED</code>. <code>phase2</code> is completely straightforward. We simply set each “acquired” reference to either the new or old value depending on whether the MCAS succeeded or not. The <code>casCCASRef</code> will fail if either we never got around to “acquiring” a particular reference (in the case of MCAS failure), or if a reference was written to since it was “acquired”. Since such writes conceptually occurred after the MCAS completed, we do not want to overwrite them.</p>
<p>During <code>tryAcquire</code>, there are a few cases that lead to retrying. First, if we find that a reference has already been “acquired” by some other MCAS operation, we recursively help it. Here, the sorting of the references is important to ensure that any MCAS operation we help will never try to help us back. It’s easy to see that without the sorting, if two MCAS operations on the same two references each acquired one of the references, the (concurrent) recursive calls to <code>mcasHelp</code> would become infinite loops. With a total ordering on references, each recursive call to <code>mcasHelp</code> will be at a greater reference and thus must eventually terminate. The other case for <code>tryAcquire</code>, is that the expected value is written after the <code>ccas</code> but before the <code>tryReadCCASRef</code>. In this case, we try again unless the status has already been decided. It might seem like this is just an optimization, and that we could instead treat this as the MCAS failing. However, the intervening write may have written the value that was there before the <code>ccas</code>, meaning that there was never a point at which the MCAS could have failed.</p>
<p>References are only “acquired” at the <code>ccas</code> in <code>phase1</code>. Once the status has been decided, no references may be “acquired” any longer. Since it’s impossible to enter <code>phase2</code> without deciding the status, once one process enters <code>phase2</code>, no processes are capable of “acquiring” references. This makes <code>phase2</code> idempotent and, indeed, each CAS in <code>phase2</code> is independently idempotent. Overlapping executions of <code>phase1</code> are fine essentially because each <code>ccas</code> is idempotent and the <code>statusRef</code> can change at most once.</p>
<p>Let’s see how an <code>mcas</code> interacts with other operations from the perspective of atomicity. If we attempt to read a reference via <code>readMCASRef</code> which is included in the list of references of an ongoing <code>mcas</code>, there are two possibilities. Either that reference has not yet been “acquired” by the <code>mcas</code>, in which case the read will occur conceptually before the MCAS, or it has been “acquired” in which case the read will help the MCAS to completion and then try again after the MCAS. The story is similar for overlapping <code>mcas</code>’s. The <code>mcas</code> which “acquires” the least reference in their intersection will conceptually complete first, either because it literally finishes before the second <code>mcas</code> notices or because the second <code>mcas</code> will help it to completion. Writes are only slightly different.</p>
<p>It is important to note that these operations are NOT atomic with respect to some other reasonable operations. Most notably, they are not atomic with respect to blind writes. It is easy to construct a scenario where two blind writes happen in sequence but the first appears to happen after the <code>mcas</code> and the second before. Except for initialization, I don’t believe there are any blind writes to references involved in a <code>mcas</code> in Fraser’s thesis. Fraser’s thesis does, however, contain <code>cas</code> operations directly against these references. These are also not atomic for exactly the same reason <code>casCCASRef</code> isn’t. That said, Fraser’s uses of <code>cas</code> against <code>MCASRef</code>s are safe, because in each case they just retry until success.</p>
<h2 id="conclusion">Conclusion</h2>
<p>While I’ve gone into a good amount of detail here, I’ve mainly wanted to illustrate the concept of recursive helping. It’s a key concept for lock-free and wait-free algorithm designs, but it also may be a useful idea to have in mind when designing concurrent code even if you aren’t explicitly trying to achieve a lock-free guarantee.</p>
<!--

Scenario:

```               
               |--mcas((a, 1, 11), (b, 2, 22))---|
w(a,1)--w(b,1)----acq(a)------------------acq(b)--
--------------------------w(a,2)--w(b,2)----------
```

`w(a,2)` seems to happen after the `mcas` but `w(b,2)` seems to occur before.
-->
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>MCAS allows you to perform transactions involving multiple updates atomically. STM additionally allows you to perform transactions involving multiple reads and updates atomically.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>While I haven’t attempted it to see if it works out, it seems like you could make a generic “recursive helping” framework by storing an <code>IO</code> action instead. The “descriptors” have the flavor of defunctionalized continuations.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'hedonisticlearning';
        var disqus_identifier = '45e34423-669d-4d74-9744-2532cb1aaca0';
        var disqus_title = 'Recursive Helping';
        
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript> 
</div>

        </div><!-- /.blog-main -->
        
        
      </div><!-- /.row -->
    </div><!-- /.container -->

    <footer class="blog-footer">
      <p>Site generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
      <p>
        <a href="#">Back to top</a>
      </p>
    </footer>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js" integrity="sha384-6ePHh72Rl3hKio4HiJ841psfsRJveeS+aLoaEf3BWfS+gTF0XdAqku2ka8VddikM" crossorigin="anonymous"></script> -->
    <script type="text/javascript" src="../js/jquery.min.js"></script>
    <script type="text/javascript" src="../js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <!--<script src="../../assets/js/ie10-viewport-bug-workaround.js"></script>-->
    <script type="text/javascript">
        var disqus_shortname = 'hedonisticlearning';
        (function () {
            var s = document.createElement('script'); s.async = true;
            s.type = 'text/javascript';
            s.src = 'https://' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
    <!-- <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_HTMLorMML.js" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script> -->
    <script type="text/javascript" src="../js/MathJax-2.7.7/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          TeX: {
              extensions: ['/js/xypic.js']
          },
          tex2jax: {
              inlineMath: [['|','|']]
          }
        });
    </script>
  </body>
</html>
